// Package spotify provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package spotify

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	Oauth_2_0Scopes = "oauth_2_0.Scopes"
)

// Defines values for AlbumBaseAlbumType.
const (
	AlbumBaseAlbumTypeAlbum       AlbumBaseAlbumType = "album"
	AlbumBaseAlbumTypeCompilation AlbumBaseAlbumType = "compilation"
	AlbumBaseAlbumTypeSingle      AlbumBaseAlbumType = "single"
)

// Defines values for AlbumBaseReleaseDatePrecision.
const (
	AlbumBaseReleaseDatePrecisionDay   AlbumBaseReleaseDatePrecision = "day"
	AlbumBaseReleaseDatePrecisionMonth AlbumBaseReleaseDatePrecision = "month"
	AlbumBaseReleaseDatePrecisionYear  AlbumBaseReleaseDatePrecision = "year"
)

// Defines values for AlbumBaseType.
const (
	AlbumBaseTypeAlbum AlbumBaseType = "album"
)

// Defines values for AlbumObjectAlbumType.
const (
	AlbumObjectAlbumTypeAlbum       AlbumObjectAlbumType = "album"
	AlbumObjectAlbumTypeCompilation AlbumObjectAlbumType = "compilation"
	AlbumObjectAlbumTypeSingle      AlbumObjectAlbumType = "single"
)

// Defines values for AlbumObjectReleaseDatePrecision.
const (
	AlbumObjectReleaseDatePrecisionDay   AlbumObjectReleaseDatePrecision = "day"
	AlbumObjectReleaseDatePrecisionMonth AlbumObjectReleaseDatePrecision = "month"
	AlbumObjectReleaseDatePrecisionYear  AlbumObjectReleaseDatePrecision = "year"
)

// Defines values for AlbumObjectType.
const (
	AlbumObjectTypeAlbum AlbumObjectType = "album"
)

// Defines values for AlbumRestrictionObjectReason.
const (
	Explicit AlbumRestrictionObjectReason = "explicit"
	Market   AlbumRestrictionObjectReason = "market"
	Product  AlbumRestrictionObjectReason = "product"
)

// Defines values for ArtistDiscographyAlbumObjectAlbumGroup.
const (
	ArtistDiscographyAlbumObjectAlbumGroupAlbum       ArtistDiscographyAlbumObjectAlbumGroup = "album"
	ArtistDiscographyAlbumObjectAlbumGroupAppearsOn   ArtistDiscographyAlbumObjectAlbumGroup = "appears_on"
	ArtistDiscographyAlbumObjectAlbumGroupCompilation ArtistDiscographyAlbumObjectAlbumGroup = "compilation"
	ArtistDiscographyAlbumObjectAlbumGroupSingle      ArtistDiscographyAlbumObjectAlbumGroup = "single"
)

// Defines values for ArtistDiscographyAlbumObjectAlbumType.
const (
	ArtistDiscographyAlbumObjectAlbumTypeAlbum       ArtistDiscographyAlbumObjectAlbumType = "album"
	ArtistDiscographyAlbumObjectAlbumTypeCompilation ArtistDiscographyAlbumObjectAlbumType = "compilation"
	ArtistDiscographyAlbumObjectAlbumTypeSingle      ArtistDiscographyAlbumObjectAlbumType = "single"
)

// Defines values for ArtistDiscographyAlbumObjectReleaseDatePrecision.
const (
	ArtistDiscographyAlbumObjectReleaseDatePrecisionDay   ArtistDiscographyAlbumObjectReleaseDatePrecision = "day"
	ArtistDiscographyAlbumObjectReleaseDatePrecisionMonth ArtistDiscographyAlbumObjectReleaseDatePrecision = "month"
	ArtistDiscographyAlbumObjectReleaseDatePrecisionYear  ArtistDiscographyAlbumObjectReleaseDatePrecision = "year"
)

// Defines values for ArtistDiscographyAlbumObjectType.
const (
	ArtistDiscographyAlbumObjectTypeAlbum ArtistDiscographyAlbumObjectType = "album"
)

// Defines values for ArtistObjectType.
const (
	ArtistObjectTypeArtist ArtistObjectType = "artist"
)

// Defines values for AudioFeaturesObjectType.
const (
	AudioFeatures AudioFeaturesObjectType = "audio_features"
)

// Defines values for AudiobookBaseType.
const (
	AudiobookBaseTypeAudiobook AudiobookBaseType = "audiobook"
)

// Defines values for AudiobookObjectType.
const (
	AudiobookObjectTypeAudiobook AudiobookObjectType = "audiobook"
)

// Defines values for ChapterBaseReleaseDatePrecision.
const (
	ChapterBaseReleaseDatePrecisionDay   ChapterBaseReleaseDatePrecision = "day"
	ChapterBaseReleaseDatePrecisionMonth ChapterBaseReleaseDatePrecision = "month"
	ChapterBaseReleaseDatePrecisionYear  ChapterBaseReleaseDatePrecision = "year"
)

// Defines values for ChapterBaseType.
const (
	ChapterBaseTypeEpisode ChapterBaseType = "episode"
)

// Defines values for ChapterObjectReleaseDatePrecision.
const (
	ChapterObjectReleaseDatePrecisionDay   ChapterObjectReleaseDatePrecision = "day"
	ChapterObjectReleaseDatePrecisionMonth ChapterObjectReleaseDatePrecision = "month"
	ChapterObjectReleaseDatePrecisionYear  ChapterObjectReleaseDatePrecision = "year"
)

// Defines values for ChapterObjectType.
const (
	ChapterObjectTypeEpisode ChapterObjectType = "episode"
)

// Defines values for EpisodeBaseReleaseDatePrecision.
const (
	EpisodeBaseReleaseDatePrecisionDay   EpisodeBaseReleaseDatePrecision = "day"
	EpisodeBaseReleaseDatePrecisionMonth EpisodeBaseReleaseDatePrecision = "month"
	EpisodeBaseReleaseDatePrecisionYear  EpisodeBaseReleaseDatePrecision = "year"
)

// Defines values for EpisodeBaseType.
const (
	EpisodeBaseTypeEpisode EpisodeBaseType = "episode"
)

// Defines values for EpisodeObjectReleaseDatePrecision.
const (
	EpisodeObjectReleaseDatePrecisionDay   EpisodeObjectReleaseDatePrecision = "day"
	EpisodeObjectReleaseDatePrecisionMonth EpisodeObjectReleaseDatePrecision = "month"
	EpisodeObjectReleaseDatePrecisionYear  EpisodeObjectReleaseDatePrecision = "year"
)

// Defines values for EpisodeObjectType.
const (
	EpisodeObjectTypeEpisode EpisodeObjectType = "episode"
)

// Defines values for PlaylistOwnerObjectType.
const (
	PlaylistOwnerObjectTypeUser PlaylistOwnerObjectType = "user"
)

// Defines values for PlaylistUserObjectType.
const (
	PlaylistUserObjectTypeUser PlaylistUserObjectType = "user"
)

// Defines values for PublicUserObjectType.
const (
	PublicUserObjectTypeUser PublicUserObjectType = "user"
)

// Defines values for SectionObjectMode.
const (
	Minus1 SectionObjectMode = -1
	N0     SectionObjectMode = 0
	N1     SectionObjectMode = 1
)

// Defines values for ShowBaseType.
const (
	ShowBaseTypeShow ShowBaseType = "show"
)

// Defines values for ShowObjectType.
const (
	ShowObjectTypeShow ShowObjectType = "show"
)

// Defines values for SimplifiedAlbumObjectAlbumType.
const (
	SimplifiedAlbumObjectAlbumTypeAlbum       SimplifiedAlbumObjectAlbumType = "album"
	SimplifiedAlbumObjectAlbumTypeCompilation SimplifiedAlbumObjectAlbumType = "compilation"
	SimplifiedAlbumObjectAlbumTypeSingle      SimplifiedAlbumObjectAlbumType = "single"
)

// Defines values for SimplifiedAlbumObjectReleaseDatePrecision.
const (
	SimplifiedAlbumObjectReleaseDatePrecisionDay   SimplifiedAlbumObjectReleaseDatePrecision = "day"
	SimplifiedAlbumObjectReleaseDatePrecisionMonth SimplifiedAlbumObjectReleaseDatePrecision = "month"
	SimplifiedAlbumObjectReleaseDatePrecisionYear  SimplifiedAlbumObjectReleaseDatePrecision = "year"
)

// Defines values for SimplifiedAlbumObjectType.
const (
	SimplifiedAlbumObjectTypeAlbum SimplifiedAlbumObjectType = "album"
)

// Defines values for SimplifiedArtistObjectType.
const (
	SimplifiedArtistObjectTypeArtist SimplifiedArtistObjectType = "artist"
)

// Defines values for SimplifiedAudiobookObjectType.
const (
	Audiobook SimplifiedAudiobookObjectType = "audiobook"
)

// Defines values for SimplifiedChapterObjectReleaseDatePrecision.
const (
	SimplifiedChapterObjectReleaseDatePrecisionDay   SimplifiedChapterObjectReleaseDatePrecision = "day"
	SimplifiedChapterObjectReleaseDatePrecisionMonth SimplifiedChapterObjectReleaseDatePrecision = "month"
	SimplifiedChapterObjectReleaseDatePrecisionYear  SimplifiedChapterObjectReleaseDatePrecision = "year"
)

// Defines values for SimplifiedChapterObjectType.
const (
	SimplifiedChapterObjectTypeEpisode SimplifiedChapterObjectType = "episode"
)

// Defines values for SimplifiedEpisodeObjectReleaseDatePrecision.
const (
	SimplifiedEpisodeObjectReleaseDatePrecisionDay   SimplifiedEpisodeObjectReleaseDatePrecision = "day"
	SimplifiedEpisodeObjectReleaseDatePrecisionMonth SimplifiedEpisodeObjectReleaseDatePrecision = "month"
	SimplifiedEpisodeObjectReleaseDatePrecisionYear  SimplifiedEpisodeObjectReleaseDatePrecision = "year"
)

// Defines values for SimplifiedEpisodeObjectType.
const (
	SimplifiedEpisodeObjectTypeEpisode SimplifiedEpisodeObjectType = "episode"
)

// Defines values for SimplifiedShowObjectType.
const (
	Show SimplifiedShowObjectType = "show"
)

// Defines values for TrackObjectType.
const (
	Track TrackObjectType = "track"
)

// Defines values for UnfollowArtistsUsersParamsType.
const (
	UnfollowArtistsUsersParamsTypeArtist UnfollowArtistsUsersParamsType = "artist"
	UnfollowArtistsUsersParamsTypeUser   UnfollowArtistsUsersParamsType = "user"
)

// Defines values for GetFollowedParamsType.
const (
	GetFollowedParamsTypeArtist GetFollowedParamsType = "artist"
)

// Defines values for FollowArtistsUsersParamsType.
const (
	FollowArtistsUsersParamsTypeArtist FollowArtistsUsersParamsType = "artist"
	FollowArtistsUsersParamsTypeUser   FollowArtistsUsersParamsType = "user"
)

// Defines values for CheckCurrentUserFollowsParamsType.
const (
	Artist CheckCurrentUserFollowsParamsType = "artist"
	User   CheckCurrentUserFollowsParamsType = "user"
)

// Defines values for GetUsersTopArtistsAndTracksParamsType.
const (
	Artists GetUsersTopArtistsAndTracksParamsType = "artists"
	Tracks  GetUsersTopArtistsAndTracksParamsType = "tracks"
)

// Defines values for SearchParamsType.
const (
	SearchParamsTypeAlbum     SearchParamsType = "album"
	SearchParamsTypeArtist    SearchParamsType = "artist"
	SearchParamsTypeAudiobook SearchParamsType = "audiobook"
	SearchParamsTypeEpisode   SearchParamsType = "episode"
	SearchParamsTypePlaylist  SearchParamsType = "playlist"
	SearchParamsTypeShow      SearchParamsType = "show"
	SearchParamsTypeTrack     SearchParamsType = "track"
)

// Defines values for SearchParamsIncludeExternal.
const (
	Audio SearchParamsIncludeExternal = "audio"
)

// AlbumBase defines model for AlbumBase.
type AlbumBase struct {
	// AlbumType The type of the album.
	AlbumType AlbumBaseAlbumType `json:"album_type"`

	// AvailableMarkets The markets in which the album is available: [ISO 3166-1 alpha-2 country codes](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). _**NOTE**: an album is considered available in a market when at least 1 of its tracks is available in that market._
	AvailableMarkets []string `json:"available_markets"`

	// ExternalUrls Known external URLs for this album.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the album.
	Href string `json:"href"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Id string `json:"id"`

	// Images The cover art for the album in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Name The name of the album. In case of an album takedown, the value may be an empty string.
	Name string `json:"name"`

	// ReleaseDate The date the album was first released.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision AlbumBaseReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *AlbumRestrictionObject `json:"restrictions,omitempty"`

	// TotalTracks The number of tracks in the album.
	TotalTracks int `json:"total_tracks"`

	// Type The object type.
	Type AlbumBaseType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Uri string `json:"uri"`
}

// AlbumBaseAlbumType The type of the album.
type AlbumBaseAlbumType string

// AlbumBaseReleaseDatePrecision The precision with which `release_date` value is known.
type AlbumBaseReleaseDatePrecision string

// AlbumBaseType The object type.
type AlbumBaseType string

// AlbumObject defines model for AlbumObject.
type AlbumObject struct {
	// AlbumType The type of the album.
	AlbumType AlbumObjectAlbumType `json:"album_type"`

	// Artists The artists of the album. Each artist object includes a link in `href` to more detailed information about the artist.
	Artists *[]SimplifiedArtistObject `json:"artists,omitempty"`

	// AvailableMarkets The markets in which the album is available: [ISO 3166-1 alpha-2 country codes](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). _**NOTE**: an album is considered available in a market when at least 1 of its tracks is available in that market._
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the album.
	Copyrights *[]CopyrightObject `json:"copyrights,omitempty"`

	// ExternalIds Known external IDs for the album.
	ExternalIds *ExternalIdObject `json:"external_ids,omitempty"`

	// ExternalUrls Known external URLs for this album.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Genres **Deprecated** The array is always empty.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Genres *[]string `json:"genres,omitempty"`

	// Href A link to the Web API endpoint providing full details of the album.
	Href string `json:"href"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Id string `json:"id"`

	// Images The cover art for the album in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Label The label associated with the album.
	Label *string `json:"label,omitempty"`

	// Name The name of the album. In case of an album takedown, the value may be an empty string.
	Name string `json:"name"`

	// Popularity The popularity of the album. The value will be between 0 and 100, with 100 being the most popular.
	Popularity *int `json:"popularity,omitempty"`

	// ReleaseDate The date the album was first released.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision AlbumObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *AlbumRestrictionObject `json:"restrictions,omitempty"`

	// TotalTracks The number of tracks in the album.
	TotalTracks int `json:"total_tracks"`

	// Tracks The tracks of the album.
	Tracks *PagingSimplifiedTrackObject `json:"tracks,omitempty"`

	// Type The object type.
	Type AlbumObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Uri string `json:"uri"`
}

// AlbumObjectAlbumType The type of the album.
type AlbumObjectAlbumType string

// AlbumObjectReleaseDatePrecision The precision with which `release_date` value is known.
type AlbumObjectReleaseDatePrecision string

// AlbumObjectType The object type.
type AlbumObjectType string

// AlbumRestrictionObject defines model for AlbumRestrictionObject.
type AlbumRestrictionObject struct {
	// Reason The reason for the restriction. Albums may be restricted if the content is not available in a given market, to the user's subscription type, or when the user's account is set to not play explicit content.
	// Additional reasons may be added in the future.
	Reason *AlbumRestrictionObjectReason `json:"reason,omitempty"`
}

// AlbumRestrictionObjectReason The reason for the restriction. Albums may be restricted if the content is not available in a given market, to the user's subscription type, or when the user's account is set to not play explicit content.
// Additional reasons may be added in the future.
type AlbumRestrictionObjectReason string

// ArtistDiscographyAlbumObject defines model for ArtistDiscographyAlbumObject.
type ArtistDiscographyAlbumObject struct {
	// AlbumGroup This field describes the relationship between the artist and the album.
	AlbumGroup ArtistDiscographyAlbumObjectAlbumGroup `json:"album_group"`

	// AlbumType The type of the album.
	AlbumType ArtistDiscographyAlbumObjectAlbumType `json:"album_type"`

	// Artists The artists of the album. Each artist object includes a link in `href` to more detailed information about the artist.
	Artists []SimplifiedArtistObject `json:"artists"`

	// AvailableMarkets The markets in which the album is available: [ISO 3166-1 alpha-2 country codes](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). _**NOTE**: an album is considered available in a market when at least 1 of its tracks is available in that market._
	AvailableMarkets []string `json:"available_markets"`

	// ExternalUrls Known external URLs for this album.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the album.
	Href string `json:"href"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Id string `json:"id"`

	// Images The cover art for the album in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Name The name of the album. In case of an album takedown, the value may be an empty string.
	Name string `json:"name"`

	// ReleaseDate The date the album was first released.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision ArtistDiscographyAlbumObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *AlbumRestrictionObject `json:"restrictions,omitempty"`

	// TotalTracks The number of tracks in the album.
	TotalTracks int `json:"total_tracks"`

	// Type The object type.
	Type ArtistDiscographyAlbumObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Uri string `json:"uri"`
}

// ArtistDiscographyAlbumObjectAlbumGroup This field describes the relationship between the artist and the album.
type ArtistDiscographyAlbumObjectAlbumGroup string

// ArtistDiscographyAlbumObjectAlbumType The type of the album.
type ArtistDiscographyAlbumObjectAlbumType string

// ArtistDiscographyAlbumObjectReleaseDatePrecision The precision with which `release_date` value is known.
type ArtistDiscographyAlbumObjectReleaseDatePrecision string

// ArtistDiscographyAlbumObjectType The object type.
type ArtistDiscographyAlbumObjectType string

// ArtistObject defines model for ArtistObject.
type ArtistObject struct {
	// ExternalUrls Known external URLs for this artist.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Followers Information about the followers of the artist.
	Followers *FollowersObject `json:"followers,omitempty"`

	// Genres A list of the genres the artist is associated with. If not yet classified, the array is empty.
	Genres *[]string `json:"genres,omitempty"`

	// Href A link to the Web API endpoint providing full details of the artist.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the artist.
	Id *string `json:"id,omitempty"`

	// Images Images of the artist in various sizes, widest first.
	Images *[]ImageObject `json:"images,omitempty"`

	// Name The name of the artist.
	Name *string `json:"name,omitempty"`

	// Popularity The popularity of the artist. The value will be between 0 and 100, with 100 being the most popular. The artist's popularity is calculated from the popularity of all the artist's tracks.
	Popularity *int `json:"popularity,omitempty"`

	// Type The object type.
	Type *ArtistObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the artist.
	Uri *string `json:"uri,omitempty"`
}

// ArtistObjectType The object type.
type ArtistObjectType string

// AudioAnalysisObject defines model for AudioAnalysisObject.
type AudioAnalysisObject struct {
	// Bars The time intervals of the bars throughout the track. A bar (or measure) is a segment of time defined as a given number of beats.
	Bars *[]TimeIntervalObject `json:"bars,omitempty"`

	// Beats The time intervals of beats throughout the track. A beat is the basic time unit of a piece of music; for example, each tick of a metronome. Beats are typically multiples of tatums.
	Beats *[]TimeIntervalObject `json:"beats,omitempty"`
	Meta  *struct {
		// AnalysisTime The amount of time taken to analyze this track.
		AnalysisTime *float32 `json:"analysis_time,omitempty"`

		// AnalyzerVersion The version of the Analyzer used to analyze this track.
		AnalyzerVersion *string `json:"analyzer_version,omitempty"`

		// DetailedStatus A detailed status code for this track. If analysis data is missing, this code may explain why.
		DetailedStatus *string `json:"detailed_status,omitempty"`

		// InputProcess The method used to read the track's audio data.
		InputProcess *string `json:"input_process,omitempty"`

		// Platform The platform used to read the track's audio data.
		Platform *string `json:"platform,omitempty"`

		// StatusCode The return code of the analyzer process. 0 if successful, 1 if any errors occurred.
		StatusCode *int `json:"status_code,omitempty"`

		// Timestamp The Unix timestamp (in seconds) at which this track was analyzed.
		Timestamp *int `json:"timestamp,omitempty"`
	} `json:"meta,omitempty"`

	// Sections Sections are defined by large variations in rhythm or timbre, e.g. chorus, verse, bridge, guitar solo, etc. Each section contains its own descriptions of tempo, key, mode, time_signature, and loudness.
	Sections *[]SectionObject `json:"sections,omitempty"`

	// Segments Each segment contains a roughly conisistent sound throughout its duration.
	Segments *[]SegmentObject `json:"segments,omitempty"`

	// Tatums A tatum represents the lowest regular pulse train that a listener intuitively infers from the timing of perceived musical events (segments).
	Tatums *[]TimeIntervalObject `json:"tatums,omitempty"`
	Track  *struct {
		// AnalysisChannels The number of channels used for analysis. If 1, all channels are summed together to mono before analysis.
		AnalysisChannels *int `json:"analysis_channels,omitempty"`

		// AnalysisSampleRate The sample rate used to decode and analyze this track. May differ from the actual sample rate of this track available on Spotify.
		AnalysisSampleRate *int `json:"analysis_sample_rate,omitempty"`

		// CodeVersion A version number for the Echo Nest Musical Fingerprint format used in the codestring field.
		CodeVersion *float32 `json:"code_version,omitempty"`

		// Codestring An [Echo Nest Musical Fingerprint (ENMFP)](https://academiccommons.columbia.edu/doi/10.7916/D8Q248M4) codestring for this track.
		Codestring *string `json:"codestring,omitempty"`

		// Duration Length of the track in seconds.
		Duration *float32 `json:"duration,omitempty"`

		// EchoprintVersion A version number for the EchoPrint format used in the echoprintstring field.
		EchoprintVersion *float32 `json:"echoprint_version,omitempty"`

		// Echoprintstring An [EchoPrint](https://github.com/spotify/echoprint-codegen) codestring for this track.
		Echoprintstring *string `json:"echoprintstring,omitempty"`

		// EndOfFadeIn The time, in seconds, at which the track's fade-in period ends. If the track has no fade-in, this will be 0.0.
		EndOfFadeIn *float32 `json:"end_of_fade_in,omitempty"`

		// Key The key the track is in. Integers map to pitches using standard [Pitch Class notation](https://en.wikipedia.org/wiki/Pitch_class). E.g. 0 = C, 1 = C♯/D♭, 2 = D, and so on. If no key was detected, the value is -1.
		Key *Key `json:"key,omitempty"`

		// KeyConfidence The confidence, from 0.0 to 1.0, of the reliability of the `key`.
		KeyConfidence *float32 `json:"key_confidence,omitempty"`

		// Loudness The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typically range between -60 and 0 db.
		Loudness *Loudness `json:"loudness,omitempty"`

		// Mode Mode indicates the modality (major or minor) of a track, the type of scale from which its melodic content is derived. Major is represented by 1 and minor is 0.
		Mode *Mode `json:"mode,omitempty"`

		// ModeConfidence The confidence, from 0.0 to 1.0, of the reliability of the `mode`.
		ModeConfidence *float32 `json:"mode_confidence,omitempty"`

		// NumSamples The exact number of audio samples analyzed from this track. See also `analysis_sample_rate`.
		NumSamples *int `json:"num_samples,omitempty"`

		// OffsetSeconds An offset to the start of the region of the track that was analyzed. (As the entire track is analyzed, this should always be 0.)
		OffsetSeconds *int `json:"offset_seconds,omitempty"`

		// RhythmVersion A version number for the Rhythmstring used in the rhythmstring field.
		RhythmVersion *float32 `json:"rhythm_version,omitempty"`

		// Rhythmstring A Rhythmstring for this track. The format of this string is similar to the Synchstring.
		Rhythmstring *string `json:"rhythmstring,omitempty"`

		// SampleMd5 This field will always contain the empty string.
		SampleMd5 *string `json:"sample_md5,omitempty"`

		// StartOfFadeOut The time, in seconds, at which the track's fade-out period starts. If the track has no fade-out, this should match the track's length.
		StartOfFadeOut *float32 `json:"start_of_fade_out,omitempty"`

		// SynchVersion A version number for the Synchstring used in the synchstring field.
		SynchVersion *float32 `json:"synch_version,omitempty"`

		// Synchstring A [Synchstring](https://github.com/echonest/synchdata) for this track.
		Synchstring *string `json:"synchstring,omitempty"`

		// Tempo The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.
		Tempo *Tempo `json:"tempo,omitempty"`

		// TempoConfidence The confidence, from 0.0 to 1.0, of the reliability of the `tempo`.
		TempoConfidence *float32 `json:"tempo_confidence,omitempty"`

		// TimeSignature An estimated time signature. The time signature (meter) is a notational convention to specify how many beats are in each bar (or measure). The time signature ranges from 3 to 7 indicating time signatures of "3/4", to "7/4".
		TimeSignature *TimeSignature `json:"time_signature,omitempty"`

		// TimeSignatureConfidence The confidence, from 0.0 to 1.0, of the reliability of the `time_signature`.
		TimeSignatureConfidence *float32 `json:"time_signature_confidence,omitempty"`

		// WindowSeconds The length of the region of the track was analyzed, if a subset of the track was analyzed. (As the entire track is analyzed, this should always be 0.)
		WindowSeconds *int `json:"window_seconds,omitempty"`
	} `json:"track,omitempty"`
}

// AudioFeaturesObject defines model for AudioFeaturesObject.
type AudioFeaturesObject struct {
	// Acousticness A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic.
	Acousticness *float32 `json:"acousticness,omitempty"`

	// AnalysisUrl A URL to access the full audio analysis of this track. An access token is required to access this data.
	AnalysisUrl *string `json:"analysis_url,omitempty"`

	// Danceability Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable.
	Danceability *float32 `json:"danceability,omitempty"`

	// DurationMs The duration of the track in milliseconds.
	DurationMs *int `json:"duration_ms,omitempty"`

	// Energy Energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. Perceptual features contributing to this attribute include dynamic range, perceived loudness, timbre, onset rate, and general entropy.
	Energy *float32 `json:"energy,omitempty"`

	// Id The Spotify ID for the track.
	Id *string `json:"id,omitempty"`

	// Instrumentalness Predicts whether a track contains no vocals. "Ooh" and "aah" sounds are treated as instrumental in this context. Rap or spoken word tracks are clearly "vocal". The closer the instrumentalness value is to 1.0, the greater likelihood the track contains no vocal content. Values above 0.5 are intended to represent instrumental tracks, but confidence is higher as the value approaches 1.0.
	Instrumentalness *float32 `json:"instrumentalness,omitempty"`

	// Key The key the track is in. Integers map to pitches using standard [Pitch Class notation](https://en.wikipedia.org/wiki/Pitch_class). E.g. 0 = C, 1 = C♯/D♭, 2 = D, and so on. If no key was detected, the value is -1.
	Key *Key `json:"key,omitempty"`

	// Liveness Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides strong likelihood that the track is live.
	Liveness *float32 `json:"liveness,omitempty"`

	// Loudness The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typically range between -60 and 0 db.
	Loudness *Loudness `json:"loudness,omitempty"`

	// Mode Mode indicates the modality (major or minor) of a track, the type of scale from which its melodic content is derived. Major is represented by 1 and minor is 0.
	Mode *Mode `json:"mode,omitempty"`

	// Speechiness Speechiness detects the presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value. Values above 0.66 describe tracks that are probably made entirely of spoken words. Values between 0.33 and 0.66 describe tracks that may contain both music and speech, either in sections or layered, including such cases as rap music. Values below 0.33 most likely represent music and other non-speech-like tracks.
	Speechiness *float32 `json:"speechiness,omitempty"`

	// Tempo The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.
	Tempo *Tempo `json:"tempo,omitempty"`

	// TimeSignature An estimated time signature. The time signature (meter) is a notational convention to specify how many beats are in each bar (or measure). The time signature ranges from 3 to 7 indicating time signatures of "3/4", to "7/4".
	TimeSignature *TimeSignature `json:"time_signature,omitempty"`

	// TrackHref A link to the Web API endpoint providing full details of the track.
	TrackHref *string `json:"track_href,omitempty"`

	// Type The object type.
	Type *AudioFeaturesObjectType `json:"type,omitempty"`

	// Uri The Spotify URI for the track.
	Uri *string `json:"uri,omitempty"`

	// Valence A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).
	Valence *float32 `json:"valence,omitempty"`
}

// AudioFeaturesObjectType The object type.
type AudioFeaturesObjectType string

// AudiobookBase defines model for AudiobookBase.
type AudiobookBase struct {
	// Authors The author(s) for the audiobook.
	Authors []AuthorObject `json:"authors"`

	// AvailableMarkets A list of the countries in which the audiobook can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the audiobook.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the audiobook. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Edition The edition of the audiobook.
	Edition *string `json:"edition,omitempty"`

	// Explicit Whether or not the audiobook has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this audiobook.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the audiobook.
	Href string `json:"href"`

	// HtmlDescription A description of the audiobook. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Id string `json:"id"`

	// Images The cover art for the audiobook in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Languages A list of the languages used in the audiobook, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the audiobook.
	MediaType string `json:"media_type"`

	// Name The name of the audiobook.
	Name string `json:"name"`

	// Narrators The narrator(s) for the audiobook.
	Narrators []NarratorObject `json:"narrators"`

	// Publisher The publisher of the audiobook.
	Publisher string `json:"publisher"`

	// TotalChapters The number of chapters in this audiobook.
	TotalChapters int `json:"total_chapters"`

	// Type The object type.
	Type AudiobookBaseType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Uri string `json:"uri"`
}

// AudiobookBaseType The object type.
type AudiobookBaseType string

// AudiobookObject defines model for AudiobookObject.
type AudiobookObject struct {
	// Authors The author(s) for the audiobook.
	Authors []AuthorObject `json:"authors"`

	// AvailableMarkets A list of the countries in which the audiobook can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Chapters The chapters of the audiobook.
	Chapters PagingSimplifiedChapterObject `json:"chapters"`

	// Copyrights The copyright statements of the audiobook.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the audiobook. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Edition The edition of the audiobook.
	Edition *string `json:"edition,omitempty"`

	// Explicit Whether or not the audiobook has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this audiobook.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the audiobook.
	Href string `json:"href"`

	// HtmlDescription A description of the audiobook. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Id string `json:"id"`

	// Images The cover art for the audiobook in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Languages A list of the languages used in the audiobook, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the audiobook.
	MediaType string `json:"media_type"`

	// Name The name of the audiobook.
	Name string `json:"name"`

	// Narrators The narrator(s) for the audiobook.
	Narrators []NarratorObject `json:"narrators"`

	// Publisher The publisher of the audiobook.
	Publisher string `json:"publisher"`

	// TotalChapters The number of chapters in this audiobook.
	TotalChapters int `json:"total_chapters"`

	// Type The object type.
	Type AudiobookObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Uri string `json:"uri"`
}

// AudiobookObjectType The object type.
type AudiobookObjectType string

// AuthorObject defines model for AuthorObject.
type AuthorObject struct {
	// Name The name of the author.
	Name *string `json:"name,omitempty"`
}

// CategoryObject defines model for CategoryObject.
type CategoryObject struct {
	// Href A link to the Web API endpoint returning full details of the category.
	Href string `json:"href"`

	// Icons The category icon, in various sizes.
	Icons []ImageObject `json:"icons"`

	// Id The [Spotify category ID](/documentation/web-api/concepts/spotify-uris-ids) of the category.
	Id string `json:"id"`

	// Name The name of the category.
	Name string `json:"name"`
}

// ChapterBase defines model for ChapterBase.
type ChapterBase struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the chapter. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// AvailableMarkets A list of the countries in which the chapter can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets *[]string `json:"available_markets,omitempty"`

	// ChapterNumber The number of the chapter
	ChapterNumber int `json:"chapter_number"`

	// Description A description of the chapter. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The chapter length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the chapter has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this chapter.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the chapter.
	Href string `json:"href"`

	// HtmlDescription A description of the chapter. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Id string `json:"id"`

	// Images The cover art for the chapter in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsPlayable True if the chapter is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Languages A list of the languages used in the chapter, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the chapter.
	Name string `json:"name"`

	// ReleaseDate The date the chapter was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision ChapterBaseReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *ChapterRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the chapter. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Type The object type.
	Type ChapterBaseType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Uri string `json:"uri"`
}

// ChapterBaseReleaseDatePrecision The precision with which `release_date` value is known.
type ChapterBaseReleaseDatePrecision string

// ChapterBaseType The object type.
type ChapterBaseType string

// ChapterObject defines model for ChapterObject.
type ChapterObject struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the chapter. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// Audiobook The audiobook for which the chapter belongs.
	Audiobook SimplifiedAudiobookObject `json:"audiobook"`

	// AvailableMarkets A list of the countries in which the chapter can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets *[]string `json:"available_markets,omitempty"`

	// ChapterNumber The number of the chapter
	ChapterNumber int `json:"chapter_number"`

	// Description A description of the chapter. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The chapter length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the chapter has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this chapter.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the chapter.
	Href string `json:"href"`

	// HtmlDescription A description of the chapter. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Id string `json:"id"`

	// Images The cover art for the chapter in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsPlayable True if the chapter is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Languages A list of the languages used in the chapter, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the chapter.
	Name string `json:"name"`

	// ReleaseDate The date the chapter was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision ChapterObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *ChapterRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the chapter. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Type The object type.
	Type ChapterObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Uri string `json:"uri"`
}

// ChapterObjectReleaseDatePrecision The precision with which `release_date` value is known.
type ChapterObjectReleaseDatePrecision string

// ChapterObjectType The object type.
type ChapterObjectType string

// ChapterRestrictionObject defines model for ChapterRestrictionObject.
type ChapterRestrictionObject struct {
	// Reason The reason for the restriction. Supported values:
	// - `market` - The content item is not available in the given market.
	// - `product` - The content item is not available for the user's subscription type.
	// - `explicit` - The content item is explicit and the user's account is set to not play explicit content.
	// - `payment_required` - Payment is required to play the content item.
	//
	// Additional reasons may be added in the future.
	// **Note**: If you use this field, make sure that your application safely handles unknown values.
	Reason *string `json:"reason,omitempty"`
}

// ContextObject defines model for ContextObject.
type ContextObject struct {
	// ExternalUrls External URLs for this context.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the track.
	Href *string `json:"href,omitempty"`

	// Type The object type, e.g. "artist", "playlist", "album", "show".
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the context.
	Uri *string `json:"uri,omitempty"`
}

// CopyrightObject defines model for CopyrightObject.
type CopyrightObject struct {
	// Text The copyright text for this content.
	Text *string `json:"text,omitempty"`

	// Type The type of copyright: `C` = the copyright, `P` = the sound recording (performance) copyright.
	Type *string `json:"type,omitempty"`
}

// CurrentlyPlayingContextObject defines model for CurrentlyPlayingContextObject.
type CurrentlyPlayingContextObject struct {
	// Actions Allows to update the user interface based on which playback actions are available within the current context.
	Actions *DisallowsObject `json:"actions,omitempty"`

	// Context A Context Object. Can be `null`.
	Context *ContextObject `json:"context,omitempty"`

	// CurrentlyPlayingType The object type of the currently playing item. Can be one of `track`, `episode`, `ad` or `unknown`.
	CurrentlyPlayingType *string `json:"currently_playing_type,omitempty"`

	// Device The device that is currently active.
	Device *DeviceObject `json:"device,omitempty"`

	// IsPlaying If something is currently playing, return `true`.
	IsPlaying *bool `json:"is_playing,omitempty"`

	// Item The currently playing track or episode. Can be `null`.
	Item *CurrentlyPlayingContextObject_Item `json:"item,omitempty"`

	// ProgressMs Progress into the currently playing track or episode. Can be `null`.
	ProgressMs *int `json:"progress_ms,omitempty"`

	// RepeatState off, track, context
	RepeatState *string `json:"repeat_state,omitempty"`

	// ShuffleState If shuffle is on or off.
	ShuffleState *bool `json:"shuffle_state,omitempty"`

	// Timestamp Unix Millisecond Timestamp when playback state was last changed (play, pause, skip, scrub, new song, etc.).
	Timestamp *int `json:"timestamp,omitempty"`
}

// CurrentlyPlayingContextObject_Item The currently playing track or episode. Can be `null`.
type CurrentlyPlayingContextObject_Item struct {
	union json.RawMessage
}

// CursorObject defines model for CursorObject.
type CursorObject struct {
	// After The cursor to use as key to find the next page of items.
	After *string `json:"after,omitempty"`

	// Before The cursor to use as key to find the previous page of items.
	Before *string `json:"before,omitempty"`
}

// CursorPagingObject defines model for CursorPagingObject.
type CursorPagingObject struct {
	// Cursors The cursors used to find the next set of items.
	Cursors *CursorObject `json:"cursors,omitempty"`

	// Href A link to the Web API endpoint returning the full result of the request.
	Href *string `json:"href,omitempty"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit *int `json:"limit,omitempty"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next,omitempty"`

	// Total The total number of items available to return.
	Total *int `json:"total,omitempty"`
}

// CursorPagingPlayHistoryObject defines model for CursorPagingPlayHistoryObject.
type CursorPagingPlayHistoryObject struct {
	// Cursors The cursors used to find the next set of items.
	Cursors *CursorObject `json:"cursors,omitempty"`

	// Href A link to the Web API endpoint returning the full result of the request.
	Href  *string              `json:"href,omitempty"`
	Items *[]PlayHistoryObject `json:"items,omitempty"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit *int `json:"limit,omitempty"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next,omitempty"`

	// Total The total number of items available to return.
	Total *int `json:"total,omitempty"`
}

// CursorPagingSimplifiedArtistObject defines model for CursorPagingSimplifiedArtistObject.
type CursorPagingSimplifiedArtistObject struct {
	// Cursors The cursors used to find the next set of items.
	Cursors *CursorObject `json:"cursors,omitempty"`

	// Href A link to the Web API endpoint returning the full result of the request.
	Href  *string         `json:"href,omitempty"`
	Items *[]ArtistObject `json:"items,omitempty"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit *int `json:"limit,omitempty"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next,omitempty"`

	// Total The total number of items available to return.
	Total *int `json:"total,omitempty"`
}

// DeviceObject defines model for DeviceObject.
type DeviceObject struct {
	// Id The device ID. This ID is unique and persistent to some extent. However, this is not guaranteed and any cached `device_id` should periodically be cleared out and refetched as necessary.
	Id *string `json:"id"`

	// IsActive If this device is the currently active device.
	IsActive *bool `json:"is_active,omitempty"`

	// IsPrivateSession If this device is currently in a private session.
	IsPrivateSession *bool `json:"is_private_session,omitempty"`

	// IsRestricted Whether controlling this device is restricted. At present if this is "true" then no Web API commands will be accepted by this device.
	IsRestricted *bool `json:"is_restricted,omitempty"`

	// Name A human-readable name for the device. Some devices have a name that the user can configure (e.g. \"Loudest speaker\") and some devices have a generic name associated with the manufacturer or device model.
	Name *string `json:"name,omitempty"`

	// SupportsVolume If this device can be used to set the volume.
	SupportsVolume *bool `json:"supports_volume,omitempty"`

	// Type Device type, such as "computer", "smartphone" or "speaker".
	Type *string `json:"type,omitempty"`

	// VolumePercent The current volume in percent.
	VolumePercent *int `json:"volume_percent"`
}

// DisallowsObject defines model for DisallowsObject.
type DisallowsObject struct {
	// InterruptingPlayback Interrupting playback. Optional field.
	InterruptingPlayback *bool `json:"interrupting_playback,omitempty"`

	// Pausing Pausing. Optional field.
	Pausing *bool `json:"pausing,omitempty"`

	// Resuming Resuming. Optional field.
	Resuming *bool `json:"resuming,omitempty"`

	// Seeking Seeking playback location. Optional field.
	Seeking *bool `json:"seeking,omitempty"`

	// SkippingNext Skipping to the next context. Optional field.
	SkippingNext *bool `json:"skipping_next,omitempty"`

	// SkippingPrev Skipping to the previous context. Optional field.
	SkippingPrev *bool `json:"skipping_prev,omitempty"`

	// TogglingRepeatContext Toggling repeat context flag. Optional field.
	TogglingRepeatContext *bool `json:"toggling_repeat_context,omitempty"`

	// TogglingRepeatTrack Toggling repeat track flag. Optional field.
	TogglingRepeatTrack *bool `json:"toggling_repeat_track,omitempty"`

	// TogglingShuffle Toggling shuffle flag. Optional field.
	TogglingShuffle *bool `json:"toggling_shuffle,omitempty"`

	// TransferringPlayback Transfering playback between devices. Optional field.
	TransferringPlayback *bool `json:"transferring_playback,omitempty"`
}

// EpisodeBase defines model for EpisodeBase.
type EpisodeBase struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the episode. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// Description A description of the episode. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The episode length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the episode has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this episode.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the episode.
	Href string `json:"href"`

	// HtmlDescription A description of the episode. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Id string `json:"id"`

	// Images The cover art for the episode in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if the episode is hosted outside of Spotify's CDN.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// IsPlayable True if the episode is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Language The language used in the episode, identified by a [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code. This field is deprecated and might be removed in the future. Please use the `languages` field instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Language *string `json:"language,omitempty"`

	// Languages A list of the languages used in the episode, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the episode.
	Name string `json:"name"`

	// ReleaseDate The date the episode was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision EpisodeBaseReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *EpisodeRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the episode. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Type The object type.
	Type EpisodeBaseType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Uri string `json:"uri"`
}

// EpisodeBaseReleaseDatePrecision The precision with which `release_date` value is known.
type EpisodeBaseReleaseDatePrecision string

// EpisodeBaseType The object type.
type EpisodeBaseType string

// EpisodeObject defines model for EpisodeObject.
type EpisodeObject struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the episode. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// Description A description of the episode. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The episode length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the episode has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this episode.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the episode.
	Href string `json:"href"`

	// HtmlDescription A description of the episode. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Id string `json:"id"`

	// Images The cover art for the episode in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if the episode is hosted outside of Spotify's CDN.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// IsPlayable True if the episode is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Language The language used in the episode, identified by a [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code. This field is deprecated and might be removed in the future. Please use the `languages` field instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Language *string `json:"language,omitempty"`

	// Languages A list of the languages used in the episode, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the episode.
	Name string `json:"name"`

	// ReleaseDate The date the episode was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision EpisodeObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *EpisodeRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the episode. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Show The show on which the episode belongs.
	Show SimplifiedShowObject `json:"show"`

	// Type The object type.
	Type EpisodeObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Uri string `json:"uri"`
}

// EpisodeObjectReleaseDatePrecision The precision with which `release_date` value is known.
type EpisodeObjectReleaseDatePrecision string

// EpisodeObjectType The object type.
type EpisodeObjectType string

// EpisodeRestrictionObject defines model for EpisodeRestrictionObject.
type EpisodeRestrictionObject struct {
	// Reason The reason for the restriction. Supported values:
	// - `market` - The content item is not available in the given market.
	// - `product` - The content item is not available for the user's subscription type.
	// - `explicit` - The content item is explicit and the user's account is set to not play explicit content.
	//
	// Additional reasons may be added in the future.
	// **Note**: If you use this field, make sure that your application safely handles unknown values.
	Reason *string `json:"reason,omitempty"`
}

// ErrorObject defines model for ErrorObject.
type ErrorObject struct {
	// Message A short description of the cause of the error.
	Message string `json:"message"`

	// Status The HTTP status code (also returned in the response header; see [Response Status Codes](/documentation/web-api/concepts/api-calls#response-status-codes) for more information).
	Status int `json:"status"`
}

// ExplicitContentSettingsObject defines model for ExplicitContentSettingsObject.
type ExplicitContentSettingsObject struct {
	// FilterEnabled When `true`, indicates that explicit content should not be played.
	FilterEnabled *bool `json:"filter_enabled,omitempty"`

	// FilterLocked When `true`, indicates that the explicit content setting is locked and can't be changed by the user.
	FilterLocked *bool `json:"filter_locked,omitempty"`
}

// ExternalIdObject defines model for ExternalIdObject.
type ExternalIdObject struct {
	// Ean [International Article Number](http://en.wikipedia.org/wiki/International_Article_Number_%28EAN%29)
	Ean *string `json:"ean,omitempty"`

	// Isrc [International Standard Recording Code](http://en.wikipedia.org/wiki/International_Standard_Recording_Code)
	Isrc *string `json:"isrc,omitempty"`

	// Upc [Universal Product Code](http://en.wikipedia.org/wiki/Universal_Product_Code)
	Upc *string `json:"upc,omitempty"`
}

// ExternalUrlObject defines model for ExternalUrlObject.
type ExternalUrlObject struct {
	// Spotify The [Spotify URL](/documentation/web-api/concepts/spotify-uris-ids) for the object.
	Spotify *string `json:"spotify,omitempty"`
}

// FollowersObject defines model for FollowersObject.
type FollowersObject struct {
	// Href This will always be set to null, as the Web API does not support it at the moment.
	Href *string `json:"href"`

	// Total The total number of followers.
	Total *int `json:"total,omitempty"`
}

// ImageObject defines model for ImageObject.
type ImageObject struct {
	// Height The image height in pixels.
	Height *int `json:"height"`

	// Url The source URL of the image.
	Url string `json:"url"`

	// Width The image width in pixels.
	Width *int `json:"width"`
}

// Key The key the track is in. Integers map to pitches using standard [Pitch Class notation](https://en.wikipedia.org/wiki/Pitch_class). E.g. 0 = C, 1 = C♯/D♭, 2 = D, and so on. If no key was detected, the value is -1.
type Key = int

// LinkedTrackObject defines model for LinkedTrackObject.
type LinkedTrackObject struct {
	// ExternalUrls Known external URLs for this track.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the track.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Id *string `json:"id,omitempty"`

	// Type The object type: "track".
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Uri *string `json:"uri,omitempty"`
}

// Loudness The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typically range between -60 and 0 db.
type Loudness = float32

// Mode Mode indicates the modality (major or minor) of a track, the type of scale from which its melodic content is derived. Major is represented by 1 and minor is 0.
type Mode = int

// NarratorObject defines model for NarratorObject.
type NarratorObject struct {
	// Name The name of the Narrator.
	Name *string `json:"name,omitempty"`
}

// PagingArtistDiscographyAlbumObject defines model for PagingArtistDiscographyAlbumObject.
type PagingArtistDiscographyAlbumObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                         `json:"href"`
	Items []ArtistDiscographyAlbumObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingArtistObject defines model for PagingArtistObject.
type PagingArtistObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string         `json:"href"`
	Items []ArtistObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingFeaturedPlaylistObject defines model for PagingFeaturedPlaylistObject.
type PagingFeaturedPlaylistObject struct {
	// Message The localized message of a playlist.
	Message   *string               `json:"message,omitempty"`
	Playlists *PagingPlaylistObject `json:"playlists,omitempty"`
}

// PagingObject defines model for PagingObject.
type PagingObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href string `json:"href"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingPlaylistObject defines model for PagingPlaylistObject.
type PagingPlaylistObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                     `json:"href"`
	Items []SimplifiedPlaylistObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingPlaylistTrackObject defines model for PagingPlaylistTrackObject.
type PagingPlaylistTrackObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                `json:"href"`
	Items []PlaylistTrackObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSavedAlbumObject defines model for PagingSavedAlbumObject.
type PagingSavedAlbumObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string             `json:"href"`
	Items []SavedAlbumObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSavedEpisodeObject defines model for PagingSavedEpisodeObject.
type PagingSavedEpisodeObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string               `json:"href"`
	Items []SavedEpisodeObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSavedShowObject defines model for PagingSavedShowObject.
type PagingSavedShowObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string            `json:"href"`
	Items []SavedShowObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSavedTrackObject defines model for PagingSavedTrackObject.
type PagingSavedTrackObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string             `json:"href"`
	Items []SavedTrackObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedAlbumObject defines model for PagingSimplifiedAlbumObject.
type PagingSimplifiedAlbumObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                  `json:"href"`
	Items []SimplifiedAlbumObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedAudiobookObject defines model for PagingSimplifiedAudiobookObject.
type PagingSimplifiedAudiobookObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                      `json:"href"`
	Items []SimplifiedAudiobookObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedChapterObject defines model for PagingSimplifiedChapterObject.
type PagingSimplifiedChapterObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                    `json:"href"`
	Items []SimplifiedChapterObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedEpisodeObject defines model for PagingSimplifiedEpisodeObject.
type PagingSimplifiedEpisodeObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                    `json:"href"`
	Items []SimplifiedEpisodeObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedShowObject defines model for PagingSimplifiedShowObject.
type PagingSimplifiedShowObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                 `json:"href"`
	Items []SimplifiedShowObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingSimplifiedTrackObject defines model for PagingSimplifiedTrackObject.
type PagingSimplifiedTrackObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string                  `json:"href"`
	Items []SimplifiedTrackObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PagingTrackObject defines model for PagingTrackObject.
type PagingTrackObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href  string        `json:"href"`
	Items []TrackObject `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PlayHistoryObject defines model for PlayHistoryObject.
type PlayHistoryObject struct {
	// Context The context the track was played from.
	Context *ContextObject `json:"context,omitempty"`

	// PlayedAt The date and time the track was played.
	PlayedAt *time.Time `json:"played_at,omitempty"`

	// Track The track the user listened to.
	Track *TrackObject `json:"track,omitempty"`
}

// PlaylistObject defines model for PlaylistObject.
type PlaylistObject struct {
	// Collaborative `true` if the owner allows other users to modify the playlist.
	Collaborative *bool `json:"collaborative,omitempty"`

	// Description The playlist description. _Only returned for modified, verified playlists, otherwise_ `null`.
	Description *string `json:"description"`

	// ExternalUrls Known external URLs for this playlist.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the playlist.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the playlist.
	Id *string `json:"id,omitempty"`

	// Images Images for the playlist. The array may be empty or contain up to three images. The images are returned by size in descending order. See [Working with Playlists](/documentation/web-api/concepts/playlists). _**Note**: If returned, the source URL for the image (`url`) is temporary and will expire in less than a day._
	Images *[]ImageObject `json:"images,omitempty"`

	// Name The name of the playlist.
	Name *string `json:"name,omitempty"`

	// Owner The user who owns the playlist
	Owner *PlaylistOwnerObject `json:"owner,omitempty"`

	// Public The playlist's public/private status (if it is added to the user's profile): `true` the playlist is public, `false` the playlist is private, `null` the playlist status is not relevant. For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists)
	Public *bool `json:"public,omitempty"`

	// SnapshotId The version identifier for the current playlist. Can be supplied in other requests to target a specific playlist version
	SnapshotId *string `json:"snapshot_id,omitempty"`

	// Tracks The tracks of the playlist.
	Tracks *PagingPlaylistTrackObject `json:"tracks,omitempty"`

	// Type The object type: "playlist"
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the playlist.
	Uri *string `json:"uri,omitempty"`
}

// PlaylistOwnerObject defines model for PlaylistOwnerObject.
type PlaylistOwnerObject struct {
	// DisplayName The name displayed on the user's profile. `null` if not available.
	DisplayName *string `json:"display_name"`

	// ExternalUrls Known public external URLs for this user.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint for this user.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify user ID](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Id *string `json:"id,omitempty"`

	// Type The object type.
	Type *PlaylistOwnerObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Uri *string `json:"uri,omitempty"`
}

// PlaylistOwnerObjectType The object type.
type PlaylistOwnerObjectType string

// PlaylistTrackObject defines model for PlaylistTrackObject.
type PlaylistTrackObject struct {
	// AddedAt The date and time the track or episode was added. _**Note**: some very old playlists may return `null` in this field._
	AddedAt *time.Time `json:"added_at,omitempty"`

	// AddedBy The Spotify user who added the track or episode. _**Note**: some very old playlists may return `null` in this field._
	AddedBy *PlaylistUserObject `json:"added_by,omitempty"`

	// IsLocal Whether this track or episode is a [local file](/documentation/web-api/concepts/playlists/#local-files) or not.
	IsLocal *bool `json:"is_local,omitempty"`

	// Track Information about the track or episode.
	Track *PlaylistTrackObject_Track `json:"track,omitempty"`
}

// PlaylistTrackObject_Track Information about the track or episode.
type PlaylistTrackObject_Track struct {
	union json.RawMessage
}

// PlaylistTracksRefObject defines model for PlaylistTracksRefObject.
type PlaylistTracksRefObject struct {
	// Href A link to the Web API endpoint where full details of the playlist's tracks can be retrieved.
	Href *string `json:"href,omitempty"`

	// Total Number of tracks in the playlist.
	Total *int `json:"total,omitempty"`
}

// PlaylistUserObject defines model for PlaylistUserObject.
type PlaylistUserObject struct {
	// ExternalUrls Known public external URLs for this user.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint for this user.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify user ID](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Id *string `json:"id,omitempty"`

	// Type The object type.
	Type *PlaylistUserObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Uri *string `json:"uri,omitempty"`
}

// PlaylistUserObjectType The object type.
type PlaylistUserObjectType string

// PrivateUserObject defines model for PrivateUserObject.
type PrivateUserObject struct {
	// Country The country of the user, as set in the user's account profile. An [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). _This field is only available when the current user has granted access to the [user-read-private](/documentation/web-api/concepts/scopes/#list-of-scopes) scope._
	Country *string `json:"country,omitempty"`

	// DisplayName The name displayed on the user's profile. `null` if not available.
	DisplayName *string `json:"display_name,omitempty"`

	// Email The user's email address, as entered by the user when creating their account. _**Important!** This email address is unverified; there is no proof that it actually belongs to the user._ _This field is only available when the current user has granted access to the [user-read-email](/documentation/web-api/concepts/scopes/#list-of-scopes) scope._
	Email *string `json:"email,omitempty"`

	// ExplicitContent The user's explicit content settings. _This field is only available when the current user has granted access to the [user-read-private](/documentation/web-api/concepts/scopes/#list-of-scopes) scope._
	ExplicitContent *ExplicitContentSettingsObject `json:"explicit_content,omitempty"`

	// ExternalUrls Known external URLs for this user.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Followers Information about the followers of the user.
	Followers *FollowersObject `json:"followers,omitempty"`

	// Href A link to the Web API endpoint for this user.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify user ID](/documentation/web-api/concepts/spotify-uris-ids) for the user.
	Id *string `json:"id,omitempty"`

	// Images The user's profile image.
	Images *[]ImageObject `json:"images,omitempty"`

	// Product The user's Spotify subscription level: "premium", "free", etc. (The subscription level "open" can be considered the same as "free".) _This field is only available when the current user has granted access to the [user-read-private](/documentation/web-api/concepts/scopes/#list-of-scopes) scope._
	Product *string `json:"product,omitempty"`

	// Type The object type: "user"
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the user.
	Uri *string `json:"uri,omitempty"`
}

// PublicUserObject defines model for PublicUserObject.
type PublicUserObject struct {
	// DisplayName The name displayed on the user's profile. `null` if not available.
	DisplayName *string `json:"display_name"`

	// ExternalUrls Known public external URLs for this user.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Followers Information about the followers of this user.
	Followers *FollowersObject `json:"followers,omitempty"`

	// Href A link to the Web API endpoint for this user.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify user ID](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Id *string `json:"id,omitempty"`

	// Images The user's profile image.
	Images *[]ImageObject `json:"images,omitempty"`

	// Type The object type.
	Type *PublicUserObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for this user.
	Uri *string `json:"uri,omitempty"`
}

// PublicUserObjectType The object type.
type PublicUserObjectType string

// QueueObject defines model for QueueObject.
type QueueObject struct {
	// CurrentlyPlaying The currently playing track or episode. Can be `null`.
	CurrentlyPlaying *QueueObject_CurrentlyPlaying `json:"currently_playing,omitempty"`

	// Queue The tracks or episodes in the queue. Can be empty.
	Queue *[]QueueObject_Queue_Item `json:"queue,omitempty"`
}

// QueueObject_CurrentlyPlaying The currently playing track or episode. Can be `null`.
type QueueObject_CurrentlyPlaying struct {
	union json.RawMessage
}

// QueueObject_Queue_Item defines model for QueueObject.queue.Item.
type QueueObject_Queue_Item struct {
	union json.RawMessage
}

// RecommendationSeedObject defines model for RecommendationSeedObject.
type RecommendationSeedObject struct {
	// AfterFilteringSize The number of tracks available after min\_\* and max\_\* filters have been applied.
	AfterFilteringSize *int `json:"afterFilteringSize,omitempty"`

	// AfterRelinkingSize The number of tracks available after relinking for regional availability.
	AfterRelinkingSize *int `json:"afterRelinkingSize,omitempty"`

	// Href A link to the full track or artist data for this seed. For tracks this will be a link to a Track Object. For artists a link to an Artist Object. For genre seeds, this value will be `null`.
	Href *string `json:"href,omitempty"`

	// Id The id used to select this seed. This will be the same as the string used in the `seed_artists`, `seed_tracks` or `seed_genres` parameter.
	Id *string `json:"id,omitempty"`

	// InitialPoolSize The number of recommended tracks available for this seed.
	InitialPoolSize *int `json:"initialPoolSize,omitempty"`

	// Type The entity type of this seed. One of `artist`, `track` or `genre`.
	Type *string `json:"type,omitempty"`
}

// RecommendationsObject defines model for RecommendationsObject.
type RecommendationsObject struct {
	// Seeds An array of recommendation seed objects.
	Seeds []RecommendationSeedObject `json:"seeds"`

	// Tracks An array of track object (simplified) ordered according to the parameters supplied.
	Tracks []TrackObject `json:"tracks"`
}

// ResumePointObject defines model for ResumePointObject.
type ResumePointObject struct {
	// FullyPlayed Whether or not the episode has been fully played by the user.
	FullyPlayed *bool `json:"fully_played,omitempty"`

	// ResumePositionMs The user's most recent position in the episode in milliseconds.
	ResumePositionMs *int `json:"resume_position_ms,omitempty"`
}

// SavedAlbumObject defines model for SavedAlbumObject.
type SavedAlbumObject struct {
	// AddedAt The date and time the album was saved
	// Timestamps are returned in ISO 8601 format as Coordinated Universal Time (UTC) with a zero offset: YYYY-MM-DDTHH:MM:SSZ.
	// If the time is imprecise (for example, the date/time of an album release), an additional field indicates the precision; see for example, release_date in an album object.
	AddedAt *time.Time `json:"added_at,omitempty"`

	// Album Information about the album.
	Album *AlbumObject `json:"album,omitempty"`
}

// SavedEpisodeObject defines model for SavedEpisodeObject.
type SavedEpisodeObject struct {
	// AddedAt The date and time the episode was saved.
	// Timestamps are returned in ISO 8601 format as Coordinated Universal Time (UTC) with a zero offset: YYYY-MM-DDTHH:MM:SSZ.
	AddedAt *time.Time `json:"added_at,omitempty"`

	// Episode Information about the episode.
	Episode *EpisodeObject `json:"episode,omitempty"`
}

// SavedShowObject defines model for SavedShowObject.
type SavedShowObject struct {
	// AddedAt The date and time the show was saved.
	// Timestamps are returned in ISO 8601 format as Coordinated Universal Time (UTC) with a zero offset: YYYY-MM-DDTHH:MM:SSZ.
	// If the time is imprecise (for example, the date/time of an album release), an additional field indicates the precision; see for example, release_date in an album object.
	AddedAt *time.Time `json:"added_at,omitempty"`

	// Show Information about the show.
	Show *SimplifiedShowObject `json:"show,omitempty"`
}

// SavedTrackObject defines model for SavedTrackObject.
type SavedTrackObject struct {
	// AddedAt The date and time the track was saved.
	// Timestamps are returned in ISO 8601 format as Coordinated Universal Time (UTC) with a zero offset: YYYY-MM-DDTHH:MM:SSZ.
	// If the time is imprecise (for example, the date/time of an album release), an additional field indicates the precision; see for example, release_date in an album object.
	AddedAt *time.Time `json:"added_at,omitempty"`

	// Track Information about the track.
	Track *TrackObject `json:"track,omitempty"`
}

// SectionObject defines model for SectionObject.
type SectionObject struct {
	// Confidence The confidence, from 0.0 to 1.0, of the reliability of the section's "designation".
	Confidence *float32 `json:"confidence,omitempty"`

	// Duration The duration (in seconds) of the section.
	Duration *float32 `json:"duration,omitempty"`

	// Key The estimated overall key of the section. The values in this field ranging from 0 to 11 mapping to pitches using standard Pitch Class notation (E.g. 0 = C, 1 = C♯/D♭, 2 = D, and so on). If no key was detected, the value is -1.
	Key *int `json:"key,omitempty"`

	// KeyConfidence The confidence, from 0.0 to 1.0, of the reliability of the key. Songs with many key changes may correspond to low values in this field.
	KeyConfidence *float32 `json:"key_confidence,omitempty"`

	// Loudness The overall loudness of the section in decibels (dB). Loudness values are useful for comparing relative loudness of sections within tracks.
	Loudness *float32 `json:"loudness,omitempty"`

	// Mode Indicates the modality (major or minor) of a section, the type of scale from which its melodic content is derived. This field will contain a 0 for "minor", a 1 for "major", or a -1 for no result. Note that the major key (e.g. C major) could more likely be confused with the minor key at 3 semitones lower (e.g. A minor) as both keys carry the same pitches.
	Mode *SectionObjectMode `json:"mode,omitempty"`

	// ModeConfidence The confidence, from 0.0 to 1.0, of the reliability of the `mode`.
	ModeConfidence *float32 `json:"mode_confidence,omitempty"`

	// Start The starting point (in seconds) of the section.
	Start *float32 `json:"start,omitempty"`

	// Tempo The overall estimated tempo of the section in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.
	Tempo *float32 `json:"tempo,omitempty"`

	// TempoConfidence The confidence, from 0.0 to 1.0, of the reliability of the tempo. Some tracks contain tempo changes or sounds which don't contain tempo (like pure speech) which would correspond to a low value in this field.
	TempoConfidence *float32 `json:"tempo_confidence,omitempty"`

	// TimeSignature An estimated time signature. The time signature (meter) is a notational convention to specify how many beats are in each bar (or measure). The time signature ranges from 3 to 7 indicating time signatures of "3/4", to "7/4".
	TimeSignature *TimeSignature `json:"time_signature,omitempty"`

	// TimeSignatureConfidence The confidence, from 0.0 to 1.0, of the reliability of the `time_signature`. Sections with time signature changes may correspond to low values in this field.
	TimeSignatureConfidence *float32 `json:"time_signature_confidence,omitempty"`
}

// SectionObjectMode Indicates the modality (major or minor) of a section, the type of scale from which its melodic content is derived. This field will contain a 0 for "minor", a 1 for "major", or a -1 for no result. Note that the major key (e.g. C major) could more likely be confused with the minor key at 3 semitones lower (e.g. A minor) as both keys carry the same pitches.
type SectionObjectMode float32

// SegmentObject defines model for SegmentObject.
type SegmentObject struct {
	// Confidence The confidence, from 0.0 to 1.0, of the reliability of the segmentation. Segments of the song which are difficult to logically segment (e.g: noise) may correspond to low values in this field.
	Confidence *float32 `json:"confidence,omitempty"`

	// Duration The duration (in seconds) of the segment.
	Duration *float32 `json:"duration,omitempty"`

	// LoudnessEnd The offset loudness of the segment in decibels (dB). This value should be equivalent to the loudness_start of the following segment.
	LoudnessEnd *float32 `json:"loudness_end,omitempty"`

	// LoudnessMax The peak loudness of the segment in decibels (dB). Combined with `loudness_start` and `loudness_max_time`, these components can be used to describe the "attack" of the segment.
	LoudnessMax *float32 `json:"loudness_max,omitempty"`

	// LoudnessMaxTime The segment-relative offset of the segment peak loudness in seconds. Combined with `loudness_start` and `loudness_max`, these components can be used to desctibe the "attack" of the segment.
	LoudnessMaxTime *float32 `json:"loudness_max_time,omitempty"`

	// LoudnessStart The onset loudness of the segment in decibels (dB). Combined with `loudness_max` and `loudness_max_time`, these components can be used to describe the "attack" of the segment.
	LoudnessStart *float32 `json:"loudness_start,omitempty"`

	// Pitches Pitch content is given by a “chroma” vector, corresponding to the 12 pitch classes C, C#, D to B, with values ranging from 0 to 1 that describe the relative dominance of every pitch in the chromatic scale. For example a C Major chord would likely be represented by large values of C, E and G (i.e. classes 0, 4, and 7).
	//
	// Vectors are normalized to 1 by their strongest dimension, therefore noisy sounds are likely represented by values that are all close to 1, while pure tones are described by one value at 1 (the pitch) and others near 0.
	// As can be seen below, the 12 vector indices are a combination of low-power spectrum values at their respective pitch frequencies.
	// ![pitch vector](/assets/audio/Pitch_vector.png)
	Pitches *[]float32 `json:"pitches,omitempty"`

	// Start The starting point (in seconds) of the segment.
	Start *float32 `json:"start,omitempty"`

	// Timbre Timbre is the quality of a musical note or sound that distinguishes different types of musical instruments, or voices. It is a complex notion also referred to as sound color, texture, or tone quality, and is derived from the shape of a segment’s spectro-temporal surface, independently of pitch and loudness. The timbre feature is a vector that includes 12 unbounded values roughly centered around 0. Those values are high level abstractions of the spectral surface, ordered by degree of importance.
	//
	// For completeness however, the first dimension represents the average loudness of the segment; second emphasizes brightness; third is more closely correlated to the flatness of a sound; fourth to sounds with a stronger attack; etc. See an image below representing the 12 basis functions (i.e. template segments).
	// ![timbre basis functions](/assets/audio/Timbre_basis_functions.png)
	//
	// The actual timbre of the segment is best described as a linear combination of these 12 basis functions weighted by the coefficient values: timbre = c1 x b1 + c2 x b2 + ... + c12 x b12, where c1 to c12 represent the 12 coefficients and b1 to b12 the 12 basis functions as displayed below. Timbre vectors are best used in comparison with each other.
	Timbre *[]float32 `json:"timbre,omitempty"`
}

// ShowBase defines model for ShowBase.
type ShowBase struct {
	// AvailableMarkets A list of the countries in which the show can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the show.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the show. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Explicit Whether or not the show has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this show.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the show.
	Href string `json:"href"`

	// HtmlDescription A description of the show. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Id string `json:"id"`

	// Images The cover art for the show in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if all of the shows episodes are hosted outside of Spotify's CDN. This field might be `null` in some cases.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// Languages A list of the languages used in the show, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the show.
	MediaType string `json:"media_type"`

	// Name The name of the episode.
	Name string `json:"name"`

	// Publisher The publisher of the show.
	Publisher string `json:"publisher"`

	// TotalEpisodes The total number of episodes in the show.
	TotalEpisodes int `json:"total_episodes"`

	// Type The object type.
	Type ShowBaseType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Uri string `json:"uri"`
}

// ShowBaseType The object type.
type ShowBaseType string

// ShowObject defines model for ShowObject.
type ShowObject struct {
	// AvailableMarkets A list of the countries in which the show can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the show.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the show. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Episodes The episodes of the show.
	Episodes PagingSimplifiedEpisodeObject `json:"episodes"`

	// Explicit Whether or not the show has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this show.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the show.
	Href string `json:"href"`

	// HtmlDescription A description of the show. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Id string `json:"id"`

	// Images The cover art for the show in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if all of the shows episodes are hosted outside of Spotify's CDN. This field might be `null` in some cases.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// Languages A list of the languages used in the show, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the show.
	MediaType string `json:"media_type"`

	// Name The name of the episode.
	Name string `json:"name"`

	// Publisher The publisher of the show.
	Publisher string `json:"publisher"`

	// TotalEpisodes The total number of episodes in the show.
	TotalEpisodes int `json:"total_episodes"`

	// Type The object type.
	Type ShowObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Uri string `json:"uri"`
}

// ShowObjectType The object type.
type ShowObjectType string

// SimplifiedAlbumObject defines model for SimplifiedAlbumObject.
type SimplifiedAlbumObject struct {
	// AlbumType The type of the album.
	AlbumType SimplifiedAlbumObjectAlbumType `json:"album_type"`

	// Artists The artists of the album. Each artist object includes a link in `href` to more detailed information about the artist.
	Artists []SimplifiedArtistObject `json:"artists"`

	// AvailableMarkets The markets in which the album is available: [ISO 3166-1 alpha-2 country codes](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). _**NOTE**: an album is considered available in a market when at least 1 of its tracks is available in that market._
	AvailableMarkets []string `json:"available_markets"`

	// ExternalUrls Known external URLs for this album.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the album.
	Href string `json:"href"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Id string `json:"id"`

	// Images The cover art for the album in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Name The name of the album. In case of an album takedown, the value may be an empty string.
	Name string `json:"name"`

	// ReleaseDate The date the album was first released.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision SimplifiedAlbumObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *AlbumRestrictionObject `json:"restrictions,omitempty"`

	// TotalTracks The number of tracks in the album.
	TotalTracks int `json:"total_tracks"`

	// Type The object type.
	Type SimplifiedAlbumObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the album.
	Uri string `json:"uri"`
}

// SimplifiedAlbumObjectAlbumType The type of the album.
type SimplifiedAlbumObjectAlbumType string

// SimplifiedAlbumObjectReleaseDatePrecision The precision with which `release_date` value is known.
type SimplifiedAlbumObjectReleaseDatePrecision string

// SimplifiedAlbumObjectType The object type.
type SimplifiedAlbumObjectType string

// SimplifiedArtistObject defines model for SimplifiedArtistObject.
type SimplifiedArtistObject struct {
	// ExternalUrls Known external URLs for this artist.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the artist.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the artist.
	Id *string `json:"id,omitempty"`

	// Name The name of the artist.
	Name *string `json:"name,omitempty"`

	// Type The object type.
	Type *SimplifiedArtistObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the artist.
	Uri *string `json:"uri,omitempty"`
}

// SimplifiedArtistObjectType The object type.
type SimplifiedArtistObjectType string

// SimplifiedAudiobookObject defines model for SimplifiedAudiobookObject.
type SimplifiedAudiobookObject struct {
	// Authors The author(s) for the audiobook.
	Authors []AuthorObject `json:"authors"`

	// AvailableMarkets A list of the countries in which the audiobook can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the audiobook.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the audiobook. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Edition The edition of the audiobook.
	Edition *string `json:"edition,omitempty"`

	// Explicit Whether or not the audiobook has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this audiobook.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the audiobook.
	Href string `json:"href"`

	// HtmlDescription A description of the audiobook. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Id string `json:"id"`

	// Images The cover art for the audiobook in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// Languages A list of the languages used in the audiobook, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the audiobook.
	MediaType string `json:"media_type"`

	// Name The name of the audiobook.
	Name string `json:"name"`

	// Narrators The narrator(s) for the audiobook.
	Narrators []NarratorObject `json:"narrators"`

	// Publisher The publisher of the audiobook.
	Publisher string `json:"publisher"`

	// TotalChapters The number of chapters in this audiobook.
	TotalChapters int `json:"total_chapters"`

	// Type The object type.
	Type SimplifiedAudiobookObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the audiobook.
	Uri string `json:"uri"`
}

// SimplifiedAudiobookObjectType The object type.
type SimplifiedAudiobookObjectType string

// SimplifiedChapterObject defines model for SimplifiedChapterObject.
type SimplifiedChapterObject struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the chapter. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// AvailableMarkets A list of the countries in which the chapter can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets *[]string `json:"available_markets,omitempty"`

	// ChapterNumber The number of the chapter
	ChapterNumber int `json:"chapter_number"`

	// Description A description of the chapter. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The chapter length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the chapter has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this chapter.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the chapter.
	Href string `json:"href"`

	// HtmlDescription A description of the chapter. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Id string `json:"id"`

	// Images The cover art for the chapter in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsPlayable True if the chapter is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Languages A list of the languages used in the chapter, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the chapter.
	Name string `json:"name"`

	// ReleaseDate The date the chapter was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision SimplifiedChapterObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *ChapterRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the chapter. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Type The object type.
	Type SimplifiedChapterObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the chapter.
	Uri string `json:"uri"`
}

// SimplifiedChapterObjectReleaseDatePrecision The precision with which `release_date` value is known.
type SimplifiedChapterObjectReleaseDatePrecision string

// SimplifiedChapterObjectType The object type.
type SimplifiedChapterObjectType string

// SimplifiedEpisodeObject defines model for SimplifiedEpisodeObject.
type SimplifiedEpisodeObject struct {
	// AudioPreviewUrl A URL to a 30 second preview (MP3 format) of the episode. `null` if not available.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	AudioPreviewUrl *string `json:"audio_preview_url"`

	// Description A description of the episode. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// DurationMs The episode length in milliseconds.
	DurationMs int `json:"duration_ms"`

	// Explicit Whether or not the episode has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this episode.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the episode.
	Href string `json:"href"`

	// HtmlDescription A description of the episode. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Id string `json:"id"`

	// Images The cover art for the episode in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if the episode is hosted outside of Spotify's CDN.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// IsPlayable True if the episode is playable in the given market. Otherwise false.
	IsPlayable bool `json:"is_playable"`

	// Language The language used in the episode, identified by a [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code. This field is deprecated and might be removed in the future. Please use the `languages` field instead.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Language *string `json:"language,omitempty"`

	// Languages A list of the languages used in the episode, identified by their [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// Name The name of the episode.
	Name string `json:"name"`

	// ReleaseDate The date the episode was first released, for example `"1981-12-15"`. Depending on the precision, it might be shown as `"1981"` or `"1981-12"`.
	ReleaseDate string `json:"release_date"`

	// ReleaseDatePrecision The precision with which `release_date` value is known.
	ReleaseDatePrecision SimplifiedEpisodeObjectReleaseDatePrecision `json:"release_date_precision"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *EpisodeRestrictionObject `json:"restrictions,omitempty"`

	// ResumePoint The user's most recent position in the episode. Set if the supplied access token is a user token and has the scope 'user-read-playback-position'.
	ResumePoint *ResumePointObject `json:"resume_point,omitempty"`

	// Type The object type.
	Type SimplifiedEpisodeObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the episode.
	Uri string `json:"uri"`
}

// SimplifiedEpisodeObjectReleaseDatePrecision The precision with which `release_date` value is known.
type SimplifiedEpisodeObjectReleaseDatePrecision string

// SimplifiedEpisodeObjectType The object type.
type SimplifiedEpisodeObjectType string

// SimplifiedPlaylistObject defines model for SimplifiedPlaylistObject.
type SimplifiedPlaylistObject struct {
	// Collaborative `true` if the owner allows other users to modify the playlist.
	Collaborative *bool `json:"collaborative,omitempty"`

	// Description The playlist description. _Only returned for modified, verified playlists, otherwise_ `null`.
	Description *string `json:"description,omitempty"`

	// ExternalUrls Known external URLs for this playlist.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the playlist.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the playlist.
	Id *string `json:"id,omitempty"`

	// Images Images for the playlist. The array may be empty or contain up to three images. The images are returned by size in descending order. See [Working with Playlists](/documentation/web-api/concepts/playlists). _**Note**: If returned, the source URL for the image (`url`) is temporary and will expire in less than a day._
	Images *[]ImageObject `json:"images,omitempty"`

	// Name The name of the playlist.
	Name *string `json:"name,omitempty"`

	// Owner The user who owns the playlist
	Owner *PlaylistOwnerObject `json:"owner,omitempty"`

	// Public The playlist's public/private status (if it is added to the user's profile): `true` the playlist is public, `false` the playlist is private, `null` the playlist status is not relevant. For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists)
	Public *bool `json:"public,omitempty"`

	// SnapshotId The version identifier for the current playlist. Can be supplied in other requests to target a specific playlist version
	SnapshotId *string `json:"snapshot_id,omitempty"`

	// Tracks A collection containing a link ( `href` ) to the Web API endpoint where full details of the playlist's tracks can be retrieved, along with the `total` number of tracks in the playlist. Note, a track object may be `null`. This can happen if a track is no longer available.
	Tracks *PlaylistTracksRefObject `json:"tracks,omitempty"`

	// Type The object type: "playlist"
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the playlist.
	Uri *string `json:"uri,omitempty"`
}

// SimplifiedShowObject defines model for SimplifiedShowObject.
type SimplifiedShowObject struct {
	// AvailableMarkets A list of the countries in which the show can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets []string `json:"available_markets"`

	// Copyrights The copyright statements of the show.
	Copyrights []CopyrightObject `json:"copyrights"`

	// Description A description of the show. HTML tags are stripped away from this field, use `html_description` field in case HTML tags are needed.
	Description string `json:"description"`

	// Explicit Whether or not the show has explicit content (true = yes it does; false = no it does not OR unknown).
	Explicit bool `json:"explicit"`

	// ExternalUrls External URLs for this show.
	ExternalUrls ExternalUrlObject `json:"external_urls"`

	// Href A link to the Web API endpoint providing full details of the show.
	Href string `json:"href"`

	// HtmlDescription A description of the show. This field may contain HTML tags.
	HtmlDescription string `json:"html_description"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Id string `json:"id"`

	// Images The cover art for the show in various sizes, widest first.
	Images []ImageObject `json:"images"`

	// IsExternallyHosted True if all of the shows episodes are hosted outside of Spotify's CDN. This field might be `null` in some cases.
	IsExternallyHosted bool `json:"is_externally_hosted"`

	// Languages A list of the languages used in the show, identified by their [ISO 639](https://en.wikipedia.org/wiki/ISO_639) code.
	Languages []string `json:"languages"`

	// MediaType The media type of the show.
	MediaType string `json:"media_type"`

	// Name The name of the episode.
	Name string `json:"name"`

	// Publisher The publisher of the show.
	Publisher string `json:"publisher"`

	// TotalEpisodes The total number of episodes in the show.
	TotalEpisodes int `json:"total_episodes"`

	// Type The object type.
	Type SimplifiedShowObjectType `json:"type"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the show.
	Uri string `json:"uri"`
}

// SimplifiedShowObjectType The object type.
type SimplifiedShowObjectType string

// SimplifiedTrackObject defines model for SimplifiedTrackObject.
type SimplifiedTrackObject struct {
	// Artists The artists who performed the track. Each artist object includes a link in `href` to more detailed information about the artist.
	Artists *[]SimplifiedArtistObject `json:"artists,omitempty"`

	// AvailableMarkets A list of the countries in which the track can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets *[]string `json:"available_markets,omitempty"`

	// DiscNumber The disc number (usually `1` unless the album consists of more than one disc).
	DiscNumber *int `json:"disc_number,omitempty"`

	// DurationMs The track length in milliseconds.
	DurationMs *int `json:"duration_ms,omitempty"`

	// Explicit Whether or not the track has explicit lyrics ( `true` = yes it does; `false` = no it does not OR unknown).
	Explicit *bool `json:"explicit,omitempty"`

	// ExternalUrls External URLs for this track.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the track.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether or not the track is from a local file.
	IsLocal *bool `json:"is_local,omitempty"`

	// IsPlayable Part of the response when [Track Relinking](/documentation/web-api/concepts/track-relinking/) is applied. If `true`, the track is playable in the given market. Otherwise `false`.
	IsPlayable *bool `json:"is_playable,omitempty"`

	// LinkedFrom Part of the response when [Track Relinking](/documentation/web-api/concepts/track-relinking/) is applied and is only part of the response if the track linking, in fact, exists. The requested track has been replaced with a different track. The track in the `linked_from` object contains information about the originally requested track.
	LinkedFrom *LinkedTrackObject `json:"linked_from,omitempty"`

	// Name The name of the track.
	Name *string `json:"name,omitempty"`

	// PreviewUrl A URL to a 30 second preview (MP3 format) of the track.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PreviewUrl *string `json:"preview_url"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *TrackRestrictionObject `json:"restrictions,omitempty"`

	// TrackNumber The number of the track. If an album has several discs, the track number is the number on the specified disc.
	TrackNumber *int `json:"track_number,omitempty"`

	// Type The object type: "track".
	Type *string `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Uri *string `json:"uri,omitempty"`
}

// Tempo The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.
type Tempo = float32

// TimeIntervalObject defines model for TimeIntervalObject.
type TimeIntervalObject struct {
	// Confidence The confidence, from 0.0 to 1.0, of the reliability of the interval.
	Confidence *float32 `json:"confidence,omitempty"`

	// Duration The duration (in seconds) of the time interval.
	Duration *float32 `json:"duration,omitempty"`

	// Start The starting point (in seconds) of the time interval.
	Start *float32 `json:"start,omitempty"`
}

// TimeSignature An estimated time signature. The time signature (meter) is a notational convention to specify how many beats are in each bar (or measure). The time signature ranges from 3 to 7 indicating time signatures of "3/4", to "7/4".
type TimeSignature = int

// TrackObject defines model for TrackObject.
type TrackObject struct {
	// Album The album on which the track appears. The album object includes a link in `href` to full information about the album.
	Album *SimplifiedAlbumObject `json:"album,omitempty"`

	// Artists The artists who performed the track. Each artist object includes a link in `href` to more detailed information about the artist.
	Artists *[]SimplifiedArtistObject `json:"artists,omitempty"`

	// AvailableMarkets A list of the countries in which the track can be played, identified by their [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
	AvailableMarkets *[]string `json:"available_markets,omitempty"`

	// DiscNumber The disc number (usually `1` unless the album consists of more than one disc).
	DiscNumber *int `json:"disc_number,omitempty"`

	// DurationMs The track length in milliseconds.
	DurationMs *int `json:"duration_ms,omitempty"`

	// Explicit Whether or not the track has explicit lyrics ( `true` = yes it does; `false` = no it does not OR unknown).
	Explicit *bool `json:"explicit,omitempty"`

	// ExternalIds Known external IDs for the track.
	ExternalIds *ExternalIdObject `json:"external_ids,omitempty"`

	// ExternalUrls Known external URLs for this track.
	ExternalUrls *ExternalUrlObject `json:"external_urls,omitempty"`

	// Href A link to the Web API endpoint providing full details of the track.
	Href *string `json:"href,omitempty"`

	// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether or not the track is from a local file.
	IsLocal *bool `json:"is_local,omitempty"`

	// IsPlayable Part of the response when [Track Relinking](/documentation/web-api/concepts/track-relinking) is applied. If `true`, the track is playable in the given market. Otherwise `false`.
	IsPlayable *bool `json:"is_playable,omitempty"`

	// LinkedFrom Part of the response when [Track Relinking](/documentation/web-api/concepts/track-relinking) is applied, and the requested track has been replaced with different track. The track in the `linked_from` object contains information about the originally requested track.
	LinkedFrom *map[string]interface{} `json:"linked_from,omitempty"`

	// Name The name of the track.
	Name *string `json:"name,omitempty"`

	// Popularity The popularity of the track. The value will be between 0 and 100, with 100 being the most popular.<br/>The popularity of a track is a value between 0 and 100, with 100 being the most popular. The popularity is calculated by algorithm and is based, in the most part, on the total number of plays the track has had and how recent those plays are.<br/>Generally speaking, songs that are being played a lot now will have a higher popularity than songs that were played a lot in the past. Duplicate tracks (e.g. the same track from a single and an album) are rated independently. Artist and album popularity is derived mathematically from track popularity. _**Note**: the popularity value may lag actual popularity by a few days: the value is not updated in real time._
	Popularity *int `json:"popularity,omitempty"`

	// PreviewUrl A link to a 30 second preview (MP3 format) of the track. Can be `null`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PreviewUrl *string `json:"preview_url"`

	// Restrictions Included in the response when a content restriction is applied.
	Restrictions *TrackRestrictionObject `json:"restrictions,omitempty"`

	// TrackNumber The number of the track. If an album has several discs, the track number is the number on the specified disc.
	TrackNumber *int `json:"track_number,omitempty"`

	// Type The object type: "track".
	Type *TrackObjectType `json:"type,omitempty"`

	// Uri The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for the track.
	Uri *string `json:"uri,omitempty"`
}

// TrackObjectType The object type: "track".
type TrackObjectType string

// TrackRestrictionObject defines model for TrackRestrictionObject.
type TrackRestrictionObject struct {
	// Reason The reason for the restriction. Supported values:
	// - `market` - The content item is not available in the given market.
	// - `product` - The content item is not available for the user's subscription type.
	// - `explicit` - The content item is explicit and the user's account is set to not play explicit content.
	//
	// Additional reasons may be added in the future.
	// **Note**: If you use this field, make sure that your application safely handles unknown values.
	Reason *string `json:"reason,omitempty"`
}

// PathAlbumId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) of the album.
type PathAlbumId = string

// PathArtistId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) of the artist.
type PathArtistId = string

// PathAudiobookId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids)
// for the audiobook.
type PathAudiobookId = string

// PathChapterId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids)
// for the chapter.
type PathChapterId = string

// PathPlaylistId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) of the playlist.
type PathPlaylistId = string

// PathShowId The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids)
// for the show.
type PathShowId = string

// PathUserId The user's [Spotify user ID](/documentation/web-api/concepts/spotify-uris-ids).
type PathUserId = string

// QueryAdditionalTypes A comma-separated list of item types that your client supports besides the default `track` type. Valid types are: `track` and `episode`.<br/>
// _**Note**: This parameter was introduced to allow existing clients to maintain their current behaviour and might be deprecated in the future._<br/>
// In addition to providing this parameter, make sure that your client properly handles cases of new types in the future by checking against the `type` field of each object.
type QueryAdditionalTypes = string

// QueryAlbumIds A comma-separated list of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids) for the albums. Maximum: 20 IDs.
type QueryAlbumIds = string

// QueryAudiobookIds A comma-separated list of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `ids=18yVqkdbdRvS24c0Ilj2ci,1HGw3J3NxZO1TP1BTtVhpZ`. Maximum: 50 IDs.
type QueryAudiobookIds = string

// QueryChapterIds A comma-separated list of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `ids=0IsXVP0JmcB2adSE338GkK,3ZXb8FKZGU0EHALYX6uCzU`. Maximum: 50 IDs.
type QueryChapterIds = string

// QueryIncludeGroups A comma-separated list of keywords that will be used to filter the response. If not supplied, all album types will be returned. <br/>
// Valid values are:<br/>- `album`<br/>- `single`<br/>- `appears_on`<br/>- `compilation`<br/>For example: `include_groups=album,single`.
type QueryIncludeGroups = string

// QueryLimit The maximum number of items to return. Default: 20. Minimum: 1. Maximum: 50.
type QueryLimit = int

// QueryMarket An [ISO 3166-1 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
//
//	If a country code is specified, only content that is available in that market will be returned.<br/>
//	If a valid user access token is specified in the request header, the country associated with
//	the user account will take priority over this parameter.<br/>
//	_**Note**: If neither market or user country are provided, the content is considered unavailable for the client._<br/>
//	Users can view the country that is associated with their account in the [account settings](https://www.spotify.com/account/overview/).
type QueryMarket = string

// QueryOffset The index of the first item to return. Default: 0 (the first item). Use with limit to get the next set of items.
type QueryOffset = int

// QueryShowIds A comma-separated list of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids) for the shows. Maximum: 50 IDs.
type QueryShowIds = string

// QueryTrackIds A comma-separated list of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `ids=4iV5W9uYEdYUVa79Axb7Rh,1301WleyT98MSxVHPZCA6M`. Maximum: 50 IDs.
type QueryTrackIds = string

// ArrayOfBooleans defines model for ArrayOfBooleans.
type ArrayOfBooleans = []bool

// ArrayOfImages defines model for ArrayOfImages.
type ArrayOfImages = []ImageObject

// BadRequest defines model for BadRequest.
type BadRequest struct {
	Error ErrorObject `json:"error"`
}

// CursorPagedArtists defines model for CursorPagedArtists.
type CursorPagedArtists struct {
	Artists CursorPagingSimplifiedArtistObject `json:"artists"`
}

// CursorPagedPlayHistory defines model for CursorPagedPlayHistory.
type CursorPagedPlayHistory = CursorPagingPlayHistoryObject

// Forbidden defines model for Forbidden.
type Forbidden struct {
	Error ErrorObject `json:"error"`
}

// ManyAlbums defines model for ManyAlbums.
type ManyAlbums struct {
	Albums []AlbumObject `json:"albums"`
}

// ManyArtists defines model for ManyArtists.
type ManyArtists struct {
	Artists []ArtistObject `json:"artists"`
}

// ManyAudioFeatures defines model for ManyAudioFeatures.
type ManyAudioFeatures struct {
	AudioFeatures []AudioFeaturesObject `json:"audio_features"`
}

// ManyAudiobooks defines model for ManyAudiobooks.
type ManyAudiobooks struct {
	Audiobooks []AudiobookObject `json:"audiobooks"`
}

// ManyChapters defines model for ManyChapters.
type ManyChapters struct {
	Chapters []ChapterObject `json:"chapters"`
}

// ManyDevices defines model for ManyDevices.
type ManyDevices struct {
	Devices []DeviceObject `json:"devices"`
}

// ManyEpisodes defines model for ManyEpisodes.
type ManyEpisodes struct {
	Episodes []EpisodeObject `json:"episodes"`
}

// ManyGenres defines model for ManyGenres.
type ManyGenres struct {
	Genres []string `json:"genres"`
}

// ManySimplifiedShows defines model for ManySimplifiedShows.
type ManySimplifiedShows struct {
	Shows []SimplifiedShowObject `json:"shows"`
}

// ManyTracks defines model for ManyTracks.
type ManyTracks struct {
	Tracks []TrackObject `json:"tracks"`
}

// NotFound defines model for NotFound.
type NotFound struct {
	Error ErrorObject `json:"error"`
}

// OneAlbum defines model for OneAlbum.
type OneAlbum = AlbumObject

// OneArtist defines model for OneArtist.
type OneArtist = ArtistObject

// OneAudioAnalysis defines model for OneAudioAnalysis.
type OneAudioAnalysis = AudioAnalysisObject

// OneAudioFeatures defines model for OneAudioFeatures.
type OneAudioFeatures = AudioFeaturesObject

// OneAudiobook defines model for OneAudiobook.
type OneAudiobook = AudiobookObject

// OneCategory defines model for OneCategory.
type OneCategory = CategoryObject

// OneChapter defines model for OneChapter.
type OneChapter = ChapterObject

// OneCurrentlyPlaying defines model for OneCurrentlyPlaying.
type OneCurrentlyPlaying = CurrentlyPlayingContextObject

// OneCurrentlyPlayingTrack defines model for OneCurrentlyPlayingTrack.
type OneCurrentlyPlayingTrack = CurrentlyPlayingContextObject

// OneEpisode defines model for OneEpisode.
type OneEpisode = EpisodeObject

// OnePlaylist defines model for OnePlaylist.
type OnePlaylist = PlaylistObject

// OnePrivateUser defines model for OnePrivateUser.
type OnePrivateUser = PrivateUserObject

// OnePublicUser defines model for OnePublicUser.
type OnePublicUser = PublicUserObject

// OneRecommendations defines model for OneRecommendations.
type OneRecommendations = RecommendationsObject

// OneShow defines model for OneShow.
type OneShow = ShowObject

// OneTrack defines model for OneTrack.
type OneTrack = TrackObject

// PagedAlbums defines model for PagedAlbums.
type PagedAlbums struct {
	Albums PagingSimplifiedAlbumObject `json:"albums"`
}

// PagedCategories defines model for PagedCategories.
type PagedCategories struct {
	Categories struct {
		// Href A link to the Web API endpoint returning the full result of the request
		Href  string           `json:"href"`
		Items []CategoryObject `json:"items"`

		// Limit The maximum number of items in the response (as set in the query or by default).
		Limit int `json:"limit"`

		// Next URL to the next page of items. ( `null` if none)
		Next *string `json:"next"`

		// Offset The offset of the items returned (as set in the query or by default)
		Offset int `json:"offset"`

		// Previous URL to the previous page of items. ( `null` if none)
		Previous *string `json:"previous"`

		// Total The total number of items available to return.
		Total int `json:"total"`
	} `json:"categories"`
}

// PagedFeaturedPlaylists defines model for PagedFeaturedPlaylists.
type PagedFeaturedPlaylists = PagingFeaturedPlaylistObject

// PagedPlaylists defines model for PagedPlaylists.
type PagedPlaylists = PagingPlaylistObject

// PagingArtistOrTrackObject defines model for PagingArtistOrTrackObject.
type PagingArtistOrTrackObject struct {
	// Href A link to the Web API endpoint returning the full result of the request
	Href string `json:"href"`

	// Items Array of artist or track objects depending on request type parameter
	Items []map[string]interface{} `json:"items"`

	// Limit The maximum number of items in the response (as set in the query or by default).
	Limit int `json:"limit"`

	// Next URL to the next page of items. ( `null` if none)
	Next *string `json:"next"`

	// Offset The offset of the items returned (as set in the query or by default)
	Offset int `json:"offset"`

	// Previous URL to the previous page of items. ( `null` if none)
	Previous *string `json:"previous"`

	// Total The total number of items available to return.
	Total int `json:"total"`
}

// PlaylistSnapshotId defines model for PlaylistSnapshotId.
type PlaylistSnapshotId struct {
	SnapshotId *string `json:"snapshot_id,omitempty"`
}

// Queue defines model for Queue.
type Queue = QueueObject

// SearchItems defines model for SearchItems.
type SearchItems struct {
	Albums     *PagingSimplifiedAlbumObject     `json:"albums,omitempty"`
	Artists    *PagingArtistObject              `json:"artists,omitempty"`
	Audiobooks *PagingSimplifiedAudiobookObject `json:"audiobooks,omitempty"`
	Episodes   *PagingSimplifiedEpisodeObject   `json:"episodes,omitempty"`
	Playlists  *PagingPlaylistObject            `json:"playlists,omitempty"`
	Shows      *PagingSimplifiedShowObject      `json:"shows,omitempty"`
	Tracks     *PagingTrackObject               `json:"tracks,omitempty"`
}

// SingletonArrayOfBoolean defines model for SingletonArrayOfBoolean.
type SingletonArrayOfBoolean = []bool

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests struct {
	Error ErrorObject `json:"error"`
}

// Unauthorized defines model for Unauthorized.
type Unauthorized struct {
	Error ErrorObject `json:"error"`
}

// GetMultipleAlbumsParams defines parameters for GetMultipleAlbums.
type GetMultipleAlbumsParams struct {
	Ids    QueryAlbumIds `form:"ids" json:"ids"`
	Market *QueryMarket  `form:"market,omitempty" json:"market,omitempty"`
}

// GetAnAlbumParams defines parameters for GetAnAlbum.
type GetAnAlbumParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetAnAlbumsTracksParams defines parameters for GetAnAlbumsTracks.
type GetAnAlbumsTracksParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetMultipleArtistsParams defines parameters for GetMultipleArtists.
type GetMultipleArtistsParams struct {
	Ids string `form:"ids" json:"ids"`
}

// GetAnArtistsAlbumsParams defines parameters for GetAnArtistsAlbums.
type GetAnArtistsAlbumsParams struct {
	IncludeGroups *QueryIncludeGroups `form:"include_groups,omitempty" json:"include_groups,omitempty"`
	Market        *QueryMarket        `form:"market,omitempty" json:"market,omitempty"`
	Limit         *QueryLimit         `form:"limit,omitempty" json:"limit,omitempty"`
	Offset        *QueryOffset        `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetAnArtistsTopTracksParams defines parameters for GetAnArtistsTopTracks.
type GetAnArtistsTopTracksParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetSeveralAudioFeaturesParams defines parameters for GetSeveralAudioFeatures.
type GetSeveralAudioFeaturesParams struct {
	Ids string `form:"ids" json:"ids"`
}

// GetMultipleAudiobooksParams defines parameters for GetMultipleAudiobooks.
type GetMultipleAudiobooksParams struct {
	Ids    QueryAudiobookIds `form:"ids" json:"ids"`
	Market *QueryMarket      `form:"market,omitempty" json:"market,omitempty"`
}

// GetAnAudiobookParams defines parameters for GetAnAudiobook.
type GetAnAudiobookParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetAudiobookChaptersParams defines parameters for GetAudiobookChapters.
type GetAudiobookChaptersParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetCategoriesParams defines parameters for GetCategories.
type GetCategoriesParams struct {
	Locale *string      `form:"locale,omitempty" json:"locale,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetACategoryParams defines parameters for GetACategory.
type GetACategoryParams struct {
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// GetACategoriesPlaylistsParams defines parameters for GetACategoriesPlaylists.
type GetACategoriesPlaylistsParams struct {
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFeaturedPlaylistsParams defines parameters for GetFeaturedPlaylists.
type GetFeaturedPlaylistsParams struct {
	Locale *string      `form:"locale,omitempty" json:"locale,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetNewReleasesParams defines parameters for GetNewReleases.
type GetNewReleasesParams struct {
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetSeveralChaptersParams defines parameters for GetSeveralChapters.
type GetSeveralChaptersParams struct {
	Ids    QueryChapterIds `form:"ids" json:"ids"`
	Market *QueryMarket    `form:"market,omitempty" json:"market,omitempty"`
}

// GetAChapterParams defines parameters for GetAChapter.
type GetAChapterParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetMultipleEpisodesParams defines parameters for GetMultipleEpisodes.
type GetMultipleEpisodesParams struct {
	Ids    string       `form:"ids" json:"ids"`
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetAnEpisodeParams defines parameters for GetAnEpisode.
type GetAnEpisodeParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// RemoveAlbumsUserJSONBody defines parameters for RemoveAlbumsUser.
type RemoveAlbumsUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `["4iV5W9uYEdYUVa79Axb7Rh", "1301WleyT98MSxVHPZCA6M"]`<br/>A maximum of 50 items can be specified in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RemoveAlbumsUserParams defines parameters for RemoveAlbumsUser.
type RemoveAlbumsUserParams struct {
	Ids QueryAlbumIds `form:"ids" json:"ids"`
}

// GetUsersSavedAlbumsParams defines parameters for GetUsersSavedAlbums.
type GetUsersSavedAlbumsParams struct {
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// SaveAlbumsUserJSONBody defines parameters for SaveAlbumsUser.
type SaveAlbumsUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `["4iV5W9uYEdYUVa79Axb7Rh", "1301WleyT98MSxVHPZCA6M"]`<br/>A maximum of 50 items can be specified in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SaveAlbumsUserParams defines parameters for SaveAlbumsUser.
type SaveAlbumsUserParams struct {
	Ids QueryAlbumIds `form:"ids" json:"ids"`
}

// CheckUsersSavedAlbumsParams defines parameters for CheckUsersSavedAlbums.
type CheckUsersSavedAlbumsParams struct {
	Ids QueryAlbumIds `form:"ids" json:"ids"`
}

// RemoveAudiobooksUserParams defines parameters for RemoveAudiobooksUser.
type RemoveAudiobooksUserParams struct {
	Ids QueryAudiobookIds `form:"ids" json:"ids"`
}

// GetUsersSavedAudiobooksParams defines parameters for GetUsersSavedAudiobooks.
type GetUsersSavedAudiobooksParams struct {
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SaveAudiobooksUserParams defines parameters for SaveAudiobooksUser.
type SaveAudiobooksUserParams struct {
	Ids QueryAudiobookIds `form:"ids" json:"ids"`
}

// CheckUsersSavedAudiobooksParams defines parameters for CheckUsersSavedAudiobooks.
type CheckUsersSavedAudiobooksParams struct {
	Ids QueryAudiobookIds `form:"ids" json:"ids"`
}

// RemoveEpisodesUserJSONBody defines parameters for RemoveEpisodesUser.
type RemoveEpisodesUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). <br/>A maximum of 50 items can be specified in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RemoveEpisodesUserParams defines parameters for RemoveEpisodesUser.
type RemoveEpisodesUserParams struct {
	Ids QueryTrackIds `form:"ids" json:"ids"`
}

// GetUsersSavedEpisodesParams defines parameters for GetUsersSavedEpisodes.
type GetUsersSavedEpisodesParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SaveEpisodesUserJSONBody defines parameters for SaveEpisodesUser.
type SaveEpisodesUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). <br/>A maximum of 50 items can be specified in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SaveEpisodesUserParams defines parameters for SaveEpisodesUser.
type SaveEpisodesUserParams struct {
	Ids string `form:"ids" json:"ids"`
}

// CheckUsersSavedEpisodesParams defines parameters for CheckUsersSavedEpisodes.
type CheckUsersSavedEpisodesParams struct {
	Ids string `form:"ids" json:"ids"`
}

// UnfollowArtistsUsersJSONBody defines parameters for UnfollowArtistsUsers.
type UnfollowArtistsUsersJSONBody struct {
	// Ids A JSON array of the artist or user [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `{ids:["74ASZWbe4lXaubB36ztrGX", "08td7MxkoHQkXnWAYD8d6Q"]}`. A maximum of 50 IDs can be sent in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UnfollowArtistsUsersParams defines parameters for UnfollowArtistsUsers.
type UnfollowArtistsUsersParams struct {
	Type UnfollowArtistsUsersParamsType `form:"type" json:"type"`
	Ids  string                         `form:"ids" json:"ids"`
}

// UnfollowArtistsUsersParamsType defines parameters for UnfollowArtistsUsers.
type UnfollowArtistsUsersParamsType string

// GetFollowedParams defines parameters for GetFollowed.
type GetFollowedParams struct {
	Type  GetFollowedParamsType `form:"type" json:"type"`
	After *string               `form:"after,omitempty" json:"after,omitempty"`
	Limit *int                  `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetFollowedParamsType defines parameters for GetFollowed.
type GetFollowedParamsType string

// FollowArtistsUsersJSONBody defines parameters for FollowArtistsUsers.
type FollowArtistsUsersJSONBody struct {
	// Ids A JSON array of the artist or user [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids).
	// For example: `{ids:["74ASZWbe4lXaubB36ztrGX", "08td7MxkoHQkXnWAYD8d6Q"]}`. A maximum of 50 IDs can be sent in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  []string               `json:"ids"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// FollowArtistsUsersParams defines parameters for FollowArtistsUsers.
type FollowArtistsUsersParams struct {
	Type FollowArtistsUsersParamsType `form:"type" json:"type"`
	Ids  string                       `form:"ids" json:"ids"`
}

// FollowArtistsUsersParamsType defines parameters for FollowArtistsUsers.
type FollowArtistsUsersParamsType string

// CheckCurrentUserFollowsParams defines parameters for CheckCurrentUserFollows.
type CheckCurrentUserFollowsParams struct {
	Type CheckCurrentUserFollowsParamsType `form:"type" json:"type"`
	Ids  string                            `form:"ids" json:"ids"`
}

// CheckCurrentUserFollowsParamsType defines parameters for CheckCurrentUserFollows.
type CheckCurrentUserFollowsParamsType string

// GetInformationAboutTheUsersCurrentPlaybackParams defines parameters for GetInformationAboutTheUsersCurrentPlayback.
type GetInformationAboutTheUsersCurrentPlaybackParams struct {
	Market          *QueryMarket          `form:"market,omitempty" json:"market,omitempty"`
	AdditionalTypes *QueryAdditionalTypes `form:"additional_types,omitempty" json:"additional_types,omitempty"`
}

// TransferAUsersPlaybackJSONBody defines parameters for TransferAUsersPlayback.
type TransferAUsersPlaybackJSONBody struct {
	// DeviceIds A JSON array containing the ID of the device on which playback should be started/transferred.<br/>For example:`{device_ids:["74ASZWbe4lXaubB36ztrGX"]}`<br/>_**Note**: Although an array is accepted, only a single device_id is currently supported. Supplying more than one will return `400 Bad Request`_
	DeviceIds []string `json:"device_ids"`

	// Play **true**: ensure playback happens on new device.<br/>**false** or not provided: keep the current playback state.
	Play                 *bool                  `json:"play,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetTheUsersCurrentlyPlayingTrackParams defines parameters for GetTheUsersCurrentlyPlayingTrack.
type GetTheUsersCurrentlyPlayingTrackParams struct {
	Market          *QueryMarket          `form:"market,omitempty" json:"market,omitempty"`
	AdditionalTypes *QueryAdditionalTypes `form:"additional_types,omitempty" json:"additional_types,omitempty"`
}

// SkipUsersPlaybackToNextTrackParams defines parameters for SkipUsersPlaybackToNextTrack.
type SkipUsersPlaybackToNextTrackParams struct {
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// PauseAUsersPlaybackParams defines parameters for PauseAUsersPlayback.
type PauseAUsersPlaybackParams struct {
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// StartAUsersPlaybackJSONBody defines parameters for StartAUsersPlayback.
type StartAUsersPlaybackJSONBody struct {
	// ContextUri Optional. Spotify URI of the context to play.
	// Valid contexts are albums, artists & playlists.
	// `{context_uri:"spotify:album:1Je1IMUlBXcx1Fz0WE7oPT"}`
	ContextUri *string `json:"context_uri,omitempty"`

	// Offset Optional. Indicates from where in the context playback should start. Only available when context_uri corresponds to an album or playlist object
	// "position" is zero based and can’t be negative. Example: `"offset": {"position": 5}`
	// "uri" is a string representing the uri of the item to start at. Example: `"offset": {"uri": "spotify:track:1301WleyT98MSxVHPZCA6M"}`
	Offset *map[string]interface{} `json:"offset,omitempty"`

	// PositionMs integer
	PositionMs *int `json:"position_ms,omitempty"`

	// Uris Optional. A JSON array of the Spotify track URIs to play.
	// For example: `{"uris": ["spotify:track:4iV5W9uYEdYUVa79Axb7Rh", "spotify:track:1301WleyT98MSxVHPZCA6M"]}`
	Uris                 *[]string              `json:"uris,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StartAUsersPlaybackParams defines parameters for StartAUsersPlayback.
type StartAUsersPlaybackParams struct {
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// SkipUsersPlaybackToPreviousTrackParams defines parameters for SkipUsersPlaybackToPreviousTrack.
type SkipUsersPlaybackToPreviousTrackParams struct {
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// AddToQueueParams defines parameters for AddToQueue.
type AddToQueueParams struct {
	Uri      string  `form:"uri" json:"uri"`
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// GetRecentlyPlayedParams defines parameters for GetRecentlyPlayed.
type GetRecentlyPlayedParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	After  *int `form:"after,omitempty" json:"after,omitempty"`
	Before *int `form:"before,omitempty" json:"before,omitempty"`
}

// SetRepeatModeOnUsersPlaybackParams defines parameters for SetRepeatModeOnUsersPlayback.
type SetRepeatModeOnUsersPlaybackParams struct {
	State    string  `form:"state" json:"state"`
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// SeekToPositionInCurrentlyPlayingTrackParams defines parameters for SeekToPositionInCurrentlyPlayingTrack.
type SeekToPositionInCurrentlyPlayingTrackParams struct {
	PositionMs int     `form:"position_ms" json:"position_ms"`
	DeviceId   *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// ToggleShuffleForUsersPlaybackParams defines parameters for ToggleShuffleForUsersPlayback.
type ToggleShuffleForUsersPlaybackParams struct {
	State    bool    `form:"state" json:"state"`
	DeviceId *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// SetVolumeForUsersPlaybackParams defines parameters for SetVolumeForUsersPlayback.
type SetVolumeForUsersPlaybackParams struct {
	VolumePercent int     `form:"volume_percent" json:"volume_percent"`
	DeviceId      *string `form:"device_id,omitempty" json:"device_id,omitempty"`
}

// GetAListOfCurrentUsersPlaylistsParams defines parameters for GetAListOfCurrentUsersPlaylists.
type GetAListOfCurrentUsersPlaylistsParams struct {
	Limit  *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int        `form:"offset,omitempty" json:"offset,omitempty"`
}

// RemoveShowsUserParams defines parameters for RemoveShowsUser.
type RemoveShowsUserParams struct {
	Ids    QueryShowIds `form:"ids" json:"ids"`
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetUsersSavedShowsParams defines parameters for GetUsersSavedShows.
type GetUsersSavedShowsParams struct {
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SaveShowsUserParams defines parameters for SaveShowsUser.
type SaveShowsUserParams struct {
	Ids QueryShowIds `form:"ids" json:"ids"`
}

// CheckUsersSavedShowsParams defines parameters for CheckUsersSavedShows.
type CheckUsersSavedShowsParams struct {
	Ids QueryShowIds `form:"ids" json:"ids"`
}

// GetUsersTopArtistsAndTracksParams defines parameters for GetUsersTopArtistsAndTracks.
type GetUsersTopArtistsAndTracksParams struct {
	TimeRange *string      `form:"time_range,omitempty" json:"time_range,omitempty"`
	Limit     *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetUsersTopArtistsAndTracksParamsType defines parameters for GetUsersTopArtistsAndTracks.
type GetUsersTopArtistsAndTracksParamsType string

// RemoveTracksUserJSONBody defines parameters for RemoveTracksUser.
type RemoveTracksUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `["4iV5W9uYEdYUVa79Axb7Rh", "1301WleyT98MSxVHPZCA6M"]`<br/>A maximum of 50 items can be specified in one request. _**Note**: if the `ids` parameter is present in the query string, any IDs listed here in the body will be ignored._
	Ids                  *[]string              `json:"ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RemoveTracksUserParams defines parameters for RemoveTracksUser.
type RemoveTracksUserParams struct {
	Ids QueryTrackIds `form:"ids" json:"ids"`
}

// GetUsersSavedTracksParams defines parameters for GetUsersSavedTracks.
type GetUsersSavedTracksParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SaveTracksUserJSONBody defines parameters for SaveTracksUser.
type SaveTracksUserJSONBody struct {
	// Ids A JSON array of the [Spotify IDs](/documentation/web-api/concepts/spotify-uris-ids). For example: `["4iV5W9uYEdYUVa79Axb7Rh", "1301WleyT98MSxVHPZCA6M"]`<br/>A maximum of 50 items can be specified in one request. _**Note**: if the `timestamped_ids` is present in the body, any IDs listed in the query parameters (deprecated) or the `ids` field in the body will be ignored._
	Ids *[]string `json:"ids,omitempty"`

	// TimestampedIds A JSON array of objects containing track IDs with their corresponding timestamps. Each object must include a track ID and an `added_at` timestamp. This allows you to specify when tracks were added to maintain a specific chronological order in the user's library.<br/>A maximum of 50 items can be specified in one request. _**Note**: if the `timestamped_ids` is present in the body, any IDs listed in the query parameters (deprecated) or the `ids` field in the body will be ignored._
	TimestampedIds *[]struct {
		// AddedAt The timestamp when the track was added to the library. Use ISO 8601 format with UTC timezone (e.g., `2023-01-15T14:30:00Z`). You can specify past timestamps to insert tracks at specific positions in the library's chronological order. The API uses minute-level granularity for ordering, though the timestamp supports millisecond precision.
		AddedAt time.Time `json:"added_at"`

		// Id The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the track.
		Id string `json:"id"`
	} `json:"timestamped_ids,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CheckUsersSavedTracksParams defines parameters for CheckUsersSavedTracks.
type CheckUsersSavedTracksParams struct {
	Ids QueryTrackIds `form:"ids" json:"ids"`
}

// GetPlaylistParams defines parameters for GetPlaylist.
type GetPlaylistParams struct {
	Market          *QueryMarket          `form:"market,omitempty" json:"market,omitempty"`
	Fields          *string               `form:"fields,omitempty" json:"fields,omitempty"`
	AdditionalTypes *QueryAdditionalTypes `form:"additional_types,omitempty" json:"additional_types,omitempty"`
}

// ChangePlaylistDetailsJSONBody defines parameters for ChangePlaylistDetails.
type ChangePlaylistDetailsJSONBody struct {
	// Collaborative If `true`, the playlist will become collaborative and other users will be able to modify the playlist in their Spotify client. <br/>
	// _**Note**: You can only set `collaborative` to `true` on non-public playlists._
	Collaborative *bool `json:"collaborative,omitempty"`

	// Description Value for playlist description as displayed in Spotify Clients and in the Web API.
	Description *string `json:"description,omitempty"`

	// Name The new name for the playlist, for example `"My New Playlist Title"`
	Name *string `json:"name,omitempty"`

	// Public The playlist's public/private status (if it should be added to the user's profile or not): `true` the playlist will be public, `false` the playlist will be private, `null` the playlist status is not relevant. For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists)
	Public               *bool                  `json:"public,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// FollowPlaylistJSONBody defines parameters for FollowPlaylist.
type FollowPlaylistJSONBody struct {
	// Public Defaults to `true`. If `true` the playlist will be included in user's public playlists (added to profile), if `false` it will remain private. For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists)
	Public               *bool                  `json:"public,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CheckIfUserFollowsPlaylistParams defines parameters for CheckIfUserFollowsPlaylist.
type CheckIfUserFollowsPlaylistParams struct {
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`
}

// RemoveTracksPlaylistJSONBody defines parameters for RemoveTracksPlaylist.
type RemoveTracksPlaylistJSONBody struct {
	// SnapshotId The playlist's snapshot ID against which you want to make the changes.
	// The API will validate that the specified items exist and in the specified positions and make the changes,
	// even if more recent changes have been made to the playlist.
	SnapshotId *string `json:"snapshot_id,omitempty"`

	// Tracks An array of objects containing [Spotify URIs](/documentation/web-api/concepts/spotify-uris-ids) of the tracks or episodes to remove.
	// For example: `{ "tracks": [{ "uri": "spotify:track:4iV5W9uYEdYUVa79Axb7Rh" },{ "uri": "spotify:track:1301WleyT98MSxVHPZCA6M" }] }`. A maximum of 100 objects can be sent at once.
	Tracks []struct {
		// Uri Spotify URI
		Uri *string `json:"uri,omitempty"`
	} `json:"tracks"`
}

// GetPlaylistsTracksParams defines parameters for GetPlaylistsTracks.
type GetPlaylistsTracksParams struct {
	Market          *QueryMarket          `form:"market,omitempty" json:"market,omitempty"`
	Fields          *string               `form:"fields,omitempty" json:"fields,omitempty"`
	Limit           *QueryLimit           `form:"limit,omitempty" json:"limit,omitempty"`
	Offset          *QueryOffset          `form:"offset,omitempty" json:"offset,omitempty"`
	AdditionalTypes *QueryAdditionalTypes `form:"additional_types,omitempty" json:"additional_types,omitempty"`
}

// AddTracksToPlaylistJSONBody defines parameters for AddTracksToPlaylist.
type AddTracksToPlaylistJSONBody struct {
	// Position The position to insert the items, a zero-based index. For example, to insert the items in the first position: `position=0` ; to insert the items in the third position: `position=2`. If omitted, the items will be appended to the playlist. Items are added in the order they appear in the uris array. For example: `{"uris": ["spotify:track:4iV5W9uYEdYUVa79Axb7Rh","spotify:track:1301WleyT98MSxVHPZCA6M"], "position": 3}`
	Position *int `json:"position,omitempty"`

	// Uris A JSON array of the [Spotify URIs](/documentation/web-api/concepts/spotify-uris-ids) to add. For example: `{"uris": ["spotify:track:4iV5W9uYEdYUVa79Axb7Rh","spotify:track:1301WleyT98MSxVHPZCA6M", "spotify:episode:512ojhOuo1ktJprKbVcKyQ"]}`<br/>A maximum of 100 items can be added in one request. _**Note**: if the `uris` parameter is present in the query string, any URIs listed here in the body will be ignored._
	Uris                 *[]string              `json:"uris,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AddTracksToPlaylistParams defines parameters for AddTracksToPlaylist.
type AddTracksToPlaylistParams struct {
	Position *int    `form:"position,omitempty" json:"position,omitempty"`
	Uris     *string `form:"uris,omitempty" json:"uris,omitempty"`
}

// ReorderOrReplacePlaylistsTracksJSONBody defines parameters for ReorderOrReplacePlaylistsTracks.
type ReorderOrReplacePlaylistsTracksJSONBody struct {
	// InsertBefore The position where the items should be inserted.<br/>To reorder the items to the end of the playlist, simply set _insert_before_ to the position after the last item.<br/>Examples:<br/>To reorder the first item to the last position in a playlist with 10 items, set _range_start_ to 0, and _insert_before_ to 10.<br/>To reorder the last item in a playlist with 10 items to the start of the playlist, set _range_start_ to 9, and _insert_before_ to 0.
	InsertBefore *int `json:"insert_before,omitempty"`

	// RangeLength The amount of items to be reordered. Defaults to 1 if not set.<br/>The range of items to be reordered begins from the _range_start_ position, and includes the _range_length_ subsequent items.<br/>Example:<br/>To move the items at index 9-10 to the start of the playlist, _range_start_ is set to 9, and _range_length_ is set to 2.
	RangeLength *int `json:"range_length,omitempty"`

	// RangeStart The position of the first item to be reordered.
	RangeStart *int `json:"range_start,omitempty"`

	// SnapshotId The playlist's snapshot ID against which you want to make the changes.
	SnapshotId           *string                `json:"snapshot_id,omitempty"`
	Uris                 *[]string              `json:"uris,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReorderOrReplacePlaylistsTracksParams defines parameters for ReorderOrReplacePlaylistsTracks.
type ReorderOrReplacePlaylistsTracksParams struct {
	Uris *string `form:"uris,omitempty" json:"uris,omitempty"`
}

// GetRecommendationsParams defines parameters for GetRecommendations.
type GetRecommendationsParams struct {
	Limit                  *int         `form:"limit,omitempty" json:"limit,omitempty"`
	Market                 *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	SeedArtists            string       `form:"seed_artists" json:"seed_artists"`
	SeedGenres             string       `form:"seed_genres" json:"seed_genres"`
	SeedTracks             string       `form:"seed_tracks" json:"seed_tracks"`
	MinAcousticness        *float32     `form:"min_acousticness,omitempty" json:"min_acousticness,omitempty"`
	MaxAcousticness        *float32     `form:"max_acousticness,omitempty" json:"max_acousticness,omitempty"`
	TargetAcousticness     *float32     `form:"target_acousticness,omitempty" json:"target_acousticness,omitempty"`
	MinDanceability        *float32     `form:"min_danceability,omitempty" json:"min_danceability,omitempty"`
	MaxDanceability        *float32     `form:"max_danceability,omitempty" json:"max_danceability,omitempty"`
	TargetDanceability     *float32     `form:"target_danceability,omitempty" json:"target_danceability,omitempty"`
	MinDurationMs          *int         `form:"min_duration_ms,omitempty" json:"min_duration_ms,omitempty"`
	MaxDurationMs          *int         `form:"max_duration_ms,omitempty" json:"max_duration_ms,omitempty"`
	TargetDurationMs       *int         `form:"target_duration_ms,omitempty" json:"target_duration_ms,omitempty"`
	MinEnergy              *float32     `form:"min_energy,omitempty" json:"min_energy,omitempty"`
	MaxEnergy              *float32     `form:"max_energy,omitempty" json:"max_energy,omitempty"`
	TargetEnergy           *float32     `form:"target_energy,omitempty" json:"target_energy,omitempty"`
	MinInstrumentalness    *float32     `form:"min_instrumentalness,omitempty" json:"min_instrumentalness,omitempty"`
	MaxInstrumentalness    *float32     `form:"max_instrumentalness,omitempty" json:"max_instrumentalness,omitempty"`
	TargetInstrumentalness *float32     `form:"target_instrumentalness,omitempty" json:"target_instrumentalness,omitempty"`
	MinKey                 *int         `form:"min_key,omitempty" json:"min_key,omitempty"`
	MaxKey                 *int         `form:"max_key,omitempty" json:"max_key,omitempty"`
	TargetKey              *int         `form:"target_key,omitempty" json:"target_key,omitempty"`
	MinLiveness            *float32     `form:"min_liveness,omitempty" json:"min_liveness,omitempty"`
	MaxLiveness            *float32     `form:"max_liveness,omitempty" json:"max_liveness,omitempty"`
	TargetLiveness         *float32     `form:"target_liveness,omitempty" json:"target_liveness,omitempty"`
	MinLoudness            *float32     `form:"min_loudness,omitempty" json:"min_loudness,omitempty"`
	MaxLoudness            *float32     `form:"max_loudness,omitempty" json:"max_loudness,omitempty"`
	TargetLoudness         *float32     `form:"target_loudness,omitempty" json:"target_loudness,omitempty"`
	MinMode                *int         `form:"min_mode,omitempty" json:"min_mode,omitempty"`
	MaxMode                *int         `form:"max_mode,omitempty" json:"max_mode,omitempty"`
	TargetMode             *int         `form:"target_mode,omitempty" json:"target_mode,omitempty"`
	MinPopularity          *int         `form:"min_popularity,omitempty" json:"min_popularity,omitempty"`
	MaxPopularity          *int         `form:"max_popularity,omitempty" json:"max_popularity,omitempty"`
	TargetPopularity       *int         `form:"target_popularity,omitempty" json:"target_popularity,omitempty"`
	MinSpeechiness         *float32     `form:"min_speechiness,omitempty" json:"min_speechiness,omitempty"`
	MaxSpeechiness         *float32     `form:"max_speechiness,omitempty" json:"max_speechiness,omitempty"`
	TargetSpeechiness      *float32     `form:"target_speechiness,omitempty" json:"target_speechiness,omitempty"`
	MinTempo               *float32     `form:"min_tempo,omitempty" json:"min_tempo,omitempty"`
	MaxTempo               *float32     `form:"max_tempo,omitempty" json:"max_tempo,omitempty"`
	TargetTempo            *float32     `form:"target_tempo,omitempty" json:"target_tempo,omitempty"`
	MinTimeSignature       *int         `form:"min_time_signature,omitempty" json:"min_time_signature,omitempty"`
	MaxTimeSignature       *int         `form:"max_time_signature,omitempty" json:"max_time_signature,omitempty"`
	TargetTimeSignature    *int         `form:"target_time_signature,omitempty" json:"target_time_signature,omitempty"`
	MinValence             *float32     `form:"min_valence,omitempty" json:"min_valence,omitempty"`
	MaxValence             *float32     `form:"max_valence,omitempty" json:"max_valence,omitempty"`
	TargetValence          *float32     `form:"target_valence,omitempty" json:"target_valence,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	Q               string                       `form:"q" json:"q"`
	Type            []SearchParamsType           `form:"type" json:"type"`
	Market          *QueryMarket                 `form:"market,omitempty" json:"market,omitempty"`
	Limit           *int                         `form:"limit,omitempty" json:"limit,omitempty"`
	Offset          *int                         `form:"offset,omitempty" json:"offset,omitempty"`
	IncludeExternal *SearchParamsIncludeExternal `form:"include_external,omitempty" json:"include_external,omitempty"`
}

// SearchParamsType defines parameters for Search.
type SearchParamsType string

// SearchParamsIncludeExternal defines parameters for Search.
type SearchParamsIncludeExternal string

// GetMultipleShowsParams defines parameters for GetMultipleShows.
type GetMultipleShowsParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Ids    QueryShowIds `form:"ids" json:"ids"`
}

// GetAShowParams defines parameters for GetAShow.
type GetAShowParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetAShowsEpisodesParams defines parameters for GetAShowsEpisodes.
type GetAShowsEpisodesParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Limit  *QueryLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetSeveralTracksParams defines parameters for GetSeveralTracks.
type GetSeveralTracksParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
	Ids    string       `form:"ids" json:"ids"`
}

// GetTrackParams defines parameters for GetTrack.
type GetTrackParams struct {
	Market *QueryMarket `form:"market,omitempty" json:"market,omitempty"`
}

// GetListUsersPlaylistsParams defines parameters for GetListUsersPlaylists.
type GetListUsersPlaylistsParams struct {
	Limit  *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int        `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreatePlaylistJSONBody defines parameters for CreatePlaylist.
type CreatePlaylistJSONBody struct {
	// Collaborative Defaults to `false`. If `true` the playlist will be collaborative. _**Note**: to create a collaborative playlist you must also set `public` to `false`. To create collaborative playlists you must have granted `playlist-modify-private` and `playlist-modify-public` [scopes](/documentation/web-api/concepts/scopes/#list-of-scopes)._
	Collaborative *bool `json:"collaborative,omitempty"`

	// Description value for playlist description as displayed in Spotify Clients and in the Web API.
	Description *string `json:"description,omitempty"`

	// Name The name for the new playlist, for example `"Your Coolest Playlist"`. This name does not need to be unique; a user may have several playlists with the same name.
	Name string `json:"name"`

	// Public Defaults to `true`. The playlist's public/private status (if it should be added to the user's profile or not): `true` the playlist will be public, `false` the playlist will be private. To be able to create private playlists, the user must have granted the `playlist-modify-private` [scope](/documentation/web-api/concepts/scopes/#list-of-scopes). For more about public/private status, see [Working with Playlists](/documentation/web-api/concepts/playlists)
	Public               *bool                  `json:"public,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RemoveAlbumsUserJSONRequestBody defines body for RemoveAlbumsUser for application/json ContentType.
type RemoveAlbumsUserJSONRequestBody RemoveAlbumsUserJSONBody

// SaveAlbumsUserJSONRequestBody defines body for SaveAlbumsUser for application/json ContentType.
type SaveAlbumsUserJSONRequestBody SaveAlbumsUserJSONBody

// RemoveEpisodesUserJSONRequestBody defines body for RemoveEpisodesUser for application/json ContentType.
type RemoveEpisodesUserJSONRequestBody RemoveEpisodesUserJSONBody

// SaveEpisodesUserJSONRequestBody defines body for SaveEpisodesUser for application/json ContentType.
type SaveEpisodesUserJSONRequestBody SaveEpisodesUserJSONBody

// UnfollowArtistsUsersJSONRequestBody defines body for UnfollowArtistsUsers for application/json ContentType.
type UnfollowArtistsUsersJSONRequestBody UnfollowArtistsUsersJSONBody

// FollowArtistsUsersJSONRequestBody defines body for FollowArtistsUsers for application/json ContentType.
type FollowArtistsUsersJSONRequestBody FollowArtistsUsersJSONBody

// TransferAUsersPlaybackJSONRequestBody defines body for TransferAUsersPlayback for application/json ContentType.
type TransferAUsersPlaybackJSONRequestBody TransferAUsersPlaybackJSONBody

// StartAUsersPlaybackJSONRequestBody defines body for StartAUsersPlayback for application/json ContentType.
type StartAUsersPlaybackJSONRequestBody StartAUsersPlaybackJSONBody

// RemoveTracksUserJSONRequestBody defines body for RemoveTracksUser for application/json ContentType.
type RemoveTracksUserJSONRequestBody RemoveTracksUserJSONBody

// SaveTracksUserJSONRequestBody defines body for SaveTracksUser for application/json ContentType.
type SaveTracksUserJSONRequestBody SaveTracksUserJSONBody

// ChangePlaylistDetailsJSONRequestBody defines body for ChangePlaylistDetails for application/json ContentType.
type ChangePlaylistDetailsJSONRequestBody ChangePlaylistDetailsJSONBody

// FollowPlaylistJSONRequestBody defines body for FollowPlaylist for application/json ContentType.
type FollowPlaylistJSONRequestBody FollowPlaylistJSONBody

// RemoveTracksPlaylistJSONRequestBody defines body for RemoveTracksPlaylist for application/json ContentType.
type RemoveTracksPlaylistJSONRequestBody RemoveTracksPlaylistJSONBody

// AddTracksToPlaylistJSONRequestBody defines body for AddTracksToPlaylist for application/json ContentType.
type AddTracksToPlaylistJSONRequestBody AddTracksToPlaylistJSONBody

// ReorderOrReplacePlaylistsTracksJSONRequestBody defines body for ReorderOrReplacePlaylistsTracks for application/json ContentType.
type ReorderOrReplacePlaylistsTracksJSONRequestBody ReorderOrReplacePlaylistsTracksJSONBody

// CreatePlaylistJSONRequestBody defines body for CreatePlaylist for application/json ContentType.
type CreatePlaylistJSONRequestBody CreatePlaylistJSONBody

// Getter for additional properties for RemoveAlbumsUserJSONBody. Returns the specified
// element and whether it was found
func (a RemoveAlbumsUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RemoveAlbumsUserJSONBody
func (a *RemoveAlbumsUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RemoveAlbumsUserJSONBody to handle AdditionalProperties
func (a *RemoveAlbumsUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RemoveAlbumsUserJSONBody to handle AdditionalProperties
func (a RemoveAlbumsUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SaveAlbumsUserJSONBody. Returns the specified
// element and whether it was found
func (a SaveAlbumsUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SaveAlbumsUserJSONBody
func (a *SaveAlbumsUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SaveAlbumsUserJSONBody to handle AdditionalProperties
func (a *SaveAlbumsUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SaveAlbumsUserJSONBody to handle AdditionalProperties
func (a SaveAlbumsUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RemoveEpisodesUserJSONBody. Returns the specified
// element and whether it was found
func (a RemoveEpisodesUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RemoveEpisodesUserJSONBody
func (a *RemoveEpisodesUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RemoveEpisodesUserJSONBody to handle AdditionalProperties
func (a *RemoveEpisodesUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RemoveEpisodesUserJSONBody to handle AdditionalProperties
func (a RemoveEpisodesUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SaveEpisodesUserJSONBody. Returns the specified
// element and whether it was found
func (a SaveEpisodesUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SaveEpisodesUserJSONBody
func (a *SaveEpisodesUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SaveEpisodesUserJSONBody to handle AdditionalProperties
func (a *SaveEpisodesUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SaveEpisodesUserJSONBody to handle AdditionalProperties
func (a SaveEpisodesUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UnfollowArtistsUsersJSONBody. Returns the specified
// element and whether it was found
func (a UnfollowArtistsUsersJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UnfollowArtistsUsersJSONBody
func (a *UnfollowArtistsUsersJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UnfollowArtistsUsersJSONBody to handle AdditionalProperties
func (a *UnfollowArtistsUsersJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UnfollowArtistsUsersJSONBody to handle AdditionalProperties
func (a UnfollowArtistsUsersJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FollowArtistsUsersJSONBody. Returns the specified
// element and whether it was found
func (a FollowArtistsUsersJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FollowArtistsUsersJSONBody
func (a *FollowArtistsUsersJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FollowArtistsUsersJSONBody to handle AdditionalProperties
func (a *FollowArtistsUsersJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FollowArtistsUsersJSONBody to handle AdditionalProperties
func (a FollowArtistsUsersJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TransferAUsersPlaybackJSONBody. Returns the specified
// element and whether it was found
func (a TransferAUsersPlaybackJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TransferAUsersPlaybackJSONBody
func (a *TransferAUsersPlaybackJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TransferAUsersPlaybackJSONBody to handle AdditionalProperties
func (a *TransferAUsersPlaybackJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["device_ids"]; found {
		err = json.Unmarshal(raw, &a.DeviceIds)
		if err != nil {
			return fmt.Errorf("error reading 'device_ids': %w", err)
		}
		delete(object, "device_ids")
	}

	if raw, found := object["play"]; found {
		err = json.Unmarshal(raw, &a.Play)
		if err != nil {
			return fmt.Errorf("error reading 'play': %w", err)
		}
		delete(object, "play")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TransferAUsersPlaybackJSONBody to handle AdditionalProperties
func (a TransferAUsersPlaybackJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DeviceIds != nil {
		object["device_ids"], err = json.Marshal(a.DeviceIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'device_ids': %w", err)
		}
	}

	if a.Play != nil {
		object["play"], err = json.Marshal(a.Play)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'play': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StartAUsersPlaybackJSONBody. Returns the specified
// element and whether it was found
func (a StartAUsersPlaybackJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StartAUsersPlaybackJSONBody
func (a *StartAUsersPlaybackJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StartAUsersPlaybackJSONBody to handle AdditionalProperties
func (a *StartAUsersPlaybackJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["context_uri"]; found {
		err = json.Unmarshal(raw, &a.ContextUri)
		if err != nil {
			return fmt.Errorf("error reading 'context_uri': %w", err)
		}
		delete(object, "context_uri")
	}

	if raw, found := object["offset"]; found {
		err = json.Unmarshal(raw, &a.Offset)
		if err != nil {
			return fmt.Errorf("error reading 'offset': %w", err)
		}
		delete(object, "offset")
	}

	if raw, found := object["position_ms"]; found {
		err = json.Unmarshal(raw, &a.PositionMs)
		if err != nil {
			return fmt.Errorf("error reading 'position_ms': %w", err)
		}
		delete(object, "position_ms")
	}

	if raw, found := object["uris"]; found {
		err = json.Unmarshal(raw, &a.Uris)
		if err != nil {
			return fmt.Errorf("error reading 'uris': %w", err)
		}
		delete(object, "uris")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StartAUsersPlaybackJSONBody to handle AdditionalProperties
func (a StartAUsersPlaybackJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ContextUri != nil {
		object["context_uri"], err = json.Marshal(a.ContextUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'context_uri': %w", err)
		}
	}

	if a.Offset != nil {
		object["offset"], err = json.Marshal(a.Offset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'offset': %w", err)
		}
	}

	if a.PositionMs != nil {
		object["position_ms"], err = json.Marshal(a.PositionMs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'position_ms': %w", err)
		}
	}

	if a.Uris != nil {
		object["uris"], err = json.Marshal(a.Uris)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uris': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RemoveTracksUserJSONBody. Returns the specified
// element and whether it was found
func (a RemoveTracksUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RemoveTracksUserJSONBody
func (a *RemoveTracksUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RemoveTracksUserJSONBody to handle AdditionalProperties
func (a *RemoveTracksUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RemoveTracksUserJSONBody to handle AdditionalProperties
func (a RemoveTracksUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SaveTracksUserJSONBody. Returns the specified
// element and whether it was found
func (a SaveTracksUserJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SaveTracksUserJSONBody
func (a *SaveTracksUserJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SaveTracksUserJSONBody to handle AdditionalProperties
func (a *SaveTracksUserJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ids"]; found {
		err = json.Unmarshal(raw, &a.Ids)
		if err != nil {
			return fmt.Errorf("error reading 'ids': %w", err)
		}
		delete(object, "ids")
	}

	if raw, found := object["timestamped_ids"]; found {
		err = json.Unmarshal(raw, &a.TimestampedIds)
		if err != nil {
			return fmt.Errorf("error reading 'timestamped_ids': %w", err)
		}
		delete(object, "timestamped_ids")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SaveTracksUserJSONBody to handle AdditionalProperties
func (a SaveTracksUserJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ids != nil {
		object["ids"], err = json.Marshal(a.Ids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ids': %w", err)
		}
	}

	if a.TimestampedIds != nil {
		object["timestamped_ids"], err = json.Marshal(a.TimestampedIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timestamped_ids': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChangePlaylistDetailsJSONBody. Returns the specified
// element and whether it was found
func (a ChangePlaylistDetailsJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChangePlaylistDetailsJSONBody
func (a *ChangePlaylistDetailsJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChangePlaylistDetailsJSONBody to handle AdditionalProperties
func (a *ChangePlaylistDetailsJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["collaborative"]; found {
		err = json.Unmarshal(raw, &a.Collaborative)
		if err != nil {
			return fmt.Errorf("error reading 'collaborative': %w", err)
		}
		delete(object, "collaborative")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["public"]; found {
		err = json.Unmarshal(raw, &a.Public)
		if err != nil {
			return fmt.Errorf("error reading 'public': %w", err)
		}
		delete(object, "public")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChangePlaylistDetailsJSONBody to handle AdditionalProperties
func (a ChangePlaylistDetailsJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Collaborative != nil {
		object["collaborative"], err = json.Marshal(a.Collaborative)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'collaborative': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Public != nil {
		object["public"], err = json.Marshal(a.Public)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'public': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FollowPlaylistJSONBody. Returns the specified
// element and whether it was found
func (a FollowPlaylistJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FollowPlaylistJSONBody
func (a *FollowPlaylistJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FollowPlaylistJSONBody to handle AdditionalProperties
func (a *FollowPlaylistJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["public"]; found {
		err = json.Unmarshal(raw, &a.Public)
		if err != nil {
			return fmt.Errorf("error reading 'public': %w", err)
		}
		delete(object, "public")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FollowPlaylistJSONBody to handle AdditionalProperties
func (a FollowPlaylistJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Public != nil {
		object["public"], err = json.Marshal(a.Public)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'public': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AddTracksToPlaylistJSONBody. Returns the specified
// element and whether it was found
func (a AddTracksToPlaylistJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AddTracksToPlaylistJSONBody
func (a *AddTracksToPlaylistJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AddTracksToPlaylistJSONBody to handle AdditionalProperties
func (a *AddTracksToPlaylistJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["position"]; found {
		err = json.Unmarshal(raw, &a.Position)
		if err != nil {
			return fmt.Errorf("error reading 'position': %w", err)
		}
		delete(object, "position")
	}

	if raw, found := object["uris"]; found {
		err = json.Unmarshal(raw, &a.Uris)
		if err != nil {
			return fmt.Errorf("error reading 'uris': %w", err)
		}
		delete(object, "uris")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AddTracksToPlaylistJSONBody to handle AdditionalProperties
func (a AddTracksToPlaylistJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Position != nil {
		object["position"], err = json.Marshal(a.Position)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'position': %w", err)
		}
	}

	if a.Uris != nil {
		object["uris"], err = json.Marshal(a.Uris)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uris': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ReorderOrReplacePlaylistsTracksJSONBody. Returns the specified
// element and whether it was found
func (a ReorderOrReplacePlaylistsTracksJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReorderOrReplacePlaylistsTracksJSONBody
func (a *ReorderOrReplacePlaylistsTracksJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReorderOrReplacePlaylistsTracksJSONBody to handle AdditionalProperties
func (a *ReorderOrReplacePlaylistsTracksJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["insert_before"]; found {
		err = json.Unmarshal(raw, &a.InsertBefore)
		if err != nil {
			return fmt.Errorf("error reading 'insert_before': %w", err)
		}
		delete(object, "insert_before")
	}

	if raw, found := object["range_length"]; found {
		err = json.Unmarshal(raw, &a.RangeLength)
		if err != nil {
			return fmt.Errorf("error reading 'range_length': %w", err)
		}
		delete(object, "range_length")
	}

	if raw, found := object["range_start"]; found {
		err = json.Unmarshal(raw, &a.RangeStart)
		if err != nil {
			return fmt.Errorf("error reading 'range_start': %w", err)
		}
		delete(object, "range_start")
	}

	if raw, found := object["snapshot_id"]; found {
		err = json.Unmarshal(raw, &a.SnapshotId)
		if err != nil {
			return fmt.Errorf("error reading 'snapshot_id': %w", err)
		}
		delete(object, "snapshot_id")
	}

	if raw, found := object["uris"]; found {
		err = json.Unmarshal(raw, &a.Uris)
		if err != nil {
			return fmt.Errorf("error reading 'uris': %w", err)
		}
		delete(object, "uris")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReorderOrReplacePlaylistsTracksJSONBody to handle AdditionalProperties
func (a ReorderOrReplacePlaylistsTracksJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.InsertBefore != nil {
		object["insert_before"], err = json.Marshal(a.InsertBefore)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'insert_before': %w", err)
		}
	}

	if a.RangeLength != nil {
		object["range_length"], err = json.Marshal(a.RangeLength)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range_length': %w", err)
		}
	}

	if a.RangeStart != nil {
		object["range_start"], err = json.Marshal(a.RangeStart)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range_start': %w", err)
		}
	}

	if a.SnapshotId != nil {
		object["snapshot_id"], err = json.Marshal(a.SnapshotId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snapshot_id': %w", err)
		}
	}

	if a.Uris != nil {
		object["uris"], err = json.Marshal(a.Uris)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uris': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreatePlaylistJSONBody. Returns the specified
// element and whether it was found
func (a CreatePlaylistJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreatePlaylistJSONBody
func (a *CreatePlaylistJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreatePlaylistJSONBody to handle AdditionalProperties
func (a *CreatePlaylistJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["collaborative"]; found {
		err = json.Unmarshal(raw, &a.Collaborative)
		if err != nil {
			return fmt.Errorf("error reading 'collaborative': %w", err)
		}
		delete(object, "collaborative")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["public"]; found {
		err = json.Unmarshal(raw, &a.Public)
		if err != nil {
			return fmt.Errorf("error reading 'public': %w", err)
		}
		delete(object, "public")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreatePlaylistJSONBody to handle AdditionalProperties
func (a CreatePlaylistJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Collaborative != nil {
		object["collaborative"], err = json.Marshal(a.Collaborative)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'collaborative': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Public != nil {
		object["public"], err = json.Marshal(a.Public)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'public': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsTrackObject returns the union data inside the CurrentlyPlayingContextObject_Item as a TrackObject
func (t CurrentlyPlayingContextObject_Item) AsTrackObject() (TrackObject, error) {
	var body TrackObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrackObject overwrites any union data inside the CurrentlyPlayingContextObject_Item as the provided TrackObject
func (t *CurrentlyPlayingContextObject_Item) FromTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrackObject performs a merge with any union data inside the CurrentlyPlayingContextObject_Item, using the provided TrackObject
func (t *CurrentlyPlayingContextObject_Item) MergeTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeObject returns the union data inside the CurrentlyPlayingContextObject_Item as a EpisodeObject
func (t CurrentlyPlayingContextObject_Item) AsEpisodeObject() (EpisodeObject, error) {
	var body EpisodeObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeObject overwrites any union data inside the CurrentlyPlayingContextObject_Item as the provided EpisodeObject
func (t *CurrentlyPlayingContextObject_Item) FromEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeObject performs a merge with any union data inside the CurrentlyPlayingContextObject_Item, using the provided EpisodeObject
func (t *CurrentlyPlayingContextObject_Item) MergeEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CurrentlyPlayingContextObject_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CurrentlyPlayingContextObject_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrackObject returns the union data inside the PlaylistTrackObject_Track as a TrackObject
func (t PlaylistTrackObject_Track) AsTrackObject() (TrackObject, error) {
	var body TrackObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrackObject overwrites any union data inside the PlaylistTrackObject_Track as the provided TrackObject
func (t *PlaylistTrackObject_Track) FromTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrackObject performs a merge with any union data inside the PlaylistTrackObject_Track, using the provided TrackObject
func (t *PlaylistTrackObject_Track) MergeTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeObject returns the union data inside the PlaylistTrackObject_Track as a EpisodeObject
func (t PlaylistTrackObject_Track) AsEpisodeObject() (EpisodeObject, error) {
	var body EpisodeObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeObject overwrites any union data inside the PlaylistTrackObject_Track as the provided EpisodeObject
func (t *PlaylistTrackObject_Track) FromEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeObject performs a merge with any union data inside the PlaylistTrackObject_Track, using the provided EpisodeObject
func (t *PlaylistTrackObject_Track) MergeEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlaylistTrackObject_Track) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlaylistTrackObject_Track) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrackObject returns the union data inside the QueueObject_CurrentlyPlaying as a TrackObject
func (t QueueObject_CurrentlyPlaying) AsTrackObject() (TrackObject, error) {
	var body TrackObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrackObject overwrites any union data inside the QueueObject_CurrentlyPlaying as the provided TrackObject
func (t *QueueObject_CurrentlyPlaying) FromTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrackObject performs a merge with any union data inside the QueueObject_CurrentlyPlaying, using the provided TrackObject
func (t *QueueObject_CurrentlyPlaying) MergeTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeObject returns the union data inside the QueueObject_CurrentlyPlaying as a EpisodeObject
func (t QueueObject_CurrentlyPlaying) AsEpisodeObject() (EpisodeObject, error) {
	var body EpisodeObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeObject overwrites any union data inside the QueueObject_CurrentlyPlaying as the provided EpisodeObject
func (t *QueueObject_CurrentlyPlaying) FromEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeObject performs a merge with any union data inside the QueueObject_CurrentlyPlaying, using the provided EpisodeObject
func (t *QueueObject_CurrentlyPlaying) MergeEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QueueObject_CurrentlyPlaying) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QueueObject_CurrentlyPlaying) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrackObject returns the union data inside the QueueObject_Queue_Item as a TrackObject
func (t QueueObject_Queue_Item) AsTrackObject() (TrackObject, error) {
	var body TrackObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrackObject overwrites any union data inside the QueueObject_Queue_Item as the provided TrackObject
func (t *QueueObject_Queue_Item) FromTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrackObject performs a merge with any union data inside the QueueObject_Queue_Item, using the provided TrackObject
func (t *QueueObject_Queue_Item) MergeTrackObject(v TrackObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeObject returns the union data inside the QueueObject_Queue_Item as a EpisodeObject
func (t QueueObject_Queue_Item) AsEpisodeObject() (EpisodeObject, error) {
	var body EpisodeObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeObject overwrites any union data inside the QueueObject_Queue_Item as the provided EpisodeObject
func (t *QueueObject_Queue_Item) FromEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeObject performs a merge with any union data inside the QueueObject_Queue_Item, using the provided EpisodeObject
func (t *QueueObject_Queue_Item) MergeEpisodeObject(v EpisodeObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QueueObject_Queue_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QueueObject_Queue_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetMultipleAlbums request
	GetMultipleAlbums(ctx context.Context, params *GetMultipleAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnAlbum request
	GetAnAlbum(ctx context.Context, id PathAlbumId, params *GetAnAlbumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnAlbumsTracks request
	GetAnAlbumsTracks(ctx context.Context, id PathAlbumId, params *GetAnAlbumsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleArtists request
	GetMultipleArtists(ctx context.Context, params *GetMultipleArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnArtist request
	GetAnArtist(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnArtistsAlbums request
	GetAnArtistsAlbums(ctx context.Context, id PathArtistId, params *GetAnArtistsAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnArtistsRelatedArtists request
	GetAnArtistsRelatedArtists(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnArtistsTopTracks request
	GetAnArtistsTopTracks(ctx context.Context, id PathArtistId, params *GetAnArtistsTopTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioAnalysis request
	GetAudioAnalysis(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeveralAudioFeatures request
	GetSeveralAudioFeatures(ctx context.Context, params *GetSeveralAudioFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioFeatures request
	GetAudioFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleAudiobooks request
	GetMultipleAudiobooks(ctx context.Context, params *GetMultipleAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnAudiobook request
	GetAnAudiobook(ctx context.Context, id PathAudiobookId, params *GetAnAudiobookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudiobookChapters request
	GetAudiobookChapters(ctx context.Context, id PathAudiobookId, params *GetAudiobookChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategories request
	GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACategory request
	GetACategory(ctx context.Context, categoryId string, params *GetACategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACategoriesPlaylists request
	GetACategoriesPlaylists(ctx context.Context, categoryId string, params *GetACategoriesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeaturedPlaylists request
	GetFeaturedPlaylists(ctx context.Context, params *GetFeaturedPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNewReleases request
	GetNewReleases(ctx context.Context, params *GetNewReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeveralChapters request
	GetSeveralChapters(ctx context.Context, params *GetSeveralChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAChapter request
	GetAChapter(ctx context.Context, id PathChapterId, params *GetAChapterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleEpisodes request
	GetMultipleEpisodes(ctx context.Context, params *GetMultipleEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnEpisode request
	GetAnEpisode(ctx context.Context, id string, params *GetAnEpisodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableMarkets request
	GetAvailableMarkets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUsersProfile request
	GetCurrentUsersProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAlbumsUserWithBody request with any body
	RemoveAlbumsUserWithBody(ctx context.Context, params *RemoveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveAlbumsUser(ctx context.Context, params *RemoveAlbumsUserParams, body RemoveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSavedAlbums request
	GetUsersSavedAlbums(ctx context.Context, params *GetUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveAlbumsUserWithBody request with any body
	SaveAlbumsUserWithBody(ctx context.Context, params *SaveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveAlbumsUser(ctx context.Context, params *SaveAlbumsUserParams, body SaveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUsersSavedAlbums request
	CheckUsersSavedAlbums(ctx context.Context, params *CheckUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAudiobooksUser request
	RemoveAudiobooksUser(ctx context.Context, params *RemoveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSavedAudiobooks request
	GetUsersSavedAudiobooks(ctx context.Context, params *GetUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveAudiobooksUser request
	SaveAudiobooksUser(ctx context.Context, params *SaveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUsersSavedAudiobooks request
	CheckUsersSavedAudiobooks(ctx context.Context, params *CheckUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveEpisodesUserWithBody request with any body
	RemoveEpisodesUserWithBody(ctx context.Context, params *RemoveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveEpisodesUser(ctx context.Context, params *RemoveEpisodesUserParams, body RemoveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSavedEpisodes request
	GetUsersSavedEpisodes(ctx context.Context, params *GetUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveEpisodesUserWithBody request with any body
	SaveEpisodesUserWithBody(ctx context.Context, params *SaveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveEpisodesUser(ctx context.Context, params *SaveEpisodesUserParams, body SaveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUsersSavedEpisodes request
	CheckUsersSavedEpisodes(ctx context.Context, params *CheckUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnfollowArtistsUsersWithBody request with any body
	UnfollowArtistsUsersWithBody(ctx context.Context, params *UnfollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnfollowArtistsUsers(ctx context.Context, params *UnfollowArtistsUsersParams, body UnfollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowed request
	GetFollowed(ctx context.Context, params *GetFollowedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FollowArtistsUsersWithBody request with any body
	FollowArtistsUsersWithBody(ctx context.Context, params *FollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FollowArtistsUsers(ctx context.Context, params *FollowArtistsUsersParams, body FollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckCurrentUserFollows request
	CheckCurrentUserFollows(ctx context.Context, params *CheckCurrentUserFollowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInformationAboutTheUsersCurrentPlayback request
	GetInformationAboutTheUsersCurrentPlayback(ctx context.Context, params *GetInformationAboutTheUsersCurrentPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferAUsersPlaybackWithBody request with any body
	TransferAUsersPlaybackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferAUsersPlayback(ctx context.Context, body TransferAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTheUsersCurrentlyPlayingTrack request
	GetTheUsersCurrentlyPlayingTrack(ctx context.Context, params *GetTheUsersCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAUsersAvailableDevices request
	GetAUsersAvailableDevices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipUsersPlaybackToNextTrack request
	SkipUsersPlaybackToNextTrack(ctx context.Context, params *SkipUsersPlaybackToNextTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseAUsersPlayback request
	PauseAUsersPlayback(ctx context.Context, params *PauseAUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAUsersPlaybackWithBody request with any body
	StartAUsersPlaybackWithBody(ctx context.Context, params *StartAUsersPlaybackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartAUsersPlayback(ctx context.Context, params *StartAUsersPlaybackParams, body StartAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SkipUsersPlaybackToPreviousTrack request
	SkipUsersPlaybackToPreviousTrack(ctx context.Context, params *SkipUsersPlaybackToPreviousTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueue request
	GetQueue(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddToQueue request
	AddToQueue(ctx context.Context, params *AddToQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentlyPlayed request
	GetRecentlyPlayed(ctx context.Context, params *GetRecentlyPlayedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepeatModeOnUsersPlayback request
	SetRepeatModeOnUsersPlayback(ctx context.Context, params *SetRepeatModeOnUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SeekToPositionInCurrentlyPlayingTrack request
	SeekToPositionInCurrentlyPlayingTrack(ctx context.Context, params *SeekToPositionInCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleShuffleForUsersPlayback request
	ToggleShuffleForUsersPlayback(ctx context.Context, params *ToggleShuffleForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVolumeForUsersPlayback request
	SetVolumeForUsersPlayback(ctx context.Context, params *SetVolumeForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAListOfCurrentUsersPlaylists request
	GetAListOfCurrentUsersPlaylists(ctx context.Context, params *GetAListOfCurrentUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveShowsUser request
	RemoveShowsUser(ctx context.Context, params *RemoveShowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSavedShows request
	GetUsersSavedShows(ctx context.Context, params *GetUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveShowsUser request
	SaveShowsUser(ctx context.Context, params *SaveShowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUsersSavedShows request
	CheckUsersSavedShows(ctx context.Context, params *CheckUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersTopArtistsAndTracks request
	GetUsersTopArtistsAndTracks(ctx context.Context, pType GetUsersTopArtistsAndTracksParamsType, params *GetUsersTopArtistsAndTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTracksUserWithBody request with any body
	RemoveTracksUserWithBody(ctx context.Context, params *RemoveTracksUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTracksUser(ctx context.Context, params *RemoveTracksUserParams, body RemoveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSavedTracks request
	GetUsersSavedTracks(ctx context.Context, params *GetUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveTracksUserWithBody request with any body
	SaveTracksUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveTracksUser(ctx context.Context, body SaveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUsersSavedTracks request
	CheckUsersSavedTracks(ctx context.Context, params *CheckUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylist request
	GetPlaylist(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePlaylistDetailsWithBody request with any body
	ChangePlaylistDetailsWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePlaylistDetails(ctx context.Context, playlistId PathPlaylistId, body ChangePlaylistDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnfollowPlaylist request
	UnfollowPlaylist(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FollowPlaylistWithBody request with any body
	FollowPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FollowPlaylist(ctx context.Context, playlistId PathPlaylistId, body FollowPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckIfUserFollowsPlaylist request
	CheckIfUserFollowsPlaylist(ctx context.Context, playlistId PathPlaylistId, params *CheckIfUserFollowsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistCover request
	GetPlaylistCover(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCustomPlaylistCoverWithBody request with any body
	UploadCustomPlaylistCoverWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTracksPlaylistWithBody request with any body
	RemoveTracksPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTracksPlaylist(ctx context.Context, playlistId PathPlaylistId, body RemoveTracksPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistsTracks request
	GetPlaylistsTracks(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTracksToPlaylistWithBody request with any body
	AddTracksToPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTracksToPlaylist(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, body AddTracksToPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReorderOrReplacePlaylistsTracksWithBody request with any body
	ReorderOrReplacePlaylistsTracksWithBody(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReorderOrReplacePlaylistsTracks(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, body ReorderOrReplacePlaylistsTracksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecommendations request
	GetRecommendations(ctx context.Context, params *GetRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecommendationGenres request
	GetRecommendationGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleShows request
	GetMultipleShows(ctx context.Context, params *GetMultipleShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAShow request
	GetAShow(ctx context.Context, id PathShowId, params *GetAShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAShowsEpisodes request
	GetAShowsEpisodes(ctx context.Context, id PathShowId, params *GetAShowsEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeveralTracks request
	GetSeveralTracks(ctx context.Context, params *GetSeveralTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrack request
	GetTrack(ctx context.Context, id string, params *GetTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersProfile request
	GetUsersProfile(ctx context.Context, userId PathUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListUsersPlaylists request
	GetListUsersPlaylists(ctx context.Context, userId PathUserId, params *GetListUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaylistWithBody request with any body
	CreatePlaylistWithBody(ctx context.Context, userId PathUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaylist(ctx context.Context, userId PathUserId, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetMultipleAlbums(ctx context.Context, params *GetMultipleAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleAlbumsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnAlbum(ctx context.Context, id PathAlbumId, params *GetAnAlbumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnAlbumRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnAlbumsTracks(ctx context.Context, id PathAlbumId, params *GetAnAlbumsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnAlbumsTracksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleArtists(ctx context.Context, params *GetMultipleArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleArtistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnArtist(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnArtistRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnArtistsAlbums(ctx context.Context, id PathArtistId, params *GetAnArtistsAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnArtistsAlbumsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnArtistsRelatedArtists(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnArtistsRelatedArtistsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnArtistsTopTracks(ctx context.Context, id PathArtistId, params *GetAnArtistsTopTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnArtistsTopTracksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioAnalysis(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioAnalysisRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeveralAudioFeatures(ctx context.Context, params *GetSeveralAudioFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeveralAudioFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioFeatures(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioFeaturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleAudiobooks(ctx context.Context, params *GetMultipleAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleAudiobooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnAudiobook(ctx context.Context, id PathAudiobookId, params *GetAnAudiobookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnAudiobookRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudiobookChapters(ctx context.Context, id PathAudiobookId, params *GetAudiobookChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudiobookChaptersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACategory(ctx context.Context, categoryId string, params *GetACategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACategoryRequest(c.Server, categoryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACategoriesPlaylists(ctx context.Context, categoryId string, params *GetACategoriesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACategoriesPlaylistsRequest(c.Server, categoryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeaturedPlaylists(ctx context.Context, params *GetFeaturedPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeaturedPlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNewReleases(ctx context.Context, params *GetNewReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNewReleasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeveralChapters(ctx context.Context, params *GetSeveralChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeveralChaptersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAChapter(ctx context.Context, id PathChapterId, params *GetAChapterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAChapterRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleEpisodes(ctx context.Context, params *GetMultipleEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnEpisode(ctx context.Context, id string, params *GetAnEpisodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnEpisodeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableMarkets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableMarketsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUsersProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUsersProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAlbumsUserWithBody(ctx context.Context, params *RemoveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAlbumsUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAlbumsUser(ctx context.Context, params *RemoveAlbumsUserParams, body RemoveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAlbumsUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSavedAlbums(ctx context.Context, params *GetUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSavedAlbumsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAlbumsUserWithBody(ctx context.Context, params *SaveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAlbumsUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAlbumsUser(ctx context.Context, params *SaveAlbumsUserParams, body SaveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAlbumsUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUsersSavedAlbums(ctx context.Context, params *CheckUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUsersSavedAlbumsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAudiobooksUser(ctx context.Context, params *RemoveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAudiobooksUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSavedAudiobooks(ctx context.Context, params *GetUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSavedAudiobooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveAudiobooksUser(ctx context.Context, params *SaveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveAudiobooksUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUsersSavedAudiobooks(ctx context.Context, params *CheckUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUsersSavedAudiobooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveEpisodesUserWithBody(ctx context.Context, params *RemoveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveEpisodesUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveEpisodesUser(ctx context.Context, params *RemoveEpisodesUserParams, body RemoveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveEpisodesUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSavedEpisodes(ctx context.Context, params *GetUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSavedEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveEpisodesUserWithBody(ctx context.Context, params *SaveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveEpisodesUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveEpisodesUser(ctx context.Context, params *SaveEpisodesUserParams, body SaveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveEpisodesUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUsersSavedEpisodes(ctx context.Context, params *CheckUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUsersSavedEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnfollowArtistsUsersWithBody(ctx context.Context, params *UnfollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowArtistsUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnfollowArtistsUsers(ctx context.Context, params *UnfollowArtistsUsersParams, body UnfollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowArtistsUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowed(ctx context.Context, params *GetFollowedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowArtistsUsersWithBody(ctx context.Context, params *FollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowArtistsUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowArtistsUsers(ctx context.Context, params *FollowArtistsUsersParams, body FollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowArtistsUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckCurrentUserFollows(ctx context.Context, params *CheckCurrentUserFollowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckCurrentUserFollowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInformationAboutTheUsersCurrentPlayback(ctx context.Context, params *GetInformationAboutTheUsersCurrentPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInformationAboutTheUsersCurrentPlaybackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferAUsersPlaybackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferAUsersPlaybackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferAUsersPlayback(ctx context.Context, body TransferAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferAUsersPlaybackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTheUsersCurrentlyPlayingTrack(ctx context.Context, params *GetTheUsersCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTheUsersCurrentlyPlayingTrackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAUsersAvailableDevices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAUsersAvailableDevicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipUsersPlaybackToNextTrack(ctx context.Context, params *SkipUsersPlaybackToNextTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipUsersPlaybackToNextTrackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseAUsersPlayback(ctx context.Context, params *PauseAUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseAUsersPlaybackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAUsersPlaybackWithBody(ctx context.Context, params *StartAUsersPlaybackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAUsersPlaybackRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAUsersPlayback(ctx context.Context, params *StartAUsersPlaybackParams, body StartAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAUsersPlaybackRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SkipUsersPlaybackToPreviousTrack(ctx context.Context, params *SkipUsersPlaybackToPreviousTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSkipUsersPlaybackToPreviousTrackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueue(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueueRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddToQueue(ctx context.Context, params *AddToQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToQueueRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentlyPlayed(ctx context.Context, params *GetRecentlyPlayedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentlyPlayedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepeatModeOnUsersPlayback(ctx context.Context, params *SetRepeatModeOnUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepeatModeOnUsersPlaybackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SeekToPositionInCurrentlyPlayingTrack(ctx context.Context, params *SeekToPositionInCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSeekToPositionInCurrentlyPlayingTrackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleShuffleForUsersPlayback(ctx context.Context, params *ToggleShuffleForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleShuffleForUsersPlaybackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVolumeForUsersPlayback(ctx context.Context, params *SetVolumeForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVolumeForUsersPlaybackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAListOfCurrentUsersPlaylists(ctx context.Context, params *GetAListOfCurrentUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAListOfCurrentUsersPlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveShowsUser(ctx context.Context, params *RemoveShowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveShowsUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSavedShows(ctx context.Context, params *GetUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSavedShowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveShowsUser(ctx context.Context, params *SaveShowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveShowsUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUsersSavedShows(ctx context.Context, params *CheckUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUsersSavedShowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersTopArtistsAndTracks(ctx context.Context, pType GetUsersTopArtistsAndTracksParamsType, params *GetUsersTopArtistsAndTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersTopArtistsAndTracksRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTracksUserWithBody(ctx context.Context, params *RemoveTracksUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTracksUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTracksUser(ctx context.Context, params *RemoveTracksUserParams, body RemoveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTracksUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSavedTracks(ctx context.Context, params *GetUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSavedTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTracksUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTracksUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTracksUser(ctx context.Context, body SaveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTracksUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUsersSavedTracks(ctx context.Context, params *CheckUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUsersSavedTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylist(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePlaylistDetailsWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePlaylistDetailsRequestWithBody(c.Server, playlistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePlaylistDetails(ctx context.Context, playlistId PathPlaylistId, body ChangePlaylistDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePlaylistDetailsRequest(c.Server, playlistId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnfollowPlaylist(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowPlaylistRequest(c.Server, playlistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowPlaylistRequestWithBody(c.Server, playlistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowPlaylist(ctx context.Context, playlistId PathPlaylistId, body FollowPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowPlaylistRequest(c.Server, playlistId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckIfUserFollowsPlaylist(ctx context.Context, playlistId PathPlaylistId, params *CheckIfUserFollowsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckIfUserFollowsPlaylistRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistCover(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistCoverRequest(c.Server, playlistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCustomPlaylistCoverWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCustomPlaylistCoverRequestWithBody(c.Server, playlistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTracksPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTracksPlaylistRequestWithBody(c.Server, playlistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTracksPlaylist(ctx context.Context, playlistId PathPlaylistId, body RemoveTracksPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTracksPlaylistRequest(c.Server, playlistId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistsTracks(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistsTracksRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTracksToPlaylistWithBody(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTracksToPlaylistRequestWithBody(c.Server, playlistId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTracksToPlaylist(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, body AddTracksToPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTracksToPlaylistRequest(c.Server, playlistId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReorderOrReplacePlaylistsTracksWithBody(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReorderOrReplacePlaylistsTracksRequestWithBody(c.Server, playlistId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReorderOrReplacePlaylistsTracks(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, body ReorderOrReplacePlaylistsTracksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReorderOrReplacePlaylistsTracksRequest(c.Server, playlistId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecommendations(ctx context.Context, params *GetRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecommendationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecommendationGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecommendationGenresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleShows(ctx context.Context, params *GetMultipleShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleShowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAShow(ctx context.Context, id PathShowId, params *GetAShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAShowsEpisodes(ctx context.Context, id PathShowId, params *GetAShowsEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAShowsEpisodesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeveralTracks(ctx context.Context, params *GetSeveralTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeveralTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrack(ctx context.Context, id string, params *GetTrackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrackRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersProfile(ctx context.Context, userId PathUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersProfileRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListUsersPlaylists(ctx context.Context, userId PathUserId, params *GetListUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListUsersPlaylistsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylistWithBody(ctx context.Context, userId PathUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylist(ctx context.Context, userId PathUserId, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetMultipleAlbumsRequest generates requests for GetMultipleAlbums
func NewGetMultipleAlbumsRequest(server string, params *GetMultipleAlbumsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/albums")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnAlbumRequest generates requests for GetAnAlbum
func NewGetAnAlbumRequest(server string, id PathAlbumId, params *GetAnAlbumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/albums/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnAlbumsTracksRequest generates requests for GetAnAlbumsTracks
func NewGetAnAlbumsTracksRequest(server string, id PathAlbumId, params *GetAnAlbumsTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/albums/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMultipleArtistsRequest generates requests for GetMultipleArtists
func NewGetMultipleArtistsRequest(server string, params *GetMultipleArtistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnArtistRequest generates requests for GetAnArtist
func NewGetAnArtistRequest(server string, id PathArtistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnArtistsAlbumsRequest generates requests for GetAnArtistsAlbums
func NewGetAnArtistsAlbumsRequest(server string, id PathArtistId, params *GetAnArtistsAlbumsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artists/%s/albums", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_groups", runtime.ParamLocationQuery, *params.IncludeGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnArtistsRelatedArtistsRequest generates requests for GetAnArtistsRelatedArtists
func NewGetAnArtistsRelatedArtistsRequest(server string, id PathArtistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artists/%s/related-artists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnArtistsTopTracksRequest generates requests for GetAnArtistsTopTracks
func NewGetAnArtistsTopTracksRequest(server string, id PathArtistId, params *GetAnArtistsTopTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artists/%s/top-tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioAnalysisRequest generates requests for GetAudioAnalysis
func NewGetAudioAnalysisRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio-analysis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeveralAudioFeaturesRequest generates requests for GetSeveralAudioFeatures
func NewGetSeveralAudioFeaturesRequest(server string, params *GetSeveralAudioFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio-features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioFeaturesRequest generates requests for GetAudioFeatures
func NewGetAudioFeaturesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio-features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMultipleAudiobooksRequest generates requests for GetMultipleAudiobooks
func NewGetMultipleAudiobooksRequest(server string, params *GetMultipleAudiobooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audiobooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnAudiobookRequest generates requests for GetAnAudiobook
func NewGetAnAudiobookRequest(server string, id PathAudiobookId, params *GetAnAudiobookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audiobooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudiobookChaptersRequest generates requests for GetAudiobookChapters
func NewGetAudiobookChaptersRequest(server string, id PathAudiobookId, params *GetAudiobookChaptersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audiobooks/%s/chapters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesRequest generates requests for GetCategories
func NewGetCategoriesRequest(server string, params *GetCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/browse/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetACategoryRequest generates requests for GetACategory
func NewGetACategoryRequest(server string, categoryId string, params *GetACategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/browse/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetACategoriesPlaylistsRequest generates requests for GetACategoriesPlaylists
func NewGetACategoriesPlaylistsRequest(server string, categoryId string, params *GetACategoriesPlaylistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/browse/categories/%s/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeaturedPlaylistsRequest generates requests for GetFeaturedPlaylists
func NewGetFeaturedPlaylistsRequest(server string, params *GetFeaturedPlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/browse/featured-playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNewReleasesRequest generates requests for GetNewReleases
func NewGetNewReleasesRequest(server string, params *GetNewReleasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/browse/new-releases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeveralChaptersRequest generates requests for GetSeveralChapters
func NewGetSeveralChaptersRequest(server string, params *GetSeveralChaptersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAChapterRequest generates requests for GetAChapter
func NewGetAChapterRequest(server string, id PathChapterId, params *GetAChapterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMultipleEpisodesRequest generates requests for GetMultipleEpisodes
func NewGetMultipleEpisodesRequest(server string, params *GetMultipleEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnEpisodeRequest generates requests for GetAnEpisode
func NewGetAnEpisodeRequest(server string, id string, params *GetAnEpisodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailableMarketsRequest generates requests for GetAvailableMarkets
func NewGetAvailableMarketsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUsersProfileRequest generates requests for GetCurrentUsersProfile
func NewGetCurrentUsersProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAlbumsUserRequest calls the generic RemoveAlbumsUser builder with application/json body
func NewRemoveAlbumsUserRequest(server string, params *RemoveAlbumsUserParams, body RemoveAlbumsUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveAlbumsUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRemoveAlbumsUserRequestWithBody generates requests for RemoveAlbumsUser with any type of body
func NewRemoveAlbumsUserRequestWithBody(server string, params *RemoveAlbumsUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/albums")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersSavedAlbumsRequest generates requests for GetUsersSavedAlbums
func NewGetUsersSavedAlbumsRequest(server string, params *GetUsersSavedAlbumsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/albums")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveAlbumsUserRequest calls the generic SaveAlbumsUser builder with application/json body
func NewSaveAlbumsUserRequest(server string, params *SaveAlbumsUserParams, body SaveAlbumsUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveAlbumsUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSaveAlbumsUserRequestWithBody generates requests for SaveAlbumsUser with any type of body
func NewSaveAlbumsUserRequestWithBody(server string, params *SaveAlbumsUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/albums")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckUsersSavedAlbumsRequest generates requests for CheckUsersSavedAlbums
func NewCheckUsersSavedAlbumsRequest(server string, params *CheckUsersSavedAlbumsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/albums/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveAudiobooksUserRequest generates requests for RemoveAudiobooksUser
func NewRemoveAudiobooksUserRequest(server string, params *RemoveAudiobooksUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/audiobooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersSavedAudiobooksRequest generates requests for GetUsersSavedAudiobooks
func NewGetUsersSavedAudiobooksRequest(server string, params *GetUsersSavedAudiobooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/audiobooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveAudiobooksUserRequest generates requests for SaveAudiobooksUser
func NewSaveAudiobooksUserRequest(server string, params *SaveAudiobooksUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/audiobooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckUsersSavedAudiobooksRequest generates requests for CheckUsersSavedAudiobooks
func NewCheckUsersSavedAudiobooksRequest(server string, params *CheckUsersSavedAudiobooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/audiobooks/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveEpisodesUserRequest calls the generic RemoveEpisodesUser builder with application/json body
func NewRemoveEpisodesUserRequest(server string, params *RemoveEpisodesUserParams, body RemoveEpisodesUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveEpisodesUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRemoveEpisodesUserRequestWithBody generates requests for RemoveEpisodesUser with any type of body
func NewRemoveEpisodesUserRequestWithBody(server string, params *RemoveEpisodesUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersSavedEpisodesRequest generates requests for GetUsersSavedEpisodes
func NewGetUsersSavedEpisodesRequest(server string, params *GetUsersSavedEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveEpisodesUserRequest calls the generic SaveEpisodesUser builder with application/json body
func NewSaveEpisodesUserRequest(server string, params *SaveEpisodesUserParams, body SaveEpisodesUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveEpisodesUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSaveEpisodesUserRequestWithBody generates requests for SaveEpisodesUser with any type of body
func NewSaveEpisodesUserRequestWithBody(server string, params *SaveEpisodesUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckUsersSavedEpisodesRequest generates requests for CheckUsersSavedEpisodes
func NewCheckUsersSavedEpisodesRequest(server string, params *CheckUsersSavedEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/episodes/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnfollowArtistsUsersRequest calls the generic UnfollowArtistsUsers builder with application/json body
func NewUnfollowArtistsUsersRequest(server string, params *UnfollowArtistsUsersParams, body UnfollowArtistsUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnfollowArtistsUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUnfollowArtistsUsersRequestWithBody generates requests for UnfollowArtistsUsers with any type of body
func NewUnfollowArtistsUsersRequestWithBody(server string, params *UnfollowArtistsUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/following")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFollowedRequest generates requests for GetFollowed
func NewGetFollowedRequest(server string, params *GetFollowedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/following")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFollowArtistsUsersRequest calls the generic FollowArtistsUsers builder with application/json body
func NewFollowArtistsUsersRequest(server string, params *FollowArtistsUsersParams, body FollowArtistsUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFollowArtistsUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFollowArtistsUsersRequestWithBody generates requests for FollowArtistsUsers with any type of body
func NewFollowArtistsUsersRequestWithBody(server string, params *FollowArtistsUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/following")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckCurrentUserFollowsRequest generates requests for CheckCurrentUserFollows
func NewCheckCurrentUserFollowsRequest(server string, params *CheckCurrentUserFollowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/following/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInformationAboutTheUsersCurrentPlaybackRequest generates requests for GetInformationAboutTheUsersCurrentPlayback
func NewGetInformationAboutTheUsersCurrentPlaybackRequest(server string, params *GetInformationAboutTheUsersCurrentPlaybackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional_types", runtime.ParamLocationQuery, *params.AdditionalTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferAUsersPlaybackRequest calls the generic TransferAUsersPlayback builder with application/json body
func NewTransferAUsersPlaybackRequest(server string, body TransferAUsersPlaybackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransferAUsersPlaybackRequestWithBody(server, "application/json", bodyReader)
}

// NewTransferAUsersPlaybackRequestWithBody generates requests for TransferAUsersPlayback with any type of body
func NewTransferAUsersPlaybackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTheUsersCurrentlyPlayingTrackRequest generates requests for GetTheUsersCurrentlyPlayingTrack
func NewGetTheUsersCurrentlyPlayingTrackRequest(server string, params *GetTheUsersCurrentlyPlayingTrackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/currently-playing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional_types", runtime.ParamLocationQuery, *params.AdditionalTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAUsersAvailableDevicesRequest generates requests for GetAUsersAvailableDevices
func NewGetAUsersAvailableDevicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSkipUsersPlaybackToNextTrackRequest generates requests for SkipUsersPlaybackToNextTrack
func NewSkipUsersPlaybackToNextTrackRequest(server string, params *SkipUsersPlaybackToNextTrackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/next")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseAUsersPlaybackRequest generates requests for PauseAUsersPlayback
func NewPauseAUsersPlaybackRequest(server string, params *PauseAUsersPlaybackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/pause")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartAUsersPlaybackRequest calls the generic StartAUsersPlayback builder with application/json body
func NewStartAUsersPlaybackRequest(server string, params *StartAUsersPlaybackParams, body StartAUsersPlaybackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartAUsersPlaybackRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStartAUsersPlaybackRequestWithBody generates requests for StartAUsersPlayback with any type of body
func NewStartAUsersPlaybackRequestWithBody(server string, params *StartAUsersPlaybackParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/play")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSkipUsersPlaybackToPreviousTrackRequest generates requests for SkipUsersPlaybackToPreviousTrack
func NewSkipUsersPlaybackToPreviousTrackRequest(server string, params *SkipUsersPlaybackToPreviousTrackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/previous")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueueRequest generates requests for GetQueue
func NewGetQueueRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/queue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddToQueueRequest generates requests for AddToQueue
func NewAddToQueueRequest(server string, params *AddToQueueParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/queue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri", runtime.ParamLocationQuery, params.Uri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentlyPlayedRequest generates requests for GetRecentlyPlayed
func NewGetRecentlyPlayedRequest(server string, params *GetRecentlyPlayedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/recently-played")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepeatModeOnUsersPlaybackRequest generates requests for SetRepeatModeOnUsersPlayback
func NewSetRepeatModeOnUsersPlaybackRequest(server string, params *SetRepeatModeOnUsersPlaybackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/repeat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSeekToPositionInCurrentlyPlayingTrackRequest generates requests for SeekToPositionInCurrentlyPlayingTrack
func NewSeekToPositionInCurrentlyPlayingTrackRequest(server string, params *SeekToPositionInCurrentlyPlayingTrackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/seek")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position_ms", runtime.ParamLocationQuery, params.PositionMs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleShuffleForUsersPlaybackRequest generates requests for ToggleShuffleForUsersPlayback
func NewToggleShuffleForUsersPlaybackRequest(server string, params *ToggleShuffleForUsersPlaybackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/shuffle")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVolumeForUsersPlaybackRequest generates requests for SetVolumeForUsersPlayback
func NewSetVolumeForUsersPlaybackRequest(server string, params *SetVolumeForUsersPlaybackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/player/volume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume_percent", runtime.ParamLocationQuery, params.VolumePercent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "device_id", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAListOfCurrentUsersPlaylistsRequest generates requests for GetAListOfCurrentUsersPlaylists
func NewGetAListOfCurrentUsersPlaylistsRequest(server string, params *GetAListOfCurrentUsersPlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveShowsUserRequest generates requests for RemoveShowsUser
func NewRemoveShowsUserRequest(server string, params *RemoveShowsUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/shows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersSavedShowsRequest generates requests for GetUsersSavedShows
func NewGetUsersSavedShowsRequest(server string, params *GetUsersSavedShowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/shows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveShowsUserRequest generates requests for SaveShowsUser
func NewSaveShowsUserRequest(server string, params *SaveShowsUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/shows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckUsersSavedShowsRequest generates requests for CheckUsersSavedShows
func NewCheckUsersSavedShowsRequest(server string, params *CheckUsersSavedShowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/shows/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersTopArtistsAndTracksRequest generates requests for GetUsersTopArtistsAndTracks
func NewGetUsersTopArtistsAndTracksRequest(server string, pType GetUsersTopArtistsAndTracksParamsType, params *GetUsersTopArtistsAndTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/top/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeRange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range", runtime.ParamLocationQuery, *params.TimeRange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTracksUserRequest calls the generic RemoveTracksUser builder with application/json body
func NewRemoveTracksUserRequest(server string, params *RemoveTracksUserParams, body RemoveTracksUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTracksUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRemoveTracksUserRequestWithBody generates requests for RemoveTracksUser with any type of body
func NewRemoveTracksUserRequestWithBody(server string, params *RemoveTracksUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersSavedTracksRequest generates requests for GetUsersSavedTracks
func NewGetUsersSavedTracksRequest(server string, params *GetUsersSavedTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveTracksUserRequest calls the generic SaveTracksUser builder with application/json body
func NewSaveTracksUserRequest(server string, body SaveTracksUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveTracksUserRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveTracksUserRequestWithBody generates requests for SaveTracksUser with any type of body
func NewSaveTracksUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckUsersSavedTracksRequest generates requests for CheckUsersSavedTracks
func NewCheckUsersSavedTracksRequest(server string, params *CheckUsersSavedTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/tracks/contains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaylistRequest generates requests for GetPlaylist
func NewGetPlaylistRequest(server string, playlistId PathPlaylistId, params *GetPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional_types", runtime.ParamLocationQuery, *params.AdditionalTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePlaylistDetailsRequest calls the generic ChangePlaylistDetails builder with application/json body
func NewChangePlaylistDetailsRequest(server string, playlistId PathPlaylistId, body ChangePlaylistDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePlaylistDetailsRequestWithBody(server, playlistId, "application/json", bodyReader)
}

// NewChangePlaylistDetailsRequestWithBody generates requests for ChangePlaylistDetails with any type of body
func NewChangePlaylistDetailsRequestWithBody(server string, playlistId PathPlaylistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnfollowPlaylistRequest generates requests for UnfollowPlaylist
func NewUnfollowPlaylistRequest(server string, playlistId PathPlaylistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFollowPlaylistRequest calls the generic FollowPlaylist builder with application/json body
func NewFollowPlaylistRequest(server string, playlistId PathPlaylistId, body FollowPlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFollowPlaylistRequestWithBody(server, playlistId, "application/json", bodyReader)
}

// NewFollowPlaylistRequestWithBody generates requests for FollowPlaylist with any type of body
func NewFollowPlaylistRequestWithBody(server string, playlistId PathPlaylistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckIfUserFollowsPlaylistRequest generates requests for CheckIfUserFollowsPlaylist
func NewCheckIfUserFollowsPlaylistRequest(server string, playlistId PathPlaylistId, params *CheckIfUserFollowsPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/followers/contains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaylistCoverRequest generates requests for GetPlaylistCover
func NewGetPlaylistCoverRequest(server string, playlistId PathPlaylistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCustomPlaylistCoverRequestWithBody generates requests for UploadCustomPlaylistCover with any type of body
func NewUploadCustomPlaylistCoverRequestWithBody(server string, playlistId PathPlaylistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTracksPlaylistRequest calls the generic RemoveTracksPlaylist builder with application/json body
func NewRemoveTracksPlaylistRequest(server string, playlistId PathPlaylistId, body RemoveTracksPlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTracksPlaylistRequestWithBody(server, playlistId, "application/json", bodyReader)
}

// NewRemoveTracksPlaylistRequestWithBody generates requests for RemoveTracksPlaylist with any type of body
func NewRemoveTracksPlaylistRequestWithBody(server string, playlistId PathPlaylistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlaylistsTracksRequest generates requests for GetPlaylistsTracks
func NewGetPlaylistsTracksRequest(server string, playlistId PathPlaylistId, params *GetPlaylistsTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional_types", runtime.ParamLocationQuery, *params.AdditionalTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTracksToPlaylistRequest calls the generic AddTracksToPlaylist builder with application/json body
func NewAddTracksToPlaylistRequest(server string, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, body AddTracksToPlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTracksToPlaylistRequestWithBody(server, playlistId, params, "application/json", bodyReader)
}

// NewAddTracksToPlaylistRequestWithBody generates requests for AddTracksToPlaylist with any type of body
func NewAddTracksToPlaylistRequestWithBody(server string, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Position != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "position", runtime.ParamLocationQuery, *params.Position); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uris != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uris", runtime.ParamLocationQuery, *params.Uris); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReorderOrReplacePlaylistsTracksRequest calls the generic ReorderOrReplacePlaylistsTracks builder with application/json body
func NewReorderOrReplacePlaylistsTracksRequest(server string, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, body ReorderOrReplacePlaylistsTracksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReorderOrReplacePlaylistsTracksRequestWithBody(server, playlistId, params, "application/json", bodyReader)
}

// NewReorderOrReplacePlaylistsTracksRequestWithBody generates requests for ReorderOrReplacePlaylistsTracks with any type of body
func NewReorderOrReplacePlaylistsTracksRequestWithBody(server string, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_id", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Uris != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uris", runtime.ParamLocationQuery, *params.Uris); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecommendationsRequest generates requests for GetRecommendations
func NewGetRecommendationsRequest(server string, params *GetRecommendationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seed_artists", runtime.ParamLocationQuery, params.SeedArtists); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seed_genres", runtime.ParamLocationQuery, params.SeedGenres); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seed_tracks", runtime.ParamLocationQuery, params.SeedTracks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MinAcousticness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_acousticness", runtime.ParamLocationQuery, *params.MinAcousticness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAcousticness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_acousticness", runtime.ParamLocationQuery, *params.MaxAcousticness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetAcousticness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_acousticness", runtime.ParamLocationQuery, *params.TargetAcousticness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDanceability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_danceability", runtime.ParamLocationQuery, *params.MinDanceability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxDanceability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_danceability", runtime.ParamLocationQuery, *params.MaxDanceability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetDanceability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_danceability", runtime.ParamLocationQuery, *params.TargetDanceability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDurationMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_duration_ms", runtime.ParamLocationQuery, *params.MinDurationMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxDurationMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_duration_ms", runtime.ParamLocationQuery, *params.MaxDurationMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetDurationMs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_duration_ms", runtime.ParamLocationQuery, *params.TargetDurationMs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinEnergy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_energy", runtime.ParamLocationQuery, *params.MinEnergy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxEnergy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_energy", runtime.ParamLocationQuery, *params.MaxEnergy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetEnergy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_energy", runtime.ParamLocationQuery, *params.TargetEnergy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinInstrumentalness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_instrumentalness", runtime.ParamLocationQuery, *params.MinInstrumentalness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxInstrumentalness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_instrumentalness", runtime.ParamLocationQuery, *params.MaxInstrumentalness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetInstrumentalness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_instrumentalness", runtime.ParamLocationQuery, *params.TargetInstrumentalness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_key", runtime.ParamLocationQuery, *params.MinKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_key", runtime.ParamLocationQuery, *params.MaxKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_key", runtime.ParamLocationQuery, *params.TargetKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinLiveness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_liveness", runtime.ParamLocationQuery, *params.MinLiveness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxLiveness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_liveness", runtime.ParamLocationQuery, *params.MaxLiveness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetLiveness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_liveness", runtime.ParamLocationQuery, *params.TargetLiveness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinLoudness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_loudness", runtime.ParamLocationQuery, *params.MinLoudness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxLoudness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_loudness", runtime.ParamLocationQuery, *params.MaxLoudness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetLoudness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_loudness", runtime.ParamLocationQuery, *params.TargetLoudness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_mode", runtime.ParamLocationQuery, *params.MinMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_mode", runtime.ParamLocationQuery, *params.MaxMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_mode", runtime.ParamLocationQuery, *params.TargetMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPopularity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_popularity", runtime.ParamLocationQuery, *params.MinPopularity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPopularity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_popularity", runtime.ParamLocationQuery, *params.MaxPopularity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetPopularity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_popularity", runtime.ParamLocationQuery, *params.TargetPopularity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSpeechiness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_speechiness", runtime.ParamLocationQuery, *params.MinSpeechiness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxSpeechiness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_speechiness", runtime.ParamLocationQuery, *params.MaxSpeechiness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetSpeechiness != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_speechiness", runtime.ParamLocationQuery, *params.TargetSpeechiness); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTempo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_tempo", runtime.ParamLocationQuery, *params.MinTempo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTempo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_tempo", runtime.ParamLocationQuery, *params.MaxTempo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTempo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_tempo", runtime.ParamLocationQuery, *params.TargetTempo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTimeSignature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_time_signature", runtime.ParamLocationQuery, *params.MinTimeSignature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxTimeSignature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_time_signature", runtime.ParamLocationQuery, *params.MaxTimeSignature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTimeSignature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_time_signature", runtime.ParamLocationQuery, *params.TargetTimeSignature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinValence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_valence", runtime.ParamLocationQuery, *params.MinValence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxValence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_valence", runtime.ParamLocationQuery, *params.MaxValence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetValence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_valence", runtime.ParamLocationQuery, *params.TargetValence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecommendationGenresRequest generates requests for GetRecommendationGenres
func NewGetRecommendationGenresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/available-genre-seeds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExternal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_external", runtime.ParamLocationQuery, *params.IncludeExternal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMultipleShowsRequest generates requests for GetMultipleShows
func NewGetMultipleShowsRequest(server string, params *GetMultipleShowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAShowRequest generates requests for GetAShow
func NewGetAShowRequest(server string, id PathShowId, params *GetAShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAShowsEpisodesRequest generates requests for GetAShowsEpisodes
func NewGetAShowsEpisodesRequest(server string, id PathShowId, params *GetAShowsEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shows/%s/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeveralTracksRequest generates requests for GetSeveralTracks
func NewGetSeveralTracksRequest(server string, params *GetSeveralTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTrackRequest generates requests for GetTrack
func NewGetTrackRequest(server string, id string, params *GetTrackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Market != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market", runtime.ParamLocationQuery, *params.Market); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersProfileRequest generates requests for GetUsersProfile
func NewGetUsersProfileRequest(server string, userId PathUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListUsersPlaylistsRequest generates requests for GetListUsersPlaylists
func NewGetListUsersPlaylistsRequest(server string, userId PathUserId, params *GetListUsersPlaylistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlaylistRequest calls the generic CreatePlaylist builder with application/json body
func NewCreatePlaylistRequest(server string, userId PathUserId, body CreatePlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaylistRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewCreatePlaylistRequestWithBody generates requests for CreatePlaylist with any type of body
func NewCreatePlaylistRequestWithBody(server string, userId PathUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetMultipleAlbumsWithResponse request
	GetMultipleAlbumsWithResponse(ctx context.Context, params *GetMultipleAlbumsParams, reqEditors ...RequestEditorFn) (*GetMultipleAlbumsResponse, error)

	// GetAnAlbumWithResponse request
	GetAnAlbumWithResponse(ctx context.Context, id PathAlbumId, params *GetAnAlbumParams, reqEditors ...RequestEditorFn) (*GetAnAlbumResponse, error)

	// GetAnAlbumsTracksWithResponse request
	GetAnAlbumsTracksWithResponse(ctx context.Context, id PathAlbumId, params *GetAnAlbumsTracksParams, reqEditors ...RequestEditorFn) (*GetAnAlbumsTracksResponse, error)

	// GetMultipleArtistsWithResponse request
	GetMultipleArtistsWithResponse(ctx context.Context, params *GetMultipleArtistsParams, reqEditors ...RequestEditorFn) (*GetMultipleArtistsResponse, error)

	// GetAnArtistWithResponse request
	GetAnArtistWithResponse(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*GetAnArtistResponse, error)

	// GetAnArtistsAlbumsWithResponse request
	GetAnArtistsAlbumsWithResponse(ctx context.Context, id PathArtistId, params *GetAnArtistsAlbumsParams, reqEditors ...RequestEditorFn) (*GetAnArtistsAlbumsResponse, error)

	// GetAnArtistsRelatedArtistsWithResponse request
	GetAnArtistsRelatedArtistsWithResponse(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*GetAnArtistsRelatedArtistsResponse, error)

	// GetAnArtistsTopTracksWithResponse request
	GetAnArtistsTopTracksWithResponse(ctx context.Context, id PathArtistId, params *GetAnArtistsTopTracksParams, reqEditors ...RequestEditorFn) (*GetAnArtistsTopTracksResponse, error)

	// GetAudioAnalysisWithResponse request
	GetAudioAnalysisWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAudioAnalysisResponse, error)

	// GetSeveralAudioFeaturesWithResponse request
	GetSeveralAudioFeaturesWithResponse(ctx context.Context, params *GetSeveralAudioFeaturesParams, reqEditors ...RequestEditorFn) (*GetSeveralAudioFeaturesResponse, error)

	// GetAudioFeaturesWithResponse request
	GetAudioFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAudioFeaturesResponse, error)

	// GetMultipleAudiobooksWithResponse request
	GetMultipleAudiobooksWithResponse(ctx context.Context, params *GetMultipleAudiobooksParams, reqEditors ...RequestEditorFn) (*GetMultipleAudiobooksResponse, error)

	// GetAnAudiobookWithResponse request
	GetAnAudiobookWithResponse(ctx context.Context, id PathAudiobookId, params *GetAnAudiobookParams, reqEditors ...RequestEditorFn) (*GetAnAudiobookResponse, error)

	// GetAudiobookChaptersWithResponse request
	GetAudiobookChaptersWithResponse(ctx context.Context, id PathAudiobookId, params *GetAudiobookChaptersParams, reqEditors ...RequestEditorFn) (*GetAudiobookChaptersResponse, error)

	// GetCategoriesWithResponse request
	GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error)

	// GetACategoryWithResponse request
	GetACategoryWithResponse(ctx context.Context, categoryId string, params *GetACategoryParams, reqEditors ...RequestEditorFn) (*GetACategoryResponse, error)

	// GetACategoriesPlaylistsWithResponse request
	GetACategoriesPlaylistsWithResponse(ctx context.Context, categoryId string, params *GetACategoriesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetACategoriesPlaylistsResponse, error)

	// GetFeaturedPlaylistsWithResponse request
	GetFeaturedPlaylistsWithResponse(ctx context.Context, params *GetFeaturedPlaylistsParams, reqEditors ...RequestEditorFn) (*GetFeaturedPlaylistsResponse, error)

	// GetNewReleasesWithResponse request
	GetNewReleasesWithResponse(ctx context.Context, params *GetNewReleasesParams, reqEditors ...RequestEditorFn) (*GetNewReleasesResponse, error)

	// GetSeveralChaptersWithResponse request
	GetSeveralChaptersWithResponse(ctx context.Context, params *GetSeveralChaptersParams, reqEditors ...RequestEditorFn) (*GetSeveralChaptersResponse, error)

	// GetAChapterWithResponse request
	GetAChapterWithResponse(ctx context.Context, id PathChapterId, params *GetAChapterParams, reqEditors ...RequestEditorFn) (*GetAChapterResponse, error)

	// GetMultipleEpisodesWithResponse request
	GetMultipleEpisodesWithResponse(ctx context.Context, params *GetMultipleEpisodesParams, reqEditors ...RequestEditorFn) (*GetMultipleEpisodesResponse, error)

	// GetAnEpisodeWithResponse request
	GetAnEpisodeWithResponse(ctx context.Context, id string, params *GetAnEpisodeParams, reqEditors ...RequestEditorFn) (*GetAnEpisodeResponse, error)

	// GetAvailableMarketsWithResponse request
	GetAvailableMarketsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableMarketsResponse, error)

	// GetCurrentUsersProfileWithResponse request
	GetCurrentUsersProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUsersProfileResponse, error)

	// RemoveAlbumsUserWithBodyWithResponse request with any body
	RemoveAlbumsUserWithBodyWithResponse(ctx context.Context, params *RemoveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveAlbumsUserResponse, error)

	RemoveAlbumsUserWithResponse(ctx context.Context, params *RemoveAlbumsUserParams, body RemoveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveAlbumsUserResponse, error)

	// GetUsersSavedAlbumsWithResponse request
	GetUsersSavedAlbumsWithResponse(ctx context.Context, params *GetUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*GetUsersSavedAlbumsResponse, error)

	// SaveAlbumsUserWithBodyWithResponse request with any body
	SaveAlbumsUserWithBodyWithResponse(ctx context.Context, params *SaveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveAlbumsUserResponse, error)

	SaveAlbumsUserWithResponse(ctx context.Context, params *SaveAlbumsUserParams, body SaveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveAlbumsUserResponse, error)

	// CheckUsersSavedAlbumsWithResponse request
	CheckUsersSavedAlbumsWithResponse(ctx context.Context, params *CheckUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedAlbumsResponse, error)

	// RemoveAudiobooksUserWithResponse request
	RemoveAudiobooksUserWithResponse(ctx context.Context, params *RemoveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*RemoveAudiobooksUserResponse, error)

	// GetUsersSavedAudiobooksWithResponse request
	GetUsersSavedAudiobooksWithResponse(ctx context.Context, params *GetUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*GetUsersSavedAudiobooksResponse, error)

	// SaveAudiobooksUserWithResponse request
	SaveAudiobooksUserWithResponse(ctx context.Context, params *SaveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*SaveAudiobooksUserResponse, error)

	// CheckUsersSavedAudiobooksWithResponse request
	CheckUsersSavedAudiobooksWithResponse(ctx context.Context, params *CheckUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedAudiobooksResponse, error)

	// RemoveEpisodesUserWithBodyWithResponse request with any body
	RemoveEpisodesUserWithBodyWithResponse(ctx context.Context, params *RemoveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveEpisodesUserResponse, error)

	RemoveEpisodesUserWithResponse(ctx context.Context, params *RemoveEpisodesUserParams, body RemoveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveEpisodesUserResponse, error)

	// GetUsersSavedEpisodesWithResponse request
	GetUsersSavedEpisodesWithResponse(ctx context.Context, params *GetUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*GetUsersSavedEpisodesResponse, error)

	// SaveEpisodesUserWithBodyWithResponse request with any body
	SaveEpisodesUserWithBodyWithResponse(ctx context.Context, params *SaveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveEpisodesUserResponse, error)

	SaveEpisodesUserWithResponse(ctx context.Context, params *SaveEpisodesUserParams, body SaveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveEpisodesUserResponse, error)

	// CheckUsersSavedEpisodesWithResponse request
	CheckUsersSavedEpisodesWithResponse(ctx context.Context, params *CheckUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedEpisodesResponse, error)

	// UnfollowArtistsUsersWithBodyWithResponse request with any body
	UnfollowArtistsUsersWithBodyWithResponse(ctx context.Context, params *UnfollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnfollowArtistsUsersResponse, error)

	UnfollowArtistsUsersWithResponse(ctx context.Context, params *UnfollowArtistsUsersParams, body UnfollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnfollowArtistsUsersResponse, error)

	// GetFollowedWithResponse request
	GetFollowedWithResponse(ctx context.Context, params *GetFollowedParams, reqEditors ...RequestEditorFn) (*GetFollowedResponse, error)

	// FollowArtistsUsersWithBodyWithResponse request with any body
	FollowArtistsUsersWithBodyWithResponse(ctx context.Context, params *FollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowArtistsUsersResponse, error)

	FollowArtistsUsersWithResponse(ctx context.Context, params *FollowArtistsUsersParams, body FollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowArtistsUsersResponse, error)

	// CheckCurrentUserFollowsWithResponse request
	CheckCurrentUserFollowsWithResponse(ctx context.Context, params *CheckCurrentUserFollowsParams, reqEditors ...RequestEditorFn) (*CheckCurrentUserFollowsResponse, error)

	// GetInformationAboutTheUsersCurrentPlaybackWithResponse request
	GetInformationAboutTheUsersCurrentPlaybackWithResponse(ctx context.Context, params *GetInformationAboutTheUsersCurrentPlaybackParams, reqEditors ...RequestEditorFn) (*GetInformationAboutTheUsersCurrentPlaybackResponse, error)

	// TransferAUsersPlaybackWithBodyWithResponse request with any body
	TransferAUsersPlaybackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferAUsersPlaybackResponse, error)

	TransferAUsersPlaybackWithResponse(ctx context.Context, body TransferAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferAUsersPlaybackResponse, error)

	// GetTheUsersCurrentlyPlayingTrackWithResponse request
	GetTheUsersCurrentlyPlayingTrackWithResponse(ctx context.Context, params *GetTheUsersCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*GetTheUsersCurrentlyPlayingTrackResponse, error)

	// GetAUsersAvailableDevicesWithResponse request
	GetAUsersAvailableDevicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAUsersAvailableDevicesResponse, error)

	// SkipUsersPlaybackToNextTrackWithResponse request
	SkipUsersPlaybackToNextTrackWithResponse(ctx context.Context, params *SkipUsersPlaybackToNextTrackParams, reqEditors ...RequestEditorFn) (*SkipUsersPlaybackToNextTrackResponse, error)

	// PauseAUsersPlaybackWithResponse request
	PauseAUsersPlaybackWithResponse(ctx context.Context, params *PauseAUsersPlaybackParams, reqEditors ...RequestEditorFn) (*PauseAUsersPlaybackResponse, error)

	// StartAUsersPlaybackWithBodyWithResponse request with any body
	StartAUsersPlaybackWithBodyWithResponse(ctx context.Context, params *StartAUsersPlaybackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartAUsersPlaybackResponse, error)

	StartAUsersPlaybackWithResponse(ctx context.Context, params *StartAUsersPlaybackParams, body StartAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*StartAUsersPlaybackResponse, error)

	// SkipUsersPlaybackToPreviousTrackWithResponse request
	SkipUsersPlaybackToPreviousTrackWithResponse(ctx context.Context, params *SkipUsersPlaybackToPreviousTrackParams, reqEditors ...RequestEditorFn) (*SkipUsersPlaybackToPreviousTrackResponse, error)

	// GetQueueWithResponse request
	GetQueueWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueueResponse, error)

	// AddToQueueWithResponse request
	AddToQueueWithResponse(ctx context.Context, params *AddToQueueParams, reqEditors ...RequestEditorFn) (*AddToQueueResponse, error)

	// GetRecentlyPlayedWithResponse request
	GetRecentlyPlayedWithResponse(ctx context.Context, params *GetRecentlyPlayedParams, reqEditors ...RequestEditorFn) (*GetRecentlyPlayedResponse, error)

	// SetRepeatModeOnUsersPlaybackWithResponse request
	SetRepeatModeOnUsersPlaybackWithResponse(ctx context.Context, params *SetRepeatModeOnUsersPlaybackParams, reqEditors ...RequestEditorFn) (*SetRepeatModeOnUsersPlaybackResponse, error)

	// SeekToPositionInCurrentlyPlayingTrackWithResponse request
	SeekToPositionInCurrentlyPlayingTrackWithResponse(ctx context.Context, params *SeekToPositionInCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*SeekToPositionInCurrentlyPlayingTrackResponse, error)

	// ToggleShuffleForUsersPlaybackWithResponse request
	ToggleShuffleForUsersPlaybackWithResponse(ctx context.Context, params *ToggleShuffleForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*ToggleShuffleForUsersPlaybackResponse, error)

	// SetVolumeForUsersPlaybackWithResponse request
	SetVolumeForUsersPlaybackWithResponse(ctx context.Context, params *SetVolumeForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*SetVolumeForUsersPlaybackResponse, error)

	// GetAListOfCurrentUsersPlaylistsWithResponse request
	GetAListOfCurrentUsersPlaylistsWithResponse(ctx context.Context, params *GetAListOfCurrentUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*GetAListOfCurrentUsersPlaylistsResponse, error)

	// RemoveShowsUserWithResponse request
	RemoveShowsUserWithResponse(ctx context.Context, params *RemoveShowsUserParams, reqEditors ...RequestEditorFn) (*RemoveShowsUserResponse, error)

	// GetUsersSavedShowsWithResponse request
	GetUsersSavedShowsWithResponse(ctx context.Context, params *GetUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*GetUsersSavedShowsResponse, error)

	// SaveShowsUserWithResponse request
	SaveShowsUserWithResponse(ctx context.Context, params *SaveShowsUserParams, reqEditors ...RequestEditorFn) (*SaveShowsUserResponse, error)

	// CheckUsersSavedShowsWithResponse request
	CheckUsersSavedShowsWithResponse(ctx context.Context, params *CheckUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedShowsResponse, error)

	// GetUsersTopArtistsAndTracksWithResponse request
	GetUsersTopArtistsAndTracksWithResponse(ctx context.Context, pType GetUsersTopArtistsAndTracksParamsType, params *GetUsersTopArtistsAndTracksParams, reqEditors ...RequestEditorFn) (*GetUsersTopArtistsAndTracksResponse, error)

	// RemoveTracksUserWithBodyWithResponse request with any body
	RemoveTracksUserWithBodyWithResponse(ctx context.Context, params *RemoveTracksUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTracksUserResponse, error)

	RemoveTracksUserWithResponse(ctx context.Context, params *RemoveTracksUserParams, body RemoveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTracksUserResponse, error)

	// GetUsersSavedTracksWithResponse request
	GetUsersSavedTracksWithResponse(ctx context.Context, params *GetUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*GetUsersSavedTracksResponse, error)

	// SaveTracksUserWithBodyWithResponse request with any body
	SaveTracksUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveTracksUserResponse, error)

	SaveTracksUserWithResponse(ctx context.Context, body SaveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveTracksUserResponse, error)

	// CheckUsersSavedTracksWithResponse request
	CheckUsersSavedTracksWithResponse(ctx context.Context, params *CheckUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedTracksResponse, error)

	// GetPlaylistWithResponse request
	GetPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistParams, reqEditors ...RequestEditorFn) (*GetPlaylistResponse, error)

	// ChangePlaylistDetailsWithBodyWithResponse request with any body
	ChangePlaylistDetailsWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePlaylistDetailsResponse, error)

	ChangePlaylistDetailsWithResponse(ctx context.Context, playlistId PathPlaylistId, body ChangePlaylistDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePlaylistDetailsResponse, error)

	// UnfollowPlaylistWithResponse request
	UnfollowPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*UnfollowPlaylistResponse, error)

	// FollowPlaylistWithBodyWithResponse request with any body
	FollowPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowPlaylistResponse, error)

	FollowPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, body FollowPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowPlaylistResponse, error)

	// CheckIfUserFollowsPlaylistWithResponse request
	CheckIfUserFollowsPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *CheckIfUserFollowsPlaylistParams, reqEditors ...RequestEditorFn) (*CheckIfUserFollowsPlaylistResponse, error)

	// GetPlaylistCoverWithResponse request
	GetPlaylistCoverWithResponse(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*GetPlaylistCoverResponse, error)

	// UploadCustomPlaylistCoverWithBodyWithResponse request with any body
	UploadCustomPlaylistCoverWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomPlaylistCoverResponse, error)

	// RemoveTracksPlaylistWithBodyWithResponse request with any body
	RemoveTracksPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTracksPlaylistResponse, error)

	RemoveTracksPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, body RemoveTracksPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTracksPlaylistResponse, error)

	// GetPlaylistsTracksWithResponse request
	GetPlaylistsTracksWithResponse(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistsTracksParams, reqEditors ...RequestEditorFn) (*GetPlaylistsTracksResponse, error)

	// AddTracksToPlaylistWithBodyWithResponse request with any body
	AddTracksToPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTracksToPlaylistResponse, error)

	AddTracksToPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, body AddTracksToPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTracksToPlaylistResponse, error)

	// ReorderOrReplacePlaylistsTracksWithBodyWithResponse request with any body
	ReorderOrReplacePlaylistsTracksWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReorderOrReplacePlaylistsTracksResponse, error)

	ReorderOrReplacePlaylistsTracksWithResponse(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, body ReorderOrReplacePlaylistsTracksJSONRequestBody, reqEditors ...RequestEditorFn) (*ReorderOrReplacePlaylistsTracksResponse, error)

	// GetRecommendationsWithResponse request
	GetRecommendationsWithResponse(ctx context.Context, params *GetRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecommendationsResponse, error)

	// GetRecommendationGenresWithResponse request
	GetRecommendationGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecommendationGenresResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// GetMultipleShowsWithResponse request
	GetMultipleShowsWithResponse(ctx context.Context, params *GetMultipleShowsParams, reqEditors ...RequestEditorFn) (*GetMultipleShowsResponse, error)

	// GetAShowWithResponse request
	GetAShowWithResponse(ctx context.Context, id PathShowId, params *GetAShowParams, reqEditors ...RequestEditorFn) (*GetAShowResponse, error)

	// GetAShowsEpisodesWithResponse request
	GetAShowsEpisodesWithResponse(ctx context.Context, id PathShowId, params *GetAShowsEpisodesParams, reqEditors ...RequestEditorFn) (*GetAShowsEpisodesResponse, error)

	// GetSeveralTracksWithResponse request
	GetSeveralTracksWithResponse(ctx context.Context, params *GetSeveralTracksParams, reqEditors ...RequestEditorFn) (*GetSeveralTracksResponse, error)

	// GetTrackWithResponse request
	GetTrackWithResponse(ctx context.Context, id string, params *GetTrackParams, reqEditors ...RequestEditorFn) (*GetTrackResponse, error)

	// GetUsersProfileWithResponse request
	GetUsersProfileWithResponse(ctx context.Context, userId PathUserId, reqEditors ...RequestEditorFn) (*GetUsersProfileResponse, error)

	// GetListUsersPlaylistsWithResponse request
	GetListUsersPlaylistsWithResponse(ctx context.Context, userId PathUserId, params *GetListUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*GetListUsersPlaylistsResponse, error)

	// CreatePlaylistWithBodyWithResponse request with any body
	CreatePlaylistWithBodyWithResponse(ctx context.Context, userId PathUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	CreatePlaylistWithResponse(ctx context.Context, userId PathUserId, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)
}

type GetMultipleAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyAlbums
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetMultipleAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnAlbumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneAlbum
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnAlbumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnAlbumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnAlbumsTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSimplifiedTrackObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnAlbumsTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnAlbumsTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyArtists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetMultipleArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneArtist
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnArtistsAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingArtistDiscographyAlbumObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnArtistsAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnArtistsAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnArtistsRelatedArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyArtists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnArtistsRelatedArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnArtistsRelatedArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnArtistsTopTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyTracks
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnArtistsTopTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnArtistsTopTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneAudioAnalysis
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAudioAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeveralAudioFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyAudioFeatures
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSeveralAudioFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeveralAudioFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneAudioFeatures
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAudioFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleAudiobooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyAudiobooks
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetMultipleAudiobooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleAudiobooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnAudiobookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneAudiobook
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnAudiobookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnAudiobookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudiobookChaptersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSimplifiedChapterObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAudiobookChaptersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudiobookChaptersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedCategories
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneCategory
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetACategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACategoriesPlaylistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedFeaturedPlaylists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetACategoriesPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACategoriesPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeaturedPlaylistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedFeaturedPlaylists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetFeaturedPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeaturedPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNewReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedAlbums
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetNewReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNewReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeveralChaptersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyChapters
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSeveralChaptersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeveralChaptersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAChapterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneChapter
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAChapterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAChapterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyEpisodes
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetMultipleEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnEpisodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneEpisode
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAnEpisodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnEpisodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Markets *[]string `json:"markets,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAvailableMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUsersProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnePrivateUser
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetCurrentUsersProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUsersProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAlbumsUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveAlbumsUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAlbumsUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSavedAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSavedAlbumObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersSavedAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSavedAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveAlbumsUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SaveAlbumsUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveAlbumsUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUsersSavedAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckUsersSavedAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUsersSavedAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAudiobooksUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveAudiobooksUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAudiobooksUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSavedAudiobooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSimplifiedAudiobookObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersSavedAudiobooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSavedAudiobooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveAudiobooksUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SaveAudiobooksUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveAudiobooksUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUsersSavedAudiobooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckUsersSavedAudiobooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUsersSavedAudiobooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveEpisodesUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveEpisodesUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveEpisodesUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSavedEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSavedEpisodeObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersSavedEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSavedEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveEpisodesUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SaveEpisodesUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveEpisodesUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUsersSavedEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckUsersSavedEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUsersSavedEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnfollowArtistsUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r UnfollowArtistsUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnfollowArtistsUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CursorPagedArtists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetFollowedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowArtistsUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r FollowArtistsUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowArtistsUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckCurrentUserFollowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckCurrentUserFollowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckCurrentUserFollowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInformationAboutTheUsersCurrentPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneCurrentlyPlaying
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetInformationAboutTheUsersCurrentPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInformationAboutTheUsersCurrentPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferAUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r TransferAUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferAUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTheUsersCurrentlyPlayingTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneCurrentlyPlayingTrack
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetTheUsersCurrentlyPlayingTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTheUsersCurrentlyPlayingTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAUsersAvailableDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyDevices
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAUsersAvailableDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAUsersAvailableDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipUsersPlaybackToNextTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SkipUsersPlaybackToNextTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipUsersPlaybackToNextTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseAUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r PauseAUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseAUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r StartAUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SkipUsersPlaybackToPreviousTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SkipUsersPlaybackToPreviousTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SkipUsersPlaybackToPreviousTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Queue
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddToQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r AddToQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddToQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentlyPlayedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CursorPagedPlayHistory
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetRecentlyPlayedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentlyPlayedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepeatModeOnUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SetRepeatModeOnUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepeatModeOnUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SeekToPositionInCurrentlyPlayingTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SeekToPositionInCurrentlyPlayingTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SeekToPositionInCurrentlyPlayingTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleShuffleForUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ToggleShuffleForUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleShuffleForUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVolumeForUsersPlaybackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SetVolumeForUsersPlaybackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVolumeForUsersPlaybackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAListOfCurrentUsersPlaylistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedPlaylists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAListOfCurrentUsersPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAListOfCurrentUsersPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveShowsUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveShowsUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveShowsUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSavedShowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSavedShowObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersSavedShowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSavedShowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveShowsUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SaveShowsUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveShowsUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUsersSavedShowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckUsersSavedShowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUsersSavedShowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersTopArtistsAndTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingArtistOrTrackObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersTopArtistsAndTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersTopArtistsAndTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTracksUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveTracksUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTracksUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSavedTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSavedTrackObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersSavedTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSavedTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveTracksUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SaveTracksUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveTracksUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUsersSavedTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfBooleans
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckUsersSavedTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUsersSavedTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnePlaylist
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePlaylistDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ChangePlaylistDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePlaylistDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnfollowPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r UnfollowPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnfollowPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r FollowPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckIfUserFollowsPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SingletonArrayOfBoolean
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CheckIfUserFollowsPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckIfUserFollowsPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfImages
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetPlaylistCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCustomPlaylistCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r UploadCustomPlaylistCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCustomPlaylistCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTracksPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaylistSnapshotId
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r RemoveTracksPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTracksPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistsTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingPlaylistTrackObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetPlaylistsTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistsTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTracksToPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PlaylistSnapshotId
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r AddTracksToPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTracksToPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReorderOrReplacePlaylistsTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaylistSnapshotId
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ReorderOrReplacePlaylistsTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReorderOrReplacePlaylistsTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneRecommendations
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecommendationGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyGenres
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetRecommendationGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecommendationGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchItems
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleShowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManySimplifiedShows
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetMultipleShowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleShowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneShow
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAShowsEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagingSimplifiedEpisodeObject
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetAShowsEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAShowsEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeveralTracksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManyTracks
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSeveralTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeveralTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OneTrack
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnePublicUser
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetUsersProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListUsersPlaylistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedPlaylists
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetListUsersPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListUsersPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OnePlaylist
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r CreatePlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetMultipleAlbumsWithResponse request returning *GetMultipleAlbumsResponse
func (c *ClientWithResponses) GetMultipleAlbumsWithResponse(ctx context.Context, params *GetMultipleAlbumsParams, reqEditors ...RequestEditorFn) (*GetMultipleAlbumsResponse, error) {
	rsp, err := c.GetMultipleAlbums(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleAlbumsResponse(rsp)
}

// GetAnAlbumWithResponse request returning *GetAnAlbumResponse
func (c *ClientWithResponses) GetAnAlbumWithResponse(ctx context.Context, id PathAlbumId, params *GetAnAlbumParams, reqEditors ...RequestEditorFn) (*GetAnAlbumResponse, error) {
	rsp, err := c.GetAnAlbum(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnAlbumResponse(rsp)
}

// GetAnAlbumsTracksWithResponse request returning *GetAnAlbumsTracksResponse
func (c *ClientWithResponses) GetAnAlbumsTracksWithResponse(ctx context.Context, id PathAlbumId, params *GetAnAlbumsTracksParams, reqEditors ...RequestEditorFn) (*GetAnAlbumsTracksResponse, error) {
	rsp, err := c.GetAnAlbumsTracks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnAlbumsTracksResponse(rsp)
}

// GetMultipleArtistsWithResponse request returning *GetMultipleArtistsResponse
func (c *ClientWithResponses) GetMultipleArtistsWithResponse(ctx context.Context, params *GetMultipleArtistsParams, reqEditors ...RequestEditorFn) (*GetMultipleArtistsResponse, error) {
	rsp, err := c.GetMultipleArtists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleArtistsResponse(rsp)
}

// GetAnArtistWithResponse request returning *GetAnArtistResponse
func (c *ClientWithResponses) GetAnArtistWithResponse(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*GetAnArtistResponse, error) {
	rsp, err := c.GetAnArtist(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnArtistResponse(rsp)
}

// GetAnArtistsAlbumsWithResponse request returning *GetAnArtistsAlbumsResponse
func (c *ClientWithResponses) GetAnArtistsAlbumsWithResponse(ctx context.Context, id PathArtistId, params *GetAnArtistsAlbumsParams, reqEditors ...RequestEditorFn) (*GetAnArtistsAlbumsResponse, error) {
	rsp, err := c.GetAnArtistsAlbums(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnArtistsAlbumsResponse(rsp)
}

// GetAnArtistsRelatedArtistsWithResponse request returning *GetAnArtistsRelatedArtistsResponse
func (c *ClientWithResponses) GetAnArtistsRelatedArtistsWithResponse(ctx context.Context, id PathArtistId, reqEditors ...RequestEditorFn) (*GetAnArtistsRelatedArtistsResponse, error) {
	rsp, err := c.GetAnArtistsRelatedArtists(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnArtistsRelatedArtistsResponse(rsp)
}

// GetAnArtistsTopTracksWithResponse request returning *GetAnArtistsTopTracksResponse
func (c *ClientWithResponses) GetAnArtistsTopTracksWithResponse(ctx context.Context, id PathArtistId, params *GetAnArtistsTopTracksParams, reqEditors ...RequestEditorFn) (*GetAnArtistsTopTracksResponse, error) {
	rsp, err := c.GetAnArtistsTopTracks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnArtistsTopTracksResponse(rsp)
}

// GetAudioAnalysisWithResponse request returning *GetAudioAnalysisResponse
func (c *ClientWithResponses) GetAudioAnalysisWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAudioAnalysisResponse, error) {
	rsp, err := c.GetAudioAnalysis(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioAnalysisResponse(rsp)
}

// GetSeveralAudioFeaturesWithResponse request returning *GetSeveralAudioFeaturesResponse
func (c *ClientWithResponses) GetSeveralAudioFeaturesWithResponse(ctx context.Context, params *GetSeveralAudioFeaturesParams, reqEditors ...RequestEditorFn) (*GetSeveralAudioFeaturesResponse, error) {
	rsp, err := c.GetSeveralAudioFeatures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeveralAudioFeaturesResponse(rsp)
}

// GetAudioFeaturesWithResponse request returning *GetAudioFeaturesResponse
func (c *ClientWithResponses) GetAudioFeaturesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAudioFeaturesResponse, error) {
	rsp, err := c.GetAudioFeatures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioFeaturesResponse(rsp)
}

// GetMultipleAudiobooksWithResponse request returning *GetMultipleAudiobooksResponse
func (c *ClientWithResponses) GetMultipleAudiobooksWithResponse(ctx context.Context, params *GetMultipleAudiobooksParams, reqEditors ...RequestEditorFn) (*GetMultipleAudiobooksResponse, error) {
	rsp, err := c.GetMultipleAudiobooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleAudiobooksResponse(rsp)
}

// GetAnAudiobookWithResponse request returning *GetAnAudiobookResponse
func (c *ClientWithResponses) GetAnAudiobookWithResponse(ctx context.Context, id PathAudiobookId, params *GetAnAudiobookParams, reqEditors ...RequestEditorFn) (*GetAnAudiobookResponse, error) {
	rsp, err := c.GetAnAudiobook(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnAudiobookResponse(rsp)
}

// GetAudiobookChaptersWithResponse request returning *GetAudiobookChaptersResponse
func (c *ClientWithResponses) GetAudiobookChaptersWithResponse(ctx context.Context, id PathAudiobookId, params *GetAudiobookChaptersParams, reqEditors ...RequestEditorFn) (*GetAudiobookChaptersResponse, error) {
	rsp, err := c.GetAudiobookChapters(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudiobookChaptersResponse(rsp)
}

// GetCategoriesWithResponse request returning *GetCategoriesResponse
func (c *ClientWithResponses) GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error) {
	rsp, err := c.GetCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesResponse(rsp)
}

// GetACategoryWithResponse request returning *GetACategoryResponse
func (c *ClientWithResponses) GetACategoryWithResponse(ctx context.Context, categoryId string, params *GetACategoryParams, reqEditors ...RequestEditorFn) (*GetACategoryResponse, error) {
	rsp, err := c.GetACategory(ctx, categoryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACategoryResponse(rsp)
}

// GetACategoriesPlaylistsWithResponse request returning *GetACategoriesPlaylistsResponse
func (c *ClientWithResponses) GetACategoriesPlaylistsWithResponse(ctx context.Context, categoryId string, params *GetACategoriesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetACategoriesPlaylistsResponse, error) {
	rsp, err := c.GetACategoriesPlaylists(ctx, categoryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACategoriesPlaylistsResponse(rsp)
}

// GetFeaturedPlaylistsWithResponse request returning *GetFeaturedPlaylistsResponse
func (c *ClientWithResponses) GetFeaturedPlaylistsWithResponse(ctx context.Context, params *GetFeaturedPlaylistsParams, reqEditors ...RequestEditorFn) (*GetFeaturedPlaylistsResponse, error) {
	rsp, err := c.GetFeaturedPlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeaturedPlaylistsResponse(rsp)
}

// GetNewReleasesWithResponse request returning *GetNewReleasesResponse
func (c *ClientWithResponses) GetNewReleasesWithResponse(ctx context.Context, params *GetNewReleasesParams, reqEditors ...RequestEditorFn) (*GetNewReleasesResponse, error) {
	rsp, err := c.GetNewReleases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNewReleasesResponse(rsp)
}

// GetSeveralChaptersWithResponse request returning *GetSeveralChaptersResponse
func (c *ClientWithResponses) GetSeveralChaptersWithResponse(ctx context.Context, params *GetSeveralChaptersParams, reqEditors ...RequestEditorFn) (*GetSeveralChaptersResponse, error) {
	rsp, err := c.GetSeveralChapters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeveralChaptersResponse(rsp)
}

// GetAChapterWithResponse request returning *GetAChapterResponse
func (c *ClientWithResponses) GetAChapterWithResponse(ctx context.Context, id PathChapterId, params *GetAChapterParams, reqEditors ...RequestEditorFn) (*GetAChapterResponse, error) {
	rsp, err := c.GetAChapter(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAChapterResponse(rsp)
}

// GetMultipleEpisodesWithResponse request returning *GetMultipleEpisodesResponse
func (c *ClientWithResponses) GetMultipleEpisodesWithResponse(ctx context.Context, params *GetMultipleEpisodesParams, reqEditors ...RequestEditorFn) (*GetMultipleEpisodesResponse, error) {
	rsp, err := c.GetMultipleEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleEpisodesResponse(rsp)
}

// GetAnEpisodeWithResponse request returning *GetAnEpisodeResponse
func (c *ClientWithResponses) GetAnEpisodeWithResponse(ctx context.Context, id string, params *GetAnEpisodeParams, reqEditors ...RequestEditorFn) (*GetAnEpisodeResponse, error) {
	rsp, err := c.GetAnEpisode(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnEpisodeResponse(rsp)
}

// GetAvailableMarketsWithResponse request returning *GetAvailableMarketsResponse
func (c *ClientWithResponses) GetAvailableMarketsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableMarketsResponse, error) {
	rsp, err := c.GetAvailableMarkets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableMarketsResponse(rsp)
}

// GetCurrentUsersProfileWithResponse request returning *GetCurrentUsersProfileResponse
func (c *ClientWithResponses) GetCurrentUsersProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUsersProfileResponse, error) {
	rsp, err := c.GetCurrentUsersProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUsersProfileResponse(rsp)
}

// RemoveAlbumsUserWithBodyWithResponse request with arbitrary body returning *RemoveAlbumsUserResponse
func (c *ClientWithResponses) RemoveAlbumsUserWithBodyWithResponse(ctx context.Context, params *RemoveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveAlbumsUserResponse, error) {
	rsp, err := c.RemoveAlbumsUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAlbumsUserResponse(rsp)
}

func (c *ClientWithResponses) RemoveAlbumsUserWithResponse(ctx context.Context, params *RemoveAlbumsUserParams, body RemoveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveAlbumsUserResponse, error) {
	rsp, err := c.RemoveAlbumsUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAlbumsUserResponse(rsp)
}

// GetUsersSavedAlbumsWithResponse request returning *GetUsersSavedAlbumsResponse
func (c *ClientWithResponses) GetUsersSavedAlbumsWithResponse(ctx context.Context, params *GetUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*GetUsersSavedAlbumsResponse, error) {
	rsp, err := c.GetUsersSavedAlbums(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSavedAlbumsResponse(rsp)
}

// SaveAlbumsUserWithBodyWithResponse request with arbitrary body returning *SaveAlbumsUserResponse
func (c *ClientWithResponses) SaveAlbumsUserWithBodyWithResponse(ctx context.Context, params *SaveAlbumsUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveAlbumsUserResponse, error) {
	rsp, err := c.SaveAlbumsUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAlbumsUserResponse(rsp)
}

func (c *ClientWithResponses) SaveAlbumsUserWithResponse(ctx context.Context, params *SaveAlbumsUserParams, body SaveAlbumsUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveAlbumsUserResponse, error) {
	rsp, err := c.SaveAlbumsUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAlbumsUserResponse(rsp)
}

// CheckUsersSavedAlbumsWithResponse request returning *CheckUsersSavedAlbumsResponse
func (c *ClientWithResponses) CheckUsersSavedAlbumsWithResponse(ctx context.Context, params *CheckUsersSavedAlbumsParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedAlbumsResponse, error) {
	rsp, err := c.CheckUsersSavedAlbums(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUsersSavedAlbumsResponse(rsp)
}

// RemoveAudiobooksUserWithResponse request returning *RemoveAudiobooksUserResponse
func (c *ClientWithResponses) RemoveAudiobooksUserWithResponse(ctx context.Context, params *RemoveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*RemoveAudiobooksUserResponse, error) {
	rsp, err := c.RemoveAudiobooksUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAudiobooksUserResponse(rsp)
}

// GetUsersSavedAudiobooksWithResponse request returning *GetUsersSavedAudiobooksResponse
func (c *ClientWithResponses) GetUsersSavedAudiobooksWithResponse(ctx context.Context, params *GetUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*GetUsersSavedAudiobooksResponse, error) {
	rsp, err := c.GetUsersSavedAudiobooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSavedAudiobooksResponse(rsp)
}

// SaveAudiobooksUserWithResponse request returning *SaveAudiobooksUserResponse
func (c *ClientWithResponses) SaveAudiobooksUserWithResponse(ctx context.Context, params *SaveAudiobooksUserParams, reqEditors ...RequestEditorFn) (*SaveAudiobooksUserResponse, error) {
	rsp, err := c.SaveAudiobooksUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveAudiobooksUserResponse(rsp)
}

// CheckUsersSavedAudiobooksWithResponse request returning *CheckUsersSavedAudiobooksResponse
func (c *ClientWithResponses) CheckUsersSavedAudiobooksWithResponse(ctx context.Context, params *CheckUsersSavedAudiobooksParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedAudiobooksResponse, error) {
	rsp, err := c.CheckUsersSavedAudiobooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUsersSavedAudiobooksResponse(rsp)
}

// RemoveEpisodesUserWithBodyWithResponse request with arbitrary body returning *RemoveEpisodesUserResponse
func (c *ClientWithResponses) RemoveEpisodesUserWithBodyWithResponse(ctx context.Context, params *RemoveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveEpisodesUserResponse, error) {
	rsp, err := c.RemoveEpisodesUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveEpisodesUserResponse(rsp)
}

func (c *ClientWithResponses) RemoveEpisodesUserWithResponse(ctx context.Context, params *RemoveEpisodesUserParams, body RemoveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveEpisodesUserResponse, error) {
	rsp, err := c.RemoveEpisodesUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveEpisodesUserResponse(rsp)
}

// GetUsersSavedEpisodesWithResponse request returning *GetUsersSavedEpisodesResponse
func (c *ClientWithResponses) GetUsersSavedEpisodesWithResponse(ctx context.Context, params *GetUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*GetUsersSavedEpisodesResponse, error) {
	rsp, err := c.GetUsersSavedEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSavedEpisodesResponse(rsp)
}

// SaveEpisodesUserWithBodyWithResponse request with arbitrary body returning *SaveEpisodesUserResponse
func (c *ClientWithResponses) SaveEpisodesUserWithBodyWithResponse(ctx context.Context, params *SaveEpisodesUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveEpisodesUserResponse, error) {
	rsp, err := c.SaveEpisodesUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveEpisodesUserResponse(rsp)
}

func (c *ClientWithResponses) SaveEpisodesUserWithResponse(ctx context.Context, params *SaveEpisodesUserParams, body SaveEpisodesUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveEpisodesUserResponse, error) {
	rsp, err := c.SaveEpisodesUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveEpisodesUserResponse(rsp)
}

// CheckUsersSavedEpisodesWithResponse request returning *CheckUsersSavedEpisodesResponse
func (c *ClientWithResponses) CheckUsersSavedEpisodesWithResponse(ctx context.Context, params *CheckUsersSavedEpisodesParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedEpisodesResponse, error) {
	rsp, err := c.CheckUsersSavedEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUsersSavedEpisodesResponse(rsp)
}

// UnfollowArtistsUsersWithBodyWithResponse request with arbitrary body returning *UnfollowArtistsUsersResponse
func (c *ClientWithResponses) UnfollowArtistsUsersWithBodyWithResponse(ctx context.Context, params *UnfollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnfollowArtistsUsersResponse, error) {
	rsp, err := c.UnfollowArtistsUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowArtistsUsersResponse(rsp)
}

func (c *ClientWithResponses) UnfollowArtistsUsersWithResponse(ctx context.Context, params *UnfollowArtistsUsersParams, body UnfollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnfollowArtistsUsersResponse, error) {
	rsp, err := c.UnfollowArtistsUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowArtistsUsersResponse(rsp)
}

// GetFollowedWithResponse request returning *GetFollowedResponse
func (c *ClientWithResponses) GetFollowedWithResponse(ctx context.Context, params *GetFollowedParams, reqEditors ...RequestEditorFn) (*GetFollowedResponse, error) {
	rsp, err := c.GetFollowed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFollowedResponse(rsp)
}

// FollowArtistsUsersWithBodyWithResponse request with arbitrary body returning *FollowArtistsUsersResponse
func (c *ClientWithResponses) FollowArtistsUsersWithBodyWithResponse(ctx context.Context, params *FollowArtistsUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowArtistsUsersResponse, error) {
	rsp, err := c.FollowArtistsUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowArtistsUsersResponse(rsp)
}

func (c *ClientWithResponses) FollowArtistsUsersWithResponse(ctx context.Context, params *FollowArtistsUsersParams, body FollowArtistsUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowArtistsUsersResponse, error) {
	rsp, err := c.FollowArtistsUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowArtistsUsersResponse(rsp)
}

// CheckCurrentUserFollowsWithResponse request returning *CheckCurrentUserFollowsResponse
func (c *ClientWithResponses) CheckCurrentUserFollowsWithResponse(ctx context.Context, params *CheckCurrentUserFollowsParams, reqEditors ...RequestEditorFn) (*CheckCurrentUserFollowsResponse, error) {
	rsp, err := c.CheckCurrentUserFollows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckCurrentUserFollowsResponse(rsp)
}

// GetInformationAboutTheUsersCurrentPlaybackWithResponse request returning *GetInformationAboutTheUsersCurrentPlaybackResponse
func (c *ClientWithResponses) GetInformationAboutTheUsersCurrentPlaybackWithResponse(ctx context.Context, params *GetInformationAboutTheUsersCurrentPlaybackParams, reqEditors ...RequestEditorFn) (*GetInformationAboutTheUsersCurrentPlaybackResponse, error) {
	rsp, err := c.GetInformationAboutTheUsersCurrentPlayback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInformationAboutTheUsersCurrentPlaybackResponse(rsp)
}

// TransferAUsersPlaybackWithBodyWithResponse request with arbitrary body returning *TransferAUsersPlaybackResponse
func (c *ClientWithResponses) TransferAUsersPlaybackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferAUsersPlaybackResponse, error) {
	rsp, err := c.TransferAUsersPlaybackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferAUsersPlaybackResponse(rsp)
}

func (c *ClientWithResponses) TransferAUsersPlaybackWithResponse(ctx context.Context, body TransferAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferAUsersPlaybackResponse, error) {
	rsp, err := c.TransferAUsersPlayback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferAUsersPlaybackResponse(rsp)
}

// GetTheUsersCurrentlyPlayingTrackWithResponse request returning *GetTheUsersCurrentlyPlayingTrackResponse
func (c *ClientWithResponses) GetTheUsersCurrentlyPlayingTrackWithResponse(ctx context.Context, params *GetTheUsersCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*GetTheUsersCurrentlyPlayingTrackResponse, error) {
	rsp, err := c.GetTheUsersCurrentlyPlayingTrack(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTheUsersCurrentlyPlayingTrackResponse(rsp)
}

// GetAUsersAvailableDevicesWithResponse request returning *GetAUsersAvailableDevicesResponse
func (c *ClientWithResponses) GetAUsersAvailableDevicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAUsersAvailableDevicesResponse, error) {
	rsp, err := c.GetAUsersAvailableDevices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAUsersAvailableDevicesResponse(rsp)
}

// SkipUsersPlaybackToNextTrackWithResponse request returning *SkipUsersPlaybackToNextTrackResponse
func (c *ClientWithResponses) SkipUsersPlaybackToNextTrackWithResponse(ctx context.Context, params *SkipUsersPlaybackToNextTrackParams, reqEditors ...RequestEditorFn) (*SkipUsersPlaybackToNextTrackResponse, error) {
	rsp, err := c.SkipUsersPlaybackToNextTrack(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipUsersPlaybackToNextTrackResponse(rsp)
}

// PauseAUsersPlaybackWithResponse request returning *PauseAUsersPlaybackResponse
func (c *ClientWithResponses) PauseAUsersPlaybackWithResponse(ctx context.Context, params *PauseAUsersPlaybackParams, reqEditors ...RequestEditorFn) (*PauseAUsersPlaybackResponse, error) {
	rsp, err := c.PauseAUsersPlayback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseAUsersPlaybackResponse(rsp)
}

// StartAUsersPlaybackWithBodyWithResponse request with arbitrary body returning *StartAUsersPlaybackResponse
func (c *ClientWithResponses) StartAUsersPlaybackWithBodyWithResponse(ctx context.Context, params *StartAUsersPlaybackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartAUsersPlaybackResponse, error) {
	rsp, err := c.StartAUsersPlaybackWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAUsersPlaybackResponse(rsp)
}

func (c *ClientWithResponses) StartAUsersPlaybackWithResponse(ctx context.Context, params *StartAUsersPlaybackParams, body StartAUsersPlaybackJSONRequestBody, reqEditors ...RequestEditorFn) (*StartAUsersPlaybackResponse, error) {
	rsp, err := c.StartAUsersPlayback(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAUsersPlaybackResponse(rsp)
}

// SkipUsersPlaybackToPreviousTrackWithResponse request returning *SkipUsersPlaybackToPreviousTrackResponse
func (c *ClientWithResponses) SkipUsersPlaybackToPreviousTrackWithResponse(ctx context.Context, params *SkipUsersPlaybackToPreviousTrackParams, reqEditors ...RequestEditorFn) (*SkipUsersPlaybackToPreviousTrackResponse, error) {
	rsp, err := c.SkipUsersPlaybackToPreviousTrack(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSkipUsersPlaybackToPreviousTrackResponse(rsp)
}

// GetQueueWithResponse request returning *GetQueueResponse
func (c *ClientWithResponses) GetQueueWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueueResponse, error) {
	rsp, err := c.GetQueue(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueueResponse(rsp)
}

// AddToQueueWithResponse request returning *AddToQueueResponse
func (c *ClientWithResponses) AddToQueueWithResponse(ctx context.Context, params *AddToQueueParams, reqEditors ...RequestEditorFn) (*AddToQueueResponse, error) {
	rsp, err := c.AddToQueue(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToQueueResponse(rsp)
}

// GetRecentlyPlayedWithResponse request returning *GetRecentlyPlayedResponse
func (c *ClientWithResponses) GetRecentlyPlayedWithResponse(ctx context.Context, params *GetRecentlyPlayedParams, reqEditors ...RequestEditorFn) (*GetRecentlyPlayedResponse, error) {
	rsp, err := c.GetRecentlyPlayed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentlyPlayedResponse(rsp)
}

// SetRepeatModeOnUsersPlaybackWithResponse request returning *SetRepeatModeOnUsersPlaybackResponse
func (c *ClientWithResponses) SetRepeatModeOnUsersPlaybackWithResponse(ctx context.Context, params *SetRepeatModeOnUsersPlaybackParams, reqEditors ...RequestEditorFn) (*SetRepeatModeOnUsersPlaybackResponse, error) {
	rsp, err := c.SetRepeatModeOnUsersPlayback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepeatModeOnUsersPlaybackResponse(rsp)
}

// SeekToPositionInCurrentlyPlayingTrackWithResponse request returning *SeekToPositionInCurrentlyPlayingTrackResponse
func (c *ClientWithResponses) SeekToPositionInCurrentlyPlayingTrackWithResponse(ctx context.Context, params *SeekToPositionInCurrentlyPlayingTrackParams, reqEditors ...RequestEditorFn) (*SeekToPositionInCurrentlyPlayingTrackResponse, error) {
	rsp, err := c.SeekToPositionInCurrentlyPlayingTrack(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSeekToPositionInCurrentlyPlayingTrackResponse(rsp)
}

// ToggleShuffleForUsersPlaybackWithResponse request returning *ToggleShuffleForUsersPlaybackResponse
func (c *ClientWithResponses) ToggleShuffleForUsersPlaybackWithResponse(ctx context.Context, params *ToggleShuffleForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*ToggleShuffleForUsersPlaybackResponse, error) {
	rsp, err := c.ToggleShuffleForUsersPlayback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleShuffleForUsersPlaybackResponse(rsp)
}

// SetVolumeForUsersPlaybackWithResponse request returning *SetVolumeForUsersPlaybackResponse
func (c *ClientWithResponses) SetVolumeForUsersPlaybackWithResponse(ctx context.Context, params *SetVolumeForUsersPlaybackParams, reqEditors ...RequestEditorFn) (*SetVolumeForUsersPlaybackResponse, error) {
	rsp, err := c.SetVolumeForUsersPlayback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVolumeForUsersPlaybackResponse(rsp)
}

// GetAListOfCurrentUsersPlaylistsWithResponse request returning *GetAListOfCurrentUsersPlaylistsResponse
func (c *ClientWithResponses) GetAListOfCurrentUsersPlaylistsWithResponse(ctx context.Context, params *GetAListOfCurrentUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*GetAListOfCurrentUsersPlaylistsResponse, error) {
	rsp, err := c.GetAListOfCurrentUsersPlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAListOfCurrentUsersPlaylistsResponse(rsp)
}

// RemoveShowsUserWithResponse request returning *RemoveShowsUserResponse
func (c *ClientWithResponses) RemoveShowsUserWithResponse(ctx context.Context, params *RemoveShowsUserParams, reqEditors ...RequestEditorFn) (*RemoveShowsUserResponse, error) {
	rsp, err := c.RemoveShowsUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveShowsUserResponse(rsp)
}

// GetUsersSavedShowsWithResponse request returning *GetUsersSavedShowsResponse
func (c *ClientWithResponses) GetUsersSavedShowsWithResponse(ctx context.Context, params *GetUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*GetUsersSavedShowsResponse, error) {
	rsp, err := c.GetUsersSavedShows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSavedShowsResponse(rsp)
}

// SaveShowsUserWithResponse request returning *SaveShowsUserResponse
func (c *ClientWithResponses) SaveShowsUserWithResponse(ctx context.Context, params *SaveShowsUserParams, reqEditors ...RequestEditorFn) (*SaveShowsUserResponse, error) {
	rsp, err := c.SaveShowsUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveShowsUserResponse(rsp)
}

// CheckUsersSavedShowsWithResponse request returning *CheckUsersSavedShowsResponse
func (c *ClientWithResponses) CheckUsersSavedShowsWithResponse(ctx context.Context, params *CheckUsersSavedShowsParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedShowsResponse, error) {
	rsp, err := c.CheckUsersSavedShows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUsersSavedShowsResponse(rsp)
}

// GetUsersTopArtistsAndTracksWithResponse request returning *GetUsersTopArtistsAndTracksResponse
func (c *ClientWithResponses) GetUsersTopArtistsAndTracksWithResponse(ctx context.Context, pType GetUsersTopArtistsAndTracksParamsType, params *GetUsersTopArtistsAndTracksParams, reqEditors ...RequestEditorFn) (*GetUsersTopArtistsAndTracksResponse, error) {
	rsp, err := c.GetUsersTopArtistsAndTracks(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersTopArtistsAndTracksResponse(rsp)
}

// RemoveTracksUserWithBodyWithResponse request with arbitrary body returning *RemoveTracksUserResponse
func (c *ClientWithResponses) RemoveTracksUserWithBodyWithResponse(ctx context.Context, params *RemoveTracksUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTracksUserResponse, error) {
	rsp, err := c.RemoveTracksUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTracksUserResponse(rsp)
}

func (c *ClientWithResponses) RemoveTracksUserWithResponse(ctx context.Context, params *RemoveTracksUserParams, body RemoveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTracksUserResponse, error) {
	rsp, err := c.RemoveTracksUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTracksUserResponse(rsp)
}

// GetUsersSavedTracksWithResponse request returning *GetUsersSavedTracksResponse
func (c *ClientWithResponses) GetUsersSavedTracksWithResponse(ctx context.Context, params *GetUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*GetUsersSavedTracksResponse, error) {
	rsp, err := c.GetUsersSavedTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSavedTracksResponse(rsp)
}

// SaveTracksUserWithBodyWithResponse request with arbitrary body returning *SaveTracksUserResponse
func (c *ClientWithResponses) SaveTracksUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveTracksUserResponse, error) {
	rsp, err := c.SaveTracksUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveTracksUserResponse(rsp)
}

func (c *ClientWithResponses) SaveTracksUserWithResponse(ctx context.Context, body SaveTracksUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveTracksUserResponse, error) {
	rsp, err := c.SaveTracksUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveTracksUserResponse(rsp)
}

// CheckUsersSavedTracksWithResponse request returning *CheckUsersSavedTracksResponse
func (c *ClientWithResponses) CheckUsersSavedTracksWithResponse(ctx context.Context, params *CheckUsersSavedTracksParams, reqEditors ...RequestEditorFn) (*CheckUsersSavedTracksResponse, error) {
	rsp, err := c.CheckUsersSavedTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckUsersSavedTracksResponse(rsp)
}

// GetPlaylistWithResponse request returning *GetPlaylistResponse
func (c *ClientWithResponses) GetPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistParams, reqEditors ...RequestEditorFn) (*GetPlaylistResponse, error) {
	rsp, err := c.GetPlaylist(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistResponse(rsp)
}

// ChangePlaylistDetailsWithBodyWithResponse request with arbitrary body returning *ChangePlaylistDetailsResponse
func (c *ClientWithResponses) ChangePlaylistDetailsWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePlaylistDetailsResponse, error) {
	rsp, err := c.ChangePlaylistDetailsWithBody(ctx, playlistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePlaylistDetailsResponse(rsp)
}

func (c *ClientWithResponses) ChangePlaylistDetailsWithResponse(ctx context.Context, playlistId PathPlaylistId, body ChangePlaylistDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePlaylistDetailsResponse, error) {
	rsp, err := c.ChangePlaylistDetails(ctx, playlistId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePlaylistDetailsResponse(rsp)
}

// UnfollowPlaylistWithResponse request returning *UnfollowPlaylistResponse
func (c *ClientWithResponses) UnfollowPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*UnfollowPlaylistResponse, error) {
	rsp, err := c.UnfollowPlaylist(ctx, playlistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowPlaylistResponse(rsp)
}

// FollowPlaylistWithBodyWithResponse request with arbitrary body returning *FollowPlaylistResponse
func (c *ClientWithResponses) FollowPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowPlaylistResponse, error) {
	rsp, err := c.FollowPlaylistWithBody(ctx, playlistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowPlaylistResponse(rsp)
}

func (c *ClientWithResponses) FollowPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, body FollowPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowPlaylistResponse, error) {
	rsp, err := c.FollowPlaylist(ctx, playlistId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowPlaylistResponse(rsp)
}

// CheckIfUserFollowsPlaylistWithResponse request returning *CheckIfUserFollowsPlaylistResponse
func (c *ClientWithResponses) CheckIfUserFollowsPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *CheckIfUserFollowsPlaylistParams, reqEditors ...RequestEditorFn) (*CheckIfUserFollowsPlaylistResponse, error) {
	rsp, err := c.CheckIfUserFollowsPlaylist(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckIfUserFollowsPlaylistResponse(rsp)
}

// GetPlaylistCoverWithResponse request returning *GetPlaylistCoverResponse
func (c *ClientWithResponses) GetPlaylistCoverWithResponse(ctx context.Context, playlistId PathPlaylistId, reqEditors ...RequestEditorFn) (*GetPlaylistCoverResponse, error) {
	rsp, err := c.GetPlaylistCover(ctx, playlistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistCoverResponse(rsp)
}

// UploadCustomPlaylistCoverWithBodyWithResponse request with arbitrary body returning *UploadCustomPlaylistCoverResponse
func (c *ClientWithResponses) UploadCustomPlaylistCoverWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomPlaylistCoverResponse, error) {
	rsp, err := c.UploadCustomPlaylistCoverWithBody(ctx, playlistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCustomPlaylistCoverResponse(rsp)
}

// RemoveTracksPlaylistWithBodyWithResponse request with arbitrary body returning *RemoveTracksPlaylistResponse
func (c *ClientWithResponses) RemoveTracksPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTracksPlaylistResponse, error) {
	rsp, err := c.RemoveTracksPlaylistWithBody(ctx, playlistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTracksPlaylistResponse(rsp)
}

func (c *ClientWithResponses) RemoveTracksPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, body RemoveTracksPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTracksPlaylistResponse, error) {
	rsp, err := c.RemoveTracksPlaylist(ctx, playlistId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTracksPlaylistResponse(rsp)
}

// GetPlaylistsTracksWithResponse request returning *GetPlaylistsTracksResponse
func (c *ClientWithResponses) GetPlaylistsTracksWithResponse(ctx context.Context, playlistId PathPlaylistId, params *GetPlaylistsTracksParams, reqEditors ...RequestEditorFn) (*GetPlaylistsTracksResponse, error) {
	rsp, err := c.GetPlaylistsTracks(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistsTracksResponse(rsp)
}

// AddTracksToPlaylistWithBodyWithResponse request with arbitrary body returning *AddTracksToPlaylistResponse
func (c *ClientWithResponses) AddTracksToPlaylistWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTracksToPlaylistResponse, error) {
	rsp, err := c.AddTracksToPlaylistWithBody(ctx, playlistId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTracksToPlaylistResponse(rsp)
}

func (c *ClientWithResponses) AddTracksToPlaylistWithResponse(ctx context.Context, playlistId PathPlaylistId, params *AddTracksToPlaylistParams, body AddTracksToPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTracksToPlaylistResponse, error) {
	rsp, err := c.AddTracksToPlaylist(ctx, playlistId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTracksToPlaylistResponse(rsp)
}

// ReorderOrReplacePlaylistsTracksWithBodyWithResponse request with arbitrary body returning *ReorderOrReplacePlaylistsTracksResponse
func (c *ClientWithResponses) ReorderOrReplacePlaylistsTracksWithBodyWithResponse(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReorderOrReplacePlaylistsTracksResponse, error) {
	rsp, err := c.ReorderOrReplacePlaylistsTracksWithBody(ctx, playlistId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReorderOrReplacePlaylistsTracksResponse(rsp)
}

func (c *ClientWithResponses) ReorderOrReplacePlaylistsTracksWithResponse(ctx context.Context, playlistId PathPlaylistId, params *ReorderOrReplacePlaylistsTracksParams, body ReorderOrReplacePlaylistsTracksJSONRequestBody, reqEditors ...RequestEditorFn) (*ReorderOrReplacePlaylistsTracksResponse, error) {
	rsp, err := c.ReorderOrReplacePlaylistsTracks(ctx, playlistId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReorderOrReplacePlaylistsTracksResponse(rsp)
}

// GetRecommendationsWithResponse request returning *GetRecommendationsResponse
func (c *ClientWithResponses) GetRecommendationsWithResponse(ctx context.Context, params *GetRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecommendationsResponse, error) {
	rsp, err := c.GetRecommendations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecommendationsResponse(rsp)
}

// GetRecommendationGenresWithResponse request returning *GetRecommendationGenresResponse
func (c *ClientWithResponses) GetRecommendationGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecommendationGenresResponse, error) {
	rsp, err := c.GetRecommendationGenres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecommendationGenresResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// GetMultipleShowsWithResponse request returning *GetMultipleShowsResponse
func (c *ClientWithResponses) GetMultipleShowsWithResponse(ctx context.Context, params *GetMultipleShowsParams, reqEditors ...RequestEditorFn) (*GetMultipleShowsResponse, error) {
	rsp, err := c.GetMultipleShows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleShowsResponse(rsp)
}

// GetAShowWithResponse request returning *GetAShowResponse
func (c *ClientWithResponses) GetAShowWithResponse(ctx context.Context, id PathShowId, params *GetAShowParams, reqEditors ...RequestEditorFn) (*GetAShowResponse, error) {
	rsp, err := c.GetAShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAShowResponse(rsp)
}

// GetAShowsEpisodesWithResponse request returning *GetAShowsEpisodesResponse
func (c *ClientWithResponses) GetAShowsEpisodesWithResponse(ctx context.Context, id PathShowId, params *GetAShowsEpisodesParams, reqEditors ...RequestEditorFn) (*GetAShowsEpisodesResponse, error) {
	rsp, err := c.GetAShowsEpisodes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAShowsEpisodesResponse(rsp)
}

// GetSeveralTracksWithResponse request returning *GetSeveralTracksResponse
func (c *ClientWithResponses) GetSeveralTracksWithResponse(ctx context.Context, params *GetSeveralTracksParams, reqEditors ...RequestEditorFn) (*GetSeveralTracksResponse, error) {
	rsp, err := c.GetSeveralTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeveralTracksResponse(rsp)
}

// GetTrackWithResponse request returning *GetTrackResponse
func (c *ClientWithResponses) GetTrackWithResponse(ctx context.Context, id string, params *GetTrackParams, reqEditors ...RequestEditorFn) (*GetTrackResponse, error) {
	rsp, err := c.GetTrack(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrackResponse(rsp)
}

// GetUsersProfileWithResponse request returning *GetUsersProfileResponse
func (c *ClientWithResponses) GetUsersProfileWithResponse(ctx context.Context, userId PathUserId, reqEditors ...RequestEditorFn) (*GetUsersProfileResponse, error) {
	rsp, err := c.GetUsersProfile(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersProfileResponse(rsp)
}

// GetListUsersPlaylistsWithResponse request returning *GetListUsersPlaylistsResponse
func (c *ClientWithResponses) GetListUsersPlaylistsWithResponse(ctx context.Context, userId PathUserId, params *GetListUsersPlaylistsParams, reqEditors ...RequestEditorFn) (*GetListUsersPlaylistsResponse, error) {
	rsp, err := c.GetListUsersPlaylists(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListUsersPlaylistsResponse(rsp)
}

// CreatePlaylistWithBodyWithResponse request with arbitrary body returning *CreatePlaylistResponse
func (c *ClientWithResponses) CreatePlaylistWithBodyWithResponse(ctx context.Context, userId PathUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylistWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaylistWithResponse(ctx context.Context, userId PathUserId, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylist(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

// ParseGetMultipleAlbumsResponse parses an HTTP response from a GetMultipleAlbumsWithResponse call
func ParseGetMultipleAlbumsResponse(rsp *http.Response) (*GetMultipleAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyAlbums
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnAlbumResponse parses an HTTP response from a GetAnAlbumWithResponse call
func ParseGetAnAlbumResponse(rsp *http.Response) (*GetAnAlbumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnAlbumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneAlbum
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnAlbumsTracksResponse parses an HTTP response from a GetAnAlbumsTracksWithResponse call
func ParseGetAnAlbumsTracksResponse(rsp *http.Response) (*GetAnAlbumsTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnAlbumsTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSimplifiedTrackObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMultipleArtistsResponse parses an HTTP response from a GetMultipleArtistsWithResponse call
func ParseGetMultipleArtistsResponse(rsp *http.Response) (*GetMultipleArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyArtists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnArtistResponse parses an HTTP response from a GetAnArtistWithResponse call
func ParseGetAnArtistResponse(rsp *http.Response) (*GetAnArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneArtist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnArtistsAlbumsResponse parses an HTTP response from a GetAnArtistsAlbumsWithResponse call
func ParseGetAnArtistsAlbumsResponse(rsp *http.Response) (*GetAnArtistsAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnArtistsAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingArtistDiscographyAlbumObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnArtistsRelatedArtistsResponse parses an HTTP response from a GetAnArtistsRelatedArtistsWithResponse call
func ParseGetAnArtistsRelatedArtistsResponse(rsp *http.Response) (*GetAnArtistsRelatedArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnArtistsRelatedArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyArtists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnArtistsTopTracksResponse parses an HTTP response from a GetAnArtistsTopTracksWithResponse call
func ParseGetAnArtistsTopTracksResponse(rsp *http.Response) (*GetAnArtistsTopTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnArtistsTopTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyTracks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAudioAnalysisResponse parses an HTTP response from a GetAudioAnalysisWithResponse call
func ParseGetAudioAnalysisResponse(rsp *http.Response) (*GetAudioAnalysisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneAudioAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetSeveralAudioFeaturesResponse parses an HTTP response from a GetSeveralAudioFeaturesWithResponse call
func ParseGetSeveralAudioFeaturesResponse(rsp *http.Response) (*GetSeveralAudioFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeveralAudioFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyAudioFeatures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAudioFeaturesResponse parses an HTTP response from a GetAudioFeaturesWithResponse call
func ParseGetAudioFeaturesResponse(rsp *http.Response) (*GetAudioFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneAudioFeatures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMultipleAudiobooksResponse parses an HTTP response from a GetMultipleAudiobooksWithResponse call
func ParseGetMultipleAudiobooksResponse(rsp *http.Response) (*GetMultipleAudiobooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleAudiobooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyAudiobooks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnAudiobookResponse parses an HTTP response from a GetAnAudiobookWithResponse call
func ParseGetAnAudiobookResponse(rsp *http.Response) (*GetAnAudiobookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnAudiobookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneAudiobook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAudiobookChaptersResponse parses an HTTP response from a GetAudiobookChaptersWithResponse call
func ParseGetAudiobookChaptersResponse(rsp *http.Response) (*GetAudiobookChaptersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudiobookChaptersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSimplifiedChapterObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetCategoriesResponse parses an HTTP response from a GetCategoriesWithResponse call
func ParseGetCategoriesResponse(rsp *http.Response) (*GetCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedCategories
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetACategoryResponse parses an HTTP response from a GetACategoryWithResponse call
func ParseGetACategoryResponse(rsp *http.Response) (*GetACategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetACategoriesPlaylistsResponse parses an HTTP response from a GetACategoriesPlaylistsWithResponse call
func ParseGetACategoriesPlaylistsResponse(rsp *http.Response) (*GetACategoriesPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACategoriesPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedFeaturedPlaylists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetFeaturedPlaylistsResponse parses an HTTP response from a GetFeaturedPlaylistsWithResponse call
func ParseGetFeaturedPlaylistsResponse(rsp *http.Response) (*GetFeaturedPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeaturedPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedFeaturedPlaylists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetNewReleasesResponse parses an HTTP response from a GetNewReleasesWithResponse call
func ParseGetNewReleasesResponse(rsp *http.Response) (*GetNewReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNewReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedAlbums
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetSeveralChaptersResponse parses an HTTP response from a GetSeveralChaptersWithResponse call
func ParseGetSeveralChaptersResponse(rsp *http.Response) (*GetSeveralChaptersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeveralChaptersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyChapters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAChapterResponse parses an HTTP response from a GetAChapterWithResponse call
func ParseGetAChapterResponse(rsp *http.Response) (*GetAChapterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAChapterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneChapter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMultipleEpisodesResponse parses an HTTP response from a GetMultipleEpisodesWithResponse call
func ParseGetMultipleEpisodesResponse(rsp *http.Response) (*GetMultipleEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAnEpisodeResponse parses an HTTP response from a GetAnEpisodeWithResponse call
func ParseGetAnEpisodeResponse(rsp *http.Response) (*GetAnEpisodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnEpisodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneEpisode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAvailableMarketsResponse parses an HTTP response from a GetAvailableMarketsWithResponse call
func ParseGetAvailableMarketsResponse(rsp *http.Response) (*GetAvailableMarketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Markets *[]string `json:"markets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetCurrentUsersProfileResponse parses an HTTP response from a GetCurrentUsersProfileWithResponse call
func ParseGetCurrentUsersProfileResponse(rsp *http.Response) (*GetCurrentUsersProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUsersProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnePrivateUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveAlbumsUserResponse parses an HTTP response from a RemoveAlbumsUserWithResponse call
func ParseRemoveAlbumsUserResponse(rsp *http.Response) (*RemoveAlbumsUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAlbumsUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersSavedAlbumsResponse parses an HTTP response from a GetUsersSavedAlbumsWithResponse call
func ParseGetUsersSavedAlbumsResponse(rsp *http.Response) (*GetUsersSavedAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSavedAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSavedAlbumObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSaveAlbumsUserResponse parses an HTTP response from a SaveAlbumsUserWithResponse call
func ParseSaveAlbumsUserResponse(rsp *http.Response) (*SaveAlbumsUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveAlbumsUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckUsersSavedAlbumsResponse parses an HTTP response from a CheckUsersSavedAlbumsWithResponse call
func ParseCheckUsersSavedAlbumsResponse(rsp *http.Response) (*CheckUsersSavedAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUsersSavedAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveAudiobooksUserResponse parses an HTTP response from a RemoveAudiobooksUserWithResponse call
func ParseRemoveAudiobooksUserResponse(rsp *http.Response) (*RemoveAudiobooksUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAudiobooksUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersSavedAudiobooksResponse parses an HTTP response from a GetUsersSavedAudiobooksWithResponse call
func ParseGetUsersSavedAudiobooksResponse(rsp *http.Response) (*GetUsersSavedAudiobooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSavedAudiobooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSimplifiedAudiobookObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSaveAudiobooksUserResponse parses an HTTP response from a SaveAudiobooksUserWithResponse call
func ParseSaveAudiobooksUserResponse(rsp *http.Response) (*SaveAudiobooksUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveAudiobooksUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckUsersSavedAudiobooksResponse parses an HTTP response from a CheckUsersSavedAudiobooksWithResponse call
func ParseCheckUsersSavedAudiobooksResponse(rsp *http.Response) (*CheckUsersSavedAudiobooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUsersSavedAudiobooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveEpisodesUserResponse parses an HTTP response from a RemoveEpisodesUserWithResponse call
func ParseRemoveEpisodesUserResponse(rsp *http.Response) (*RemoveEpisodesUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveEpisodesUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersSavedEpisodesResponse parses an HTTP response from a GetUsersSavedEpisodesWithResponse call
func ParseGetUsersSavedEpisodesResponse(rsp *http.Response) (*GetUsersSavedEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSavedEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSavedEpisodeObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSaveEpisodesUserResponse parses an HTTP response from a SaveEpisodesUserWithResponse call
func ParseSaveEpisodesUserResponse(rsp *http.Response) (*SaveEpisodesUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveEpisodesUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckUsersSavedEpisodesResponse parses an HTTP response from a CheckUsersSavedEpisodesWithResponse call
func ParseCheckUsersSavedEpisodesResponse(rsp *http.Response) (*CheckUsersSavedEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUsersSavedEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUnfollowArtistsUsersResponse parses an HTTP response from a UnfollowArtistsUsersWithResponse call
func ParseUnfollowArtistsUsersResponse(rsp *http.Response) (*UnfollowArtistsUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnfollowArtistsUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetFollowedResponse parses an HTTP response from a GetFollowedWithResponse call
func ParseGetFollowedResponse(rsp *http.Response) (*GetFollowedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFollowedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CursorPagedArtists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseFollowArtistsUsersResponse parses an HTTP response from a FollowArtistsUsersWithResponse call
func ParseFollowArtistsUsersResponse(rsp *http.Response) (*FollowArtistsUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowArtistsUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckCurrentUserFollowsResponse parses an HTTP response from a CheckCurrentUserFollowsWithResponse call
func ParseCheckCurrentUserFollowsResponse(rsp *http.Response) (*CheckCurrentUserFollowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckCurrentUserFollowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetInformationAboutTheUsersCurrentPlaybackResponse parses an HTTP response from a GetInformationAboutTheUsersCurrentPlaybackWithResponse call
func ParseGetInformationAboutTheUsersCurrentPlaybackResponse(rsp *http.Response) (*GetInformationAboutTheUsersCurrentPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInformationAboutTheUsersCurrentPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneCurrentlyPlaying
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseTransferAUsersPlaybackResponse parses an HTTP response from a TransferAUsersPlaybackWithResponse call
func ParseTransferAUsersPlaybackResponse(rsp *http.Response) (*TransferAUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferAUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTheUsersCurrentlyPlayingTrackResponse parses an HTTP response from a GetTheUsersCurrentlyPlayingTrackWithResponse call
func ParseGetTheUsersCurrentlyPlayingTrackResponse(rsp *http.Response) (*GetTheUsersCurrentlyPlayingTrackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTheUsersCurrentlyPlayingTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneCurrentlyPlayingTrack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAUsersAvailableDevicesResponse parses an HTTP response from a GetAUsersAvailableDevicesWithResponse call
func ParseGetAUsersAvailableDevicesResponse(rsp *http.Response) (*GetAUsersAvailableDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAUsersAvailableDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyDevices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSkipUsersPlaybackToNextTrackResponse parses an HTTP response from a SkipUsersPlaybackToNextTrackWithResponse call
func ParseSkipUsersPlaybackToNextTrackResponse(rsp *http.Response) (*SkipUsersPlaybackToNextTrackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipUsersPlaybackToNextTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePauseAUsersPlaybackResponse parses an HTTP response from a PauseAUsersPlaybackWithResponse call
func ParsePauseAUsersPlaybackResponse(rsp *http.Response) (*PauseAUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseAUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseStartAUsersPlaybackResponse parses an HTTP response from a StartAUsersPlaybackWithResponse call
func ParseStartAUsersPlaybackResponse(rsp *http.Response) (*StartAUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSkipUsersPlaybackToPreviousTrackResponse parses an HTTP response from a SkipUsersPlaybackToPreviousTrackWithResponse call
func ParseSkipUsersPlaybackToPreviousTrackResponse(rsp *http.Response) (*SkipUsersPlaybackToPreviousTrackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SkipUsersPlaybackToPreviousTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetQueueResponse parses an HTTP response from a GetQueueWithResponse call
func ParseGetQueueResponse(rsp *http.Response) (*GetQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Queue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseAddToQueueResponse parses an HTTP response from a AddToQueueWithResponse call
func ParseAddToQueueResponse(rsp *http.Response) (*AddToQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddToQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRecentlyPlayedResponse parses an HTTP response from a GetRecentlyPlayedWithResponse call
func ParseGetRecentlyPlayedResponse(rsp *http.Response) (*GetRecentlyPlayedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentlyPlayedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CursorPagedPlayHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSetRepeatModeOnUsersPlaybackResponse parses an HTTP response from a SetRepeatModeOnUsersPlaybackWithResponse call
func ParseSetRepeatModeOnUsersPlaybackResponse(rsp *http.Response) (*SetRepeatModeOnUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRepeatModeOnUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSeekToPositionInCurrentlyPlayingTrackResponse parses an HTTP response from a SeekToPositionInCurrentlyPlayingTrackWithResponse call
func ParseSeekToPositionInCurrentlyPlayingTrackResponse(rsp *http.Response) (*SeekToPositionInCurrentlyPlayingTrackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SeekToPositionInCurrentlyPlayingTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseToggleShuffleForUsersPlaybackResponse parses an HTTP response from a ToggleShuffleForUsersPlaybackWithResponse call
func ParseToggleShuffleForUsersPlaybackResponse(rsp *http.Response) (*ToggleShuffleForUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleShuffleForUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSetVolumeForUsersPlaybackResponse parses an HTTP response from a SetVolumeForUsersPlaybackWithResponse call
func ParseSetVolumeForUsersPlaybackResponse(rsp *http.Response) (*SetVolumeForUsersPlaybackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVolumeForUsersPlaybackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAListOfCurrentUsersPlaylistsResponse parses an HTTP response from a GetAListOfCurrentUsersPlaylistsWithResponse call
func ParseGetAListOfCurrentUsersPlaylistsResponse(rsp *http.Response) (*GetAListOfCurrentUsersPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAListOfCurrentUsersPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedPlaylists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveShowsUserResponse parses an HTTP response from a RemoveShowsUserWithResponse call
func ParseRemoveShowsUserResponse(rsp *http.Response) (*RemoveShowsUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveShowsUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersSavedShowsResponse parses an HTTP response from a GetUsersSavedShowsWithResponse call
func ParseGetUsersSavedShowsResponse(rsp *http.Response) (*GetUsersSavedShowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSavedShowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSavedShowObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSaveShowsUserResponse parses an HTTP response from a SaveShowsUserWithResponse call
func ParseSaveShowsUserResponse(rsp *http.Response) (*SaveShowsUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveShowsUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckUsersSavedShowsResponse parses an HTTP response from a CheckUsersSavedShowsWithResponse call
func ParseCheckUsersSavedShowsResponse(rsp *http.Response) (*CheckUsersSavedShowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUsersSavedShowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersTopArtistsAndTracksResponse parses an HTTP response from a GetUsersTopArtistsAndTracksWithResponse call
func ParseGetUsersTopArtistsAndTracksResponse(rsp *http.Response) (*GetUsersTopArtistsAndTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersTopArtistsAndTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingArtistOrTrackObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveTracksUserResponse parses an HTTP response from a RemoveTracksUserWithResponse call
func ParseRemoveTracksUserResponse(rsp *http.Response) (*RemoveTracksUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTracksUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersSavedTracksResponse parses an HTTP response from a GetUsersSavedTracksWithResponse call
func ParseGetUsersSavedTracksResponse(rsp *http.Response) (*GetUsersSavedTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSavedTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSavedTrackObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSaveTracksUserResponse parses an HTTP response from a SaveTracksUserWithResponse call
func ParseSaveTracksUserResponse(rsp *http.Response) (*SaveTracksUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveTracksUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckUsersSavedTracksResponse parses an HTTP response from a CheckUsersSavedTracksWithResponse call
func ParseCheckUsersSavedTracksResponse(rsp *http.Response) (*CheckUsersSavedTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckUsersSavedTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfBooleans
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPlaylistResponse parses an HTTP response from a GetPlaylistWithResponse call
func ParseGetPlaylistResponse(rsp *http.Response) (*GetPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnePlaylist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseChangePlaylistDetailsResponse parses an HTTP response from a ChangePlaylistDetailsWithResponse call
func ParseChangePlaylistDetailsResponse(rsp *http.Response) (*ChangePlaylistDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePlaylistDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUnfollowPlaylistResponse parses an HTTP response from a UnfollowPlaylistWithResponse call
func ParseUnfollowPlaylistResponse(rsp *http.Response) (*UnfollowPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnfollowPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseFollowPlaylistResponse parses an HTTP response from a FollowPlaylistWithResponse call
func ParseFollowPlaylistResponse(rsp *http.Response) (*FollowPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCheckIfUserFollowsPlaylistResponse parses an HTTP response from a CheckIfUserFollowsPlaylistWithResponse call
func ParseCheckIfUserFollowsPlaylistResponse(rsp *http.Response) (*CheckIfUserFollowsPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckIfUserFollowsPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SingletonArrayOfBoolean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPlaylistCoverResponse parses an HTTP response from a GetPlaylistCoverWithResponse call
func ParseGetPlaylistCoverResponse(rsp *http.Response) (*GetPlaylistCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfImages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUploadCustomPlaylistCoverResponse parses an HTTP response from a UploadCustomPlaylistCoverWithResponse call
func ParseUploadCustomPlaylistCoverResponse(rsp *http.Response) (*UploadCustomPlaylistCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCustomPlaylistCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseRemoveTracksPlaylistResponse parses an HTTP response from a RemoveTracksPlaylistWithResponse call
func ParseRemoveTracksPlaylistResponse(rsp *http.Response) (*RemoveTracksPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTracksPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaylistSnapshotId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPlaylistsTracksResponse parses an HTTP response from a GetPlaylistsTracksWithResponse call
func ParseGetPlaylistsTracksResponse(rsp *http.Response) (*GetPlaylistsTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistsTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingPlaylistTrackObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseAddTracksToPlaylistResponse parses an HTTP response from a AddTracksToPlaylistWithResponse call
func ParseAddTracksToPlaylistResponse(rsp *http.Response) (*AddTracksToPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTracksToPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PlaylistSnapshotId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseReorderOrReplacePlaylistsTracksResponse parses an HTTP response from a ReorderOrReplacePlaylistsTracksWithResponse call
func ParseReorderOrReplacePlaylistsTracksResponse(rsp *http.Response) (*ReorderOrReplacePlaylistsTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReorderOrReplacePlaylistsTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaylistSnapshotId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRecommendationsResponse parses an HTTP response from a GetRecommendationsWithResponse call
func ParseGetRecommendationsResponse(rsp *http.Response) (*GetRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneRecommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRecommendationGenresResponse parses an HTTP response from a GetRecommendationGenresWithResponse call
func ParseGetRecommendationGenresResponse(rsp *http.Response) (*GetRecommendationGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecommendationGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyGenres
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMultipleShowsResponse parses an HTTP response from a GetMultipleShowsWithResponse call
func ParseGetMultipleShowsResponse(rsp *http.Response) (*GetMultipleShowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleShowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManySimplifiedShows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAShowResponse parses an HTTP response from a GetAShowWithResponse call
func ParseGetAShowResponse(rsp *http.Response) (*GetAShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneShow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAShowsEpisodesResponse parses an HTTP response from a GetAShowsEpisodesWithResponse call
func ParseGetAShowsEpisodesResponse(rsp *http.Response) (*GetAShowsEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAShowsEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagingSimplifiedEpisodeObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetSeveralTracksResponse parses an HTTP response from a GetSeveralTracksWithResponse call
func ParseGetSeveralTracksResponse(rsp *http.Response) (*GetSeveralTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeveralTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManyTracks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTrackResponse parses an HTTP response from a GetTrackWithResponse call
func ParseGetTrackResponse(rsp *http.Response) (*GetTrackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OneTrack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetUsersProfileResponse parses an HTTP response from a GetUsersProfileWithResponse call
func ParseGetUsersProfileResponse(rsp *http.Response) (*GetUsersProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnePublicUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetListUsersPlaylistsResponse parses an HTTP response from a GetListUsersPlaylistsWithResponse call
func ParseGetListUsersPlaylistsResponse(rsp *http.Response) (*GetListUsersPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListUsersPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedPlaylists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreatePlaylistResponse parses an HTTP response from a CreatePlaylistWithResponse call
func ParseCreatePlaylistResponse(rsp *http.Response) (*CreatePlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OnePlaylist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
