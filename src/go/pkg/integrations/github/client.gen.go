// Package github provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package github

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ContentFileType.
const (
	Dir       ContentFileType = "dir"
	File      ContentFileType = "file"
	Submodule ContentFileType = "submodule"
	Symlink   ContentFileType = "symlink"
)

// Defines values for DiffEntryStatus.
const (
	Added     DiffEntryStatus = "added"
	Changed   DiffEntryStatus = "changed"
	Copied    DiffEntryStatus = "copied"
	Modified  DiffEntryStatus = "modified"
	Removed   DiffEntryStatus = "removed"
	Renamed   DiffEntryStatus = "renamed"
	Unchanged DiffEntryStatus = "unchanged"
)

// BasicError Basic Error
type BasicError struct {
	DocumentationUrl *string `json:"documentation_url,omitempty"`
	Message          *string `json:"message,omitempty"`
	Status           *string `json:"status,omitempty"`
	Url              *string `json:"url,omitempty"`
}

// Commit Commit
type Commit struct {
	// Author A GitHub user.
	Author *SimpleUser `json:"author,omitempty"`

	// Commit The commit details.
	Commit FileCommitDetails `json:"commit"`

	// Committer A GitHub user.
	Committer *SimpleUser  `json:"committer,omitempty"`
	Files     *[]DiffEntry `json:"files,omitempty"`
	HtmlUrl   string       `json:"html_url"`
	Sha       string       `json:"sha"`
	Url       string       `json:"url"`
}

// CommitAuthor The author or committer of a commit.
type CommitAuthor struct {
	// Date Indicates when this commit was authored (or committed).
	Date *time.Time `json:"date,omitempty"`

	// Email The email of the author or committer.
	Email string `json:"email"`

	// Name The name of the author or committer.
	Name string `json:"name"`
}

// CommitUser defines model for CommitUser.
type CommitUser struct {
	Date  *string `json:"date,omitempty"`
	Email *string `json:"email,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// ContentFile Content File
type ContentFile struct {
	UnderscoreLinks ContentLinks `json:"_links"`

	// Content Base64 encoded content of the file.
	Content     *string         `json:"content,omitempty"`
	DownloadUrl string          `json:"download_url"`
	Encoding    *string         `json:"encoding,omitempty"`
	GitUrl      string          `json:"git_url"`
	HtmlUrl     string          `json:"html_url"`
	Name        string          `json:"name"`
	Path        string          `json:"path"`
	Sha         string          `json:"sha"`
	Size        int             `json:"size"`
	Type        ContentFileType `json:"type"`
	Url         string          `json:"url"`
}

// ContentFileType defines model for ContentFile.Type.
type ContentFileType string

// ContentLinks defines model for ContentLinks.
type ContentLinks struct {
	Git  string `json:"git"`
	Html string `json:"html"`
	Self string `json:"self"`
}

// CreateOrUpdateFileRequest Request body for creating or updating a file.
type CreateOrUpdateFileRequest struct {
	// Author The author or committer of a commit.
	Author *CommitAuthor `json:"author,omitempty"`

	// Branch The branch name. Default: the repository's default branch.
	Branch *string `json:"branch,omitempty"`

	// Committer The author or committer of a commit.
	Committer *CommitAuthor `json:"committer,omitempty"`

	// Content The new file content, using Base64 encoding.
	Content string `json:"content"`

	// Message The commit message.
	Message string `json:"message"`

	// Sha Required if you are updating a file. The blob SHA of the file being replaced.
	Sha *string `json:"sha,omitempty"`
}

// DiffEntry Diff Entry
type DiffEntry struct {
	Additions        int             `json:"additions"`
	Changes          int             `json:"changes"`
	Deletions        int             `json:"deletions"`
	Filename         string          `json:"filename"`
	Patch            *string         `json:"patch,omitempty"`
	PreviousFilename *string         `json:"previous_filename,omitempty"`
	Sha              string          `json:"sha"`
	Status           DiffEntryStatus `json:"status"`
}

// DiffEntryStatus defines model for DiffEntry.Status.
type DiffEntryStatus string

// FileCommit File Commit
type FileCommit struct {
	// Commit The commit details.
	Commit FileCommitDetails `json:"commit"`

	// Content The file content after the commit.
	Content FileCommitContent `json:"content"`
}

// FileCommitContent The file content after the commit.
type FileCommitContent struct {
	UnderscoreLinks *ContentLinks `json:"_links,omitempty"`
	DownloadUrl     *string       `json:"download_url,omitempty"`
	GitUrl          *string       `json:"git_url,omitempty"`
	HtmlUrl         *string       `json:"html_url,omitempty"`
	Name            *string       `json:"name,omitempty"`
	Path            *string       `json:"path,omitempty"`
	Sha             *string       `json:"sha,omitempty"`
	Size            *int          `json:"size,omitempty"`
	Type            *string       `json:"type,omitempty"`
	Url             *string       `json:"url,omitempty"`
}

// FileCommitDetails The commit details.
type FileCommitDetails struct {
	Author    *CommitUser `json:"author,omitempty"`
	Committer *CommitUser `json:"committer,omitempty"`
	HtmlUrl   *string     `json:"html_url,omitempty"`
	Message   *string     `json:"message,omitempty"`
	Parents   *[]struct {
		HtmlUrl *string `json:"html_url,omitempty"`
		Sha     *string `json:"sha,omitempty"`
		Url     *string `json:"url,omitempty"`
	} `json:"parents,omitempty"`
	Sha  *string `json:"sha,omitempty"`
	Tree *struct {
		Sha *string `json:"sha,omitempty"`
		Url *string `json:"url,omitempty"`
	} `json:"tree,omitempty"`
	Url *string `json:"url,omitempty"`
}

// SimpleUser A GitHub user.
type SimpleUser struct {
	AvatarUrl *string `json:"avatar_url,omitempty"`
	HtmlUrl   *string `json:"html_url,omitempty"`
	Id        int     `json:"id"`
	Login     string  `json:"login"`
}

// ValidationError Validation Error
type ValidationError struct {
	DocumentationUrl string `json:"documentation_url"`
	Errors           *[]struct {
		Code     string  `json:"code"`
		Field    *string `json:"field,omitempty"`
		Message  *string `json:"message,omitempty"`
		Resource *string `json:"resource,omitempty"`
	} `json:"errors,omitempty"`
	Message string `json:"message"`
}

// Owner defines model for owner.
type Owner = string

// Path defines model for path.
type Path = string

// Ref defines model for ref.
type Ref = string

// Repo defines model for repo.
type Repo = string

// ReposgetContentParams defines parameters for ReposgetContent.
type ReposgetContentParams struct {
	// Ref The name of the commit/branch/tag. Default: the repository's default branch.
	Ref *string `form:"ref,omitempty" json:"ref,omitempty"`
}

// ReposcreateOrUpdateFileContentsJSONRequestBody defines body for ReposcreateOrUpdateFileContents for application/json ContentType.
type ReposcreateOrUpdateFileContentsJSONRequestBody = CreateOrUpdateFileRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ReposgetCommit request
	ReposgetCommit(ctx context.Context, owner Owner, repo Repo, ref Ref, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetContent request
	ReposgetContent(ctx context.Context, owner Owner, repo Repo, path Path, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateOrUpdateFileContentsWithBody request with any body
	ReposcreateOrUpdateFileContentsWithBody(ctx context.Context, owner Owner, repo Repo, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateOrUpdateFileContents(ctx context.Context, owner Owner, repo Repo, path Path, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ReposgetCommit(ctx context.Context, owner Owner, repo Repo, ref Ref, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommitRequest(c.Server, owner, repo, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetContent(ctx context.Context, owner Owner, repo Repo, path Path, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetContentRequest(c.Server, owner, repo, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateFileContentsWithBody(ctx context.Context, owner Owner, repo Repo, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateFileContentsRequestWithBody(c.Server, owner, repo, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateFileContents(ctx context.Context, owner Owner, repo Repo, path Path, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateFileContentsRequest(c.Server, owner, repo, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewReposgetCommitRequest generates requests for ReposgetCommit
func NewReposgetCommitRequest(server string, owner Owner, repo Repo, ref Ref) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetContentRequest generates requests for ReposgetContent
func NewReposgetContentRequest(server string, owner Owner, repo Repo, path Path, params *ReposgetContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ref != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateOrUpdateFileContentsRequest calls the generic ReposcreateOrUpdateFileContents builder with application/json body
func NewReposcreateOrUpdateFileContentsRequest(server string, owner Owner, repo Repo, path Path, body ReposcreateOrUpdateFileContentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateOrUpdateFileContentsRequestWithBody(server, owner, repo, path, "application/json", bodyReader)
}

// NewReposcreateOrUpdateFileContentsRequestWithBody generates requests for ReposcreateOrUpdateFileContents with any type of body
func NewReposcreateOrUpdateFileContentsRequestWithBody(server string, owner Owner, repo Repo, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ReposgetCommitWithResponse request
	ReposgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, ref Ref, reqEditors ...RequestEditorFn) (*ReposgetCommitResponse, error)

	// ReposgetContentWithResponse request
	ReposgetContentWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*ReposgetContentResponse, error)

	// ReposcreateOrUpdateFileContentsWithBodyWithResponse request with any body
	ReposcreateOrUpdateFileContentsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error)

	ReposcreateOrUpdateFileContentsWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error)
}

type ReposgetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentFile
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateOrUpdateFileContentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileCommit
	JSON201      *FileCommit
	JSON404      *BasicError
	JSON409      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateOrUpdateFileContentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateOrUpdateFileContentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ReposgetCommitWithResponse request returning *ReposgetCommitResponse
func (c *ClientWithResponses) ReposgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, ref Ref, reqEditors ...RequestEditorFn) (*ReposgetCommitResponse, error) {
	rsp, err := c.ReposgetCommit(ctx, owner, repo, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommitResponse(rsp)
}

// ReposgetContentWithResponse request returning *ReposgetContentResponse
func (c *ClientWithResponses) ReposgetContentWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*ReposgetContentResponse, error) {
	rsp, err := c.ReposgetContent(ctx, owner, repo, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetContentResponse(rsp)
}

// ReposcreateOrUpdateFileContentsWithBodyWithResponse request with arbitrary body returning *ReposcreateOrUpdateFileContentsResponse
func (c *ClientWithResponses) ReposcreateOrUpdateFileContentsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error) {
	rsp, err := c.ReposcreateOrUpdateFileContentsWithBody(ctx, owner, repo, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateFileContentsResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateOrUpdateFileContentsWithResponse(ctx context.Context, owner Owner, repo Repo, path Path, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error) {
	rsp, err := c.ReposcreateOrUpdateFileContents(ctx, owner, repo, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateFileContentsResponse(rsp)
}

// ParseReposgetCommitResponse parses an HTTP response from a ReposgetCommitWithResponse call
func ParseReposgetCommitResponse(rsp *http.Response) (*ReposgetCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetContentResponse parses an HTTP response from a ReposgetContentWithResponse call
func ParseReposgetContentResponse(rsp *http.Response) (*ReposgetContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateOrUpdateFileContentsResponse parses an HTTP response from a ReposcreateOrUpdateFileContentsWithResponse call
func ParseReposcreateOrUpdateFileContentsResponse(rsp *http.Response) (*ReposcreateOrUpdateFileContentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateOrUpdateFileContentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FileCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
