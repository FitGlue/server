// Package polar provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package polar

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicScopes  = "Basic.Scopes"
	OAuth2Scopes = "OAuth2.Scopes"
)

// Defines values for AvailableUserDataDataType.
const (
	ACTIVITYSUMMARY     AvailableUserDataDataType = "ACTIVITY_SUMMARY"
	EXERCISE            AvailableUserDataDataType = "EXERCISE"
	PHYSICALINFORMATION AvailableUserDataDataType = "PHYSICAL_INFORMATION"
)

// Defines values for ActivityZoneSample2Zone.
const (
	LIGHT     ActivityZoneSample2Zone = "LIGHT"
	MODERATE  ActivityZoneSample2Zone = "MODERATE"
	SEDENTARY ActivityZoneSample2Zone = "SEDENTARY"
	SLEEP     ActivityZoneSample2Zone = "SLEEP"
	VIGOROUS  ActivityZoneSample2Zone = "VIGOROUS"
)

// Defines values for AlertnessGradeClassification.
const (
	GRADECLASSIFICATIONEXCELLENT AlertnessGradeClassification = "GRADE_CLASSIFICATION_EXCELLENT"
	GRADECLASSIFICATIONFAIR      AlertnessGradeClassification = "GRADE_CLASSIFICATION_FAIR"
	GRADECLASSIFICATIONSTRONG    AlertnessGradeClassification = "GRADE_CLASSIFICATION_STRONG"
	GRADECLASSIFICATIONUNKNOWN   AlertnessGradeClassification = "GRADE_CLASSIFICATION_UNKNOWN"
	GRADECLASSIFICATIONWEAK      AlertnessGradeClassification = "GRADE_CLASSIFICATION_WEAK"
)

// Defines values for AlertnessGradeType.
const (
	GRADETYPEADDITIONAL AlertnessGradeType = "GRADE_TYPE_ADDITIONAL"
	GRADETYPEPRIMARY    AlertnessGradeType = "GRADE_TYPE_PRIMARY"
	GRADETYPEUNKNOWN    AlertnessGradeType = "GRADE_TYPE_UNKNOWN"
)

// Defines values for AlertnessResultType.
const (
	ALERTNESSTYPEHISTORY    AlertnessResultType = "ALERTNESS_TYPE_HISTORY"
	ALERTNESSTYPEPREDICTION AlertnessResultType = "ALERTNESS_TYPE_PREDICTION"
	ALERTNESSTYPEUNKNOWN    AlertnessResultType = "ALERTNESS_TYPE_UNKNOWN"
)

// Defines values for AlertnessSleepInertia.
const (
	SLEEPINERTIAHEAVY     AlertnessSleepInertia = "SLEEP_INERTIA_HEAVY"
	SLEEPINERTIAMILD      AlertnessSleepInertia = "SLEEP_INERTIA_MILD"
	SLEEPINERTIAMODERATE  AlertnessSleepInertia = "SLEEP_INERTIA_MODERATE"
	SLEEPINERTIANOINERTIA AlertnessSleepInertia = "SLEEP_INERTIA_NO_INERTIA"
	SLEEPINERTIAUNKNOWN   AlertnessSleepInertia = "SLEEP_INERTIA_UNKNOWN"
)

// Defines values for AlertnessSleepType.
const (
	SLEEPTYPEARTIFICIAL AlertnessSleepType = "SLEEP_TYPE_ARTIFICIAL"
	SLEEPTYPEPRIMARY    AlertnessSleepType = "SLEEP_TYPE_PRIMARY"
	SLEEPTYPESECONDARY  AlertnessSleepType = "SLEEP_TYPE_SECONDARY"
	SLEEPTYPEUNKNOWN    AlertnessSleepType = "SLEEP_TYPE_UNKNOWN"
)

// Defines values for AlertnessValidity.
const (
	AlertnessValidityVALIDITYESTIMATE AlertnessValidity = "VALIDITY_ESTIMATE"
	AlertnessValidityVALIDITYNOTVALID AlertnessValidity = "VALIDITY_NOT_VALID"
	AlertnessValidityVALIDITYRESET    AlertnessValidity = "VALIDITY_RESET"
	AlertnessValidityVALIDITYUNKNOWN  AlertnessValidity = "VALIDITY_UNKNOWN"
	AlertnessValidityVALIDITYVALID    AlertnessValidity = "VALIDITY_VALID"
)

// Defines values for AlertnessHourlyDataAlertnessLevel.
const (
	ALERTNESSLEVELHIGH     AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_HIGH"
	ALERTNESSLEVELLOW      AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_LOW"
	ALERTNESSLEVELMINIMAL  AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_MINIMAL"
	ALERTNESSLEVELUNKNOWN  AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_UNKNOWN"
	ALERTNESSLEVELVERYHIGH AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_VERY_HIGH"
	ALERTNESSLEVELVERYLOW  AlertnessHourlyDataAlertnessLevel = "ALERTNESS_LEVEL_VERY_LOW"
)

// Defines values for AlertnessHourlyDataValidity.
const (
	AlertnessHourlyDataValidityVALIDITYESTIMATE AlertnessHourlyDataValidity = "VALIDITY_ESTIMATE"
	AlertnessHourlyDataValidityVALIDITYNOTVALID AlertnessHourlyDataValidity = "VALIDITY_NOT_VALID"
	AlertnessHourlyDataValidityVALIDITYRESET    AlertnessHourlyDataValidity = "VALIDITY_RESET"
	AlertnessHourlyDataValidityVALIDITYUNKNOWN  AlertnessHourlyDataValidity = "VALIDITY_UNKNOWN"
	AlertnessHourlyDataValidityVALIDITYVALID    AlertnessHourlyDataValidity = "VALIDITY_VALID"
)

// Defines values for BodyTemperaturePeriodMeasurementType.
const (
	TMCORETEMPERATURE BodyTemperaturePeriodMeasurementType = "TM_CORE_TEMPERATURE"
	TMSKINTEMPERATURE BodyTemperaturePeriodMeasurementType = "TM_SKIN_TEMPERATURE"
	TMUNKNOWN         BodyTemperaturePeriodMeasurementType = "TM_UNKNOWN"
)

// Defines values for BodyTemperaturePeriodSensorLocation.
const (
	SLDISTAL   BodyTemperaturePeriodSensorLocation = "SL_DISTAL"
	SLPROXIMAL BodyTemperaturePeriodSensorLocation = "SL_PROXIMAL"
	SLUNKNOWN  BodyTemperaturePeriodSensorLocation = "SL_UNKNOWN"
)

// Defines values for CardioLoadStatusEnum.
const (
	DETRAINING                        CardioLoadStatusEnum = "DETRAINING"
	LOADSTATUSNOTAVAILABLE            CardioLoadStatusEnum = "LOAD_STATUS_NOT_AVAILABLE"
	MAINTAINING                       CardioLoadStatusEnum = "MAINTAINING"
	OVERREACHING                      CardioLoadStatusEnum = "OVERREACHING"
	PRODUCTIVE                        CardioLoadStatusEnum = "PRODUCTIVE"
	PRODUCTIVEALMOSTOVERREACHING      CardioLoadStatusEnum = "PRODUCTIVE_ALMOST_OVERREACHING"
	PRODUCTIVEDROPPEDFROMOVERREACHING CardioLoadStatusEnum = "PRODUCTIVE_DROPPED_FROM_OVERREACHING"
	RECOVERYAFTEROVERREACHING         CardioLoadStatusEnum = "RECOVERY_AFTER_OVERREACHING"
	UNRECOGNIZED                      CardioLoadStatusEnum = "UNRECOGNIZED"
)

// Defines values for CircadianBedtimeQuality.
const (
	CIRCADIANBEDTIMEQUALITYCLEARLYRECOGNIZABLE CircadianBedtimeQuality = "CIRCADIAN_BEDTIME_QUALITY_CLEARLY_RECOGNIZABLE"
	CIRCADIANBEDTIMEQUALITYCOMPROMISED         CircadianBedtimeQuality = "CIRCADIAN_BEDTIME_QUALITY_COMPROMISED"
	CIRCADIANBEDTIMEQUALITYUNKNOWN             CircadianBedtimeQuality = "CIRCADIAN_BEDTIME_QUALITY_UNKNOWN"
	CIRCADIANBEDTIMEQUALITYWEAK                CircadianBedtimeQuality = "CIRCADIAN_BEDTIME_QUALITY_WEAK"
)

// Defines values for CircadianBedtimeResultType.
const (
	CIRCADIANBEDTIMETYPEHISTORY    CircadianBedtimeResultType = "CIRCADIAN_BEDTIME_TYPE_HISTORY"
	CIRCADIANBEDTIMETYPEPREDICTION CircadianBedtimeResultType = "CIRCADIAN_BEDTIME_TYPE_PREDICTION"
	CIRCADIANBEDTIMETYPEUNKNOWN    CircadianBedtimeResultType = "CIRCADIAN_BEDTIME_TYPE_UNKNOWN"
)

// Defines values for CircadianBedtimeValidity.
const (
	VALIDITYESTIMATE CircadianBedtimeValidity = "VALIDITY_ESTIMATE"
	VALIDITYNOTVALID CircadianBedtimeValidity = "VALIDITY_NOT_VALID"
	VALIDITYRESET    CircadianBedtimeValidity = "VALIDITY_RESET"
	VALIDITYUNKNOWN  CircadianBedtimeValidity = "VALIDITY_UNKNOWN"
	VALIDITYVALID    CircadianBedtimeValidity = "VALIDITY_VALID"
)

// Defines values for EcgTestResultHeartRateVariabilityLevel.
const (
	ECGHRVLEVELABOVEUSUAL EcgTestResultHeartRateVariabilityLevel = "ECG_HRV_LEVEL_ABOVE_USUAL"
	ECGHRVLEVELBELOWUSUAL EcgTestResultHeartRateVariabilityLevel = "ECG_HRV_LEVEL_BELOW_USUAL"
	ECGHRVLEVELNOBASELINE EcgTestResultHeartRateVariabilityLevel = "ECG_HRV_LEVEL_NO_BASELINE"
	ECGHRVLEVELUSUAL      EcgTestResultHeartRateVariabilityLevel = "ECG_HRV_LEVEL_USUAL"
)

// Defines values for PhysicalInformationWeightSource.
const (
	SOURCEMEASURED PhysicalInformationWeightSource = "SOURCE_MEASURED"
	SOURCEUSER     PhysicalInformationWeightSource = "SOURCE_USER"
)

// Defines values for QualityMeasurementQualityLevel.
const (
	ECGQUALITYHIGH      QualityMeasurementQualityLevel = "ECG_QUALITY_HIGH"
	ECGQUALITYLOW       QualityMeasurementQualityLevel = "ECG_QUALITY_LOW"
	ECGQUALITYNOCONTACT QualityMeasurementQualityLevel = "ECG_QUALITY_NO_CONTACT"
	ECGQUALITYUNKNOWN   QualityMeasurementQualityLevel = "ECG_QUALITY_UNKNOWN"
)

// Defines values for Spo2TestResultSpo2Class.
const (
	SPO2CLASSLOW     Spo2TestResultSpo2Class = "SPO2_CLASS_LOW"
	SPO2CLASSNORMAL  Spo2TestResultSpo2Class = "SPO2_CLASS_NORMAL"
	SPO2CLASSUNKNOWN Spo2TestResultSpo2Class = "SPO2_CLASS_UNKNOWN"
	SPO2CLASSVERYLOW Spo2TestResultSpo2Class = "SPO2_CLASS_VERY_LOW"
)

// Defines values for Spo2TestResultSpo2HrvDeviationFromBaseline.
const (
	Spo2TestResultSpo2HrvDeviationFromBaselineDEVIATIONABOVEUSUAL Spo2TestResultSpo2HrvDeviationFromBaseline = "DEVIATION_ABOVE_USUAL"
	Spo2TestResultSpo2HrvDeviationFromBaselineDEVIATIONBELOWUSUAL Spo2TestResultSpo2HrvDeviationFromBaseline = "DEVIATION_BELOW_USUAL"
	Spo2TestResultSpo2HrvDeviationFromBaselineDEVIATIONNOBASELINE Spo2TestResultSpo2HrvDeviationFromBaseline = "DEVIATION_NO_BASELINE"
	Spo2TestResultSpo2HrvDeviationFromBaselineDEVIATIONUSUAL      Spo2TestResultSpo2HrvDeviationFromBaseline = "DEVIATION_USUAL"
)

// Defines values for Spo2TestResultSpo2ValueDeviationFromBaseline.
const (
	Spo2TestResultSpo2ValueDeviationFromBaselineDEVIATIONABOVEUSUAL Spo2TestResultSpo2ValueDeviationFromBaseline = "DEVIATION_ABOVE_USUAL"
	Spo2TestResultSpo2ValueDeviationFromBaselineDEVIATIONBELOWUSUAL Spo2TestResultSpo2ValueDeviationFromBaseline = "DEVIATION_BELOW_USUAL"
	Spo2TestResultSpo2ValueDeviationFromBaselineDEVIATIONNOBASELINE Spo2TestResultSpo2ValueDeviationFromBaseline = "DEVIATION_NO_BASELINE"
	Spo2TestResultSpo2ValueDeviationFromBaselineDEVIATIONUSUAL      Spo2TestResultSpo2ValueDeviationFromBaseline = "DEVIATION_USUAL"
)

// Defines values for Spo2TestResultTestStatus.
const (
	SPO2TESTINCONCLUSIVETOOLOWOVERALLQUALITY   Spo2TestResultTestStatus = "SPO2_TEST_INCONCLUSIVE_TOO_LOW_OVERALL_QUALITY"
	SPO2TESTINCONCLUSIVETOOLOWQUALITYINSAMPLES Spo2TestResultTestStatus = "SPO2_TEST_INCONCLUSIVE_TOO_LOW_QUALITY_IN_SAMPLES"
	SPO2TESTINCONCLUSIVETOOMANYMISSINGSAMPLES  Spo2TestResultTestStatus = "SPO2_TEST_INCONCLUSIVE_TOO_MANY_MISSING_SAMPLES"
	SPO2TESTPASSED                             Spo2TestResultTestStatus = "SPO2_TEST_PASSED"
)

// Defines values for TrainingLoadProLoadEnum.
const (
	TrainingLoadProLoadEnumHIGH         TrainingLoadProLoadEnum = "HIGH"
	TrainingLoadProLoadEnumLOW          TrainingLoadProLoadEnum = "LOW"
	TrainingLoadProLoadEnumMEDIUM       TrainingLoadProLoadEnum = "MEDIUM"
	TrainingLoadProLoadEnumNOTAVAILABLE TrainingLoadProLoadEnum = "NOT_AVAILABLE"
	TrainingLoadProLoadEnumUNKNOWN      TrainingLoadProLoadEnum = "UNKNOWN"
	TrainingLoadProLoadEnumVERYHIGH     TrainingLoadProLoadEnum = "VERY_HIGH"
	TrainingLoadProLoadEnumVERYLOW      TrainingLoadProLoadEnum = "VERY_LOW"
)

// Defines values for TrainingLoadProRpeEnum.
const (
	TrainingLoadProRpeEnumRPEBRISK       TrainingLoadProRpeEnum = "RPE_BRISK"
	TrainingLoadProRpeEnumRPEEASY        TrainingLoadProRpeEnum = "RPE_EASY"
	TrainingLoadProRpeEnumRPEEXHAUSTING  TrainingLoadProRpeEnum = "RPE_EXHAUSTING"
	TrainingLoadProRpeEnumRPEEXTREME     TrainingLoadProRpeEnum = "RPE_EXTREME"
	TrainingLoadProRpeEnumRPEFAIRLYBRISK TrainingLoadProRpeEnum = "RPE_FAIRLY_BRISK"
	TrainingLoadProRpeEnumRPEFAIRLYHARD  TrainingLoadProRpeEnum = "RPE_FAIRLY_HARD"
	TrainingLoadProRpeEnumRPEHARD        TrainingLoadProRpeEnum = "RPE_HARD"
	TrainingLoadProRpeEnumRPELIGHT       TrainingLoadProRpeEnum = "RPE_LIGHT"
	TrainingLoadProRpeEnumRPEMODERATE    TrainingLoadProRpeEnum = "RPE_MODERATE"
	TrainingLoadProRpeEnumRPENONE        TrainingLoadProRpeEnum = "RPE_NONE"
	TrainingLoadProRpeEnumUNKNOWN        TrainingLoadProRpeEnum = "UNKNOWN"
)

// Defines values for UserGender.
const (
	FEMALE UserGender = "FEMALE"
	MALE   UserGender = "MALE"
)

// Defines values for WebhookType.
const (
	EXERCISESLEEPCONTINUOUSHEARTRATESLEEPWISECIRCADIANBEDTIMESLEEPWISEALERTNESSACTIVITYSUMMARY WebhookType = "EXERCISE, SLEEP, CONTINUOUS_HEART_RATE, SLEEP_WISE_CIRCADIAN_BEDTIME, SLEEP_WISE_ALERTNESS, ACTIVITY_SUMMARY"
)

// AvailableUserData Model contains information of the data available.
type AvailableUserData struct {
	// DataType Type of available data.
	DataType *AvailableUserDataDataType `json:"data-type,omitempty"`

	// Url URI pointing to transaction initiation endpoint for user
	Url *string `json:"url,omitempty"`

	// UserId User identifier who has available data.
	UserId *int64 `json:"user-id,omitempty"`
}

// AvailableUserDataDataType Type of available data.
type AvailableUserDataDataType string

// DurationZone Model contains the time spent in certain activity zone.
type DurationZone struct {
	// Index Activity zone index
	Index *int32 `json:"index,omitempty"`

	// Inzone Time duration spent in the zone ISO 8601
	Inzone *string `json:"inzone,omitempty"`
}

// HeartRate Heart-rate statistics information
type HeartRate struct {
	// Average Average heart-rate
	Average *int32 `json:"average,omitempty"`

	// Maximum Maximum heart-rate
	Maximum *int32 `json:"maximum,omitempty"`
}

// UserExtraInfo User's answers to the custom extra-info fields requested by partners
type UserExtraInfo struct {
	// Index Item index
	Index *int32 `json:"index,omitempty"`

	// Name Name of the extra info asked from customer
	Name *string `json:"name,omitempty"`

	// Value Value provided by the customer
	Value *string `json:"value,omitempty"`
}

// Activity Summary of user's daily activity
type Activity struct {
	// ActiveCalories Total daily calories not including BMR. Precise calculation requires that user's physical data is entered into Polar Flow
	ActiveCalories *int32 `json:"active-calories,omitempty"`

	// ActiveSteps You could consider this as a kind of activity unit. If you take one step the active-steps should increase by one and any activity comparable to one physical step would also increase the number by one
	ActiveSteps *int32 `json:"active-steps,omitempty"`

	// Calories Total daily calories in kilo calories including BMR
	Calories *int32 `json:"calories,omitempty"`

	// Created The time activity summary was created in AccessLink, in format YYYY-MM-DDTHH:mm:ss.SSS
	Created *string `json:"created,omitempty"`

	// Date Date when activity summary was recorded, in format YYYY-MM-DD
	Date *string `json:"date,omitempty"`

	// Duration The time interval as specified in ISO 8601
	Duration *string `json:"duration,omitempty"`

	// Id Activity summary id
	Id *int64 `json:"id,omitempty"`

	// PolarUser Absolute link to user owning the activity
	PolarUser *string `json:"polar-user,omitempty"`

	// TransactionId Id of the activity-transaction this training was transferred in
	TransactionId *int64 `json:"transaction-id,omitempty"`
}

// ActivityDayWithSamples Activity day samples.
type ActivityDayWithSamples struct {
	ActivityZones *ActivityZoneSamples2 `json:"activity_zones,omitempty"`

	// Date Activity day date
	Date             *string `json:"date,omitempty"`
	InactivityStamps *[]struct {
		// Stamp time of inactivity stamp
		Stamp *string `json:"stamp,omitempty"`
	} `json:"inactivity_stamps,omitempty"`

	// Steps Activity step samples for a day. Contains total number of steps and list of individual step samples with time and number of steps in that time period. Note that consecutive repeated (same steps count) samples are filtered out from the list to reduce the payload size. If time between two consecutive samples is larger than interval_ms, one or more samples have been filtered out.
	Steps *ActivitySteps2 `json:"steps,omitempty"`
}

// ActivityLog Activity transaction container
type ActivityLog struct {
	// ActivityLog Absolute links to individual activity summaries within the transaction
	ActivityLog *[]string `json:"activity-log,omitempty"`
}

// ActivityStepSample Model contains number of steps in certain time period.
type ActivityStepSample struct {
	// Steps Number of steps in sample segment. If element is null, step samples are not available for current segment.
	Steps *int32 `json:"steps,omitempty"`

	// Time Start time of sample segment.
	Time *string `json:"time,omitempty"`
}

// ActivityStepSample2 Model contains number of steps in certain time period.
type ActivityStepSample2 struct {
	// Steps Number of steps in sample segment.
	Steps *int32 `json:"steps,omitempty"`

	// Timestamp Start time of sample segment.
	Timestamp *string `json:"timestamp,omitempty"`
}

// ActivityStepSamples Wrapper model for partner step samples.
type ActivityStepSamples struct {
	// Date Activity step sample date
	Date *string `json:"date,omitempty"`

	// Interval Sample interval in minutes.
	Interval *int32 `json:"interval,omitempty"`

	// Samples List of individual step sample objects.
	Samples *[]ActivityStepSample `json:"samples,omitempty"`
}

// ActivitySteps2 Activity step samples for a day. Contains total number of steps and list of individual step samples with time and number of steps in that time period. Note that consecutive repeated (same steps count) samples are filtered out from the list to reduce the payload size. If time between two consecutive samples is larger than interval_ms, one or more samples have been filtered out.
type ActivitySteps2 struct {
	// IntervalMs Sample interval in milliseconds.
	IntervalMs *int32 `json:"interval_ms,omitempty"`

	// Samples List of individual step sample objects.
	Samples *[]ActivityStepSample2 `json:"samples,omitempty"`

	// TotalSteps Total number of steps in activity day.
	TotalSteps *int32 `json:"total_steps,omitempty"`
}

// ActivitySummaryWithAllSamples Activity days with all samples.
type ActivitySummaryWithAllSamples struct {
	// ActiveCalories Active calories burned during the day, excluding BMR
	ActiveCalories *int32 `json:"active_calories,omitempty"`

	// ActiveDuration The duration of the activity in ISO8601 format
	ActiveDuration *string `json:"active_duration,omitempty"`

	// Calories Total calories burned during the day
	Calories *int32 `json:"calories,omitempty"`

	// DailyActivity Daily activity score / percentage
	DailyActivity *float32 `json:"daily_activity,omitempty"`

	// DistanceFromSteps Distance covered based on steps taken, in meters
	DistanceFromSteps *float32 `json:"distance_from_steps,omitempty"`

	// EndTime End time of the activity in UTC
	EndTime *string `json:"end_time,omitempty"`

	// InactiveDuration The duration of the inactivity in ISO8601 format
	InactiveDuration *string `json:"inactive_duration,omitempty"`

	// InactivityAlertCount Number of inactivity alerts received during the day
	InactivityAlertCount *int32 `json:"inactivity_alert_count,omitempty"`

	// Samples Activity day samples.
	Samples *ActivityDayWithSamples `json:"samples,omitempty"`

	// StartTime Start time of the activity in UTC
	StartTime *string `json:"start_time,omitempty"`

	// Steps Total number of steps taken during the day
	Steps *int32 `json:"steps,omitempty"`
}

// ActivityZoneSample Model contains number of steps in certain time period.
type ActivityZoneSample struct {
	// ActivityZones List of heart rate zones with duration.
	ActivityZones *[]DurationZone `json:"activity-zones,omitempty"`

	// Time Start time of sample segment.
	Time *string `json:"time,omitempty"`
}

// ActivityZoneSample2 defines model for activity-zone-sample2.
type ActivityZoneSample2 struct {
	Timestamp *string `json:"timestamp,omitempty"`

	// Zone Activity zone type.
	Zone *ActivityZoneSample2Zone `json:"zone,omitempty"`
}

// ActivityZoneSample2Zone Activity zone type.
type ActivityZoneSample2Zone string

// ActivityZoneSamples List containing the times (in zone) in different heart rate zones (i.e. Heart rate between lower and upper values). Zone is null if no zone information available.
type ActivityZoneSamples struct {
	// Date Activity zone sample date
	Date *string `json:"date,omitempty"`

	// Interval Sample interval in minutes.
	Interval *int32 `json:"interval,omitempty"`

	// Samples List of individual zone sample objects.
	Samples *[]ActivityZoneSample `json:"samples,omitempty"`
}

// ActivityZoneSamples2 defines model for activity-zone-samples2.
type ActivityZoneSamples2 struct {
	// Samples List of activity zones samples.
	Samples *[]ActivityZoneSample2 `json:"samples,omitempty"`
}

// Alertness Alertness period data
type Alertness struct {
	// Grade Grade
	Grade *float64 `json:"grade,omitempty"`

	// GradeClassification Grade classification
	GradeClassification *AlertnessGradeClassification `json:"grade_classification,omitempty"`

	// GradeType Grade type
	GradeType *AlertnessGradeType `json:"grade_type,omitempty"`

	// GradeValiditySeconds Grade validity seconds
	GradeValiditySeconds *int64 `json:"grade_validity_seconds,omitempty"`

	// HourlyData Alertness hourly data for the alertness period
	HourlyData *[]AlertnessHourlyData `json:"hourly_data,omitempty"`

	// PeriodEndTime Alertness period end time (UTC)
	PeriodEndTime *openapi_types.Date `json:"period_end_time,omitempty"`

	// PeriodStartTime Alertness period start time (UTC)
	PeriodStartTime *openapi_types.Date `json:"period_start_time,omitempty"`

	// ResultType Result type
	ResultType *AlertnessResultType `json:"result_type,omitempty"`

	// SleepInertia Sleep inertia
	SleepInertia *AlertnessSleepInertia `json:"sleep_inertia,omitempty"`

	// SleepPeriodEndTime Sleep period end time (UTC)
	SleepPeriodEndTime *openapi_types.Date `json:"sleep_period_end_time,omitempty"`

	// SleepPeriodStartTime Sleep period start time (UTC)
	SleepPeriodStartTime *openapi_types.Date `json:"sleep_period_start_time,omitempty"`

	// SleepTimezoneOffsetMinutes Sleep timezone offset minutes
	SleepTimezoneOffsetMinutes *int64 `json:"sleep_timezone_offset_minutes,omitempty"`

	// SleepType Sleep type
	SleepType *AlertnessSleepType `json:"sleep_type,omitempty"`

	// Validity Validity
	Validity *AlertnessValidity `json:"validity,omitempty"`
}

// AlertnessGradeClassification Grade classification
type AlertnessGradeClassification string

// AlertnessGradeType Grade type
type AlertnessGradeType string

// AlertnessResultType Result type
type AlertnessResultType string

// AlertnessSleepInertia Sleep inertia
type AlertnessSleepInertia string

// AlertnessSleepType Sleep type
type AlertnessSleepType string

// AlertnessValidity Validity
type AlertnessValidity string

// AlertnessHourlyData Hourly data for the alertness period
type AlertnessHourlyData struct {
	// AlertnessLevel Alertness level
	AlertnessLevel *AlertnessHourlyDataAlertnessLevel `json:"alertness_level,omitempty"`

	// EndTime Alertness period end time (UTC)
	EndTime *openapi_types.Date `json:"end_time,omitempty"`

	// StartTime Alertness period start time (UTC)
	StartTime *openapi_types.Date `json:"start_time,omitempty"`

	// Validity Validity
	Validity *AlertnessHourlyDataValidity `json:"validity,omitempty"`
}

// AlertnessHourlyDataAlertnessLevel Alertness level
type AlertnessHourlyDataAlertnessLevel string

// AlertnessHourlyDataValidity Validity
type AlertnessHourlyDataValidity string

// ArrayOfActivityDayWithSamples Array of activity days with samples. Each item in the array contains a summary of the activity for a specific day, including all samples.
type ArrayOfActivityDayWithSamples = []ActivityDayWithSamples

// ArrayOfActivitySummaryWithAllSamples Array of activity summaries with all samples. Each item in the array contains a summary of the activity for a specific day, including all samples.
type ArrayOfActivitySummaryWithAllSamples = []ActivitySummaryWithAllSamples

// AvailableSleep defines model for available-sleep.
type AvailableSleep struct {
	// Date Result date of the sleep
	Date *openapi_types.Date `json:"date,omitempty"`

	// EndTime End timestamp of the sleep as ISO-8601 datetime string
	EndTime *time.Time `json:"end_time,omitempty"`

	// StartTime Start timestamp of the sleep as ISO-8601 datetime string
	StartTime *time.Time `json:"start_time,omitempty"`
}

// AvailableSleeps defines model for available-sleeps.
type AvailableSleeps struct {
	// Available List of available sleep data
	Available *[]AvailableSleep `json:"available,omitempty"`
}

// AvailableUserDatas AvailableUserDatas is a container model for AvailableUserData.
type AvailableUserDatas struct {
	// AvailableUserData List of available user datas.
	AvailableUserData *[]AvailableUserData `json:"available-user-data,omitempty"`
}

// BodyTemperaturePeriod defines model for body-temperature-period.
type BodyTemperaturePeriod struct {
	// EndTime Measurement period end time (UTC)
	EndTime *time.Time `json:"end_time,omitempty"`

	// MeasurementType Measurement type
	MeasurementType *BodyTemperaturePeriodMeasurementType `json:"measurement_type,omitempty"`

	// ModifiedTime Measurement period modified time (UTC)
	ModifiedTime *time.Time               `json:"modified_time,omitempty"`
	Samples      *[]BodyTemperatureSample `json:"samples,omitempty"`

	// SensorLocation Sensor location
	SensorLocation *BodyTemperaturePeriodSensorLocation `json:"sensor_location,omitempty"`
	SourceDeviceId *string                              `json:"source_device_id,omitempty"`

	// StartTime Measurement period start time (UTC)
	StartTime *time.Time `json:"start_time,omitempty"`
}

// BodyTemperaturePeriodMeasurementType Measurement type
type BodyTemperaturePeriodMeasurementType string

// BodyTemperaturePeriodSensorLocation Sensor location
type BodyTemperaturePeriodSensorLocation string

// BodyTemperatureSample defines model for body-temperature-sample.
type BodyTemperatureSample struct {
	RecordingTimeDeltaMilliseconds *int64   `json:"recording_time_delta_milliseconds,omitempty"`
	TemperatureCelsius             *float32 `json:"temperature_celsius,omitempty"`
}

// CardioLoad Cardio load model.
type CardioLoad struct {
	// CardioLoad Cardio load (training impulse, TRIMP) shows your cardiac response to a training session.
	CardioLoad *float32 `json:"cardio_load,omitempty"`

	// CardioLoadLevel Cardio load levels indicate how hard a training session was compared to your session average from the past 90 days.
	CardioLoadLevel *CardioLoadLevels `json:"cardio_load_level,omitempty"`

	// CardioLoadRatio Ratio between strain and tolerance.
	CardioLoadRatio *float32 `json:"cardio_load_ratio,omitempty"`

	// CardioLoadStatus Text representation of cardio load status.
	CardioLoadStatus *CardioLoadStatusEnum `json:"cardio_load_status,omitempty"`

	// Date Date in format YYYY-MM-DD.
	Date *openapi_types.Date `json:"date,omitempty"`

	// Strain Strain shows how much you have strained yourself with training lately. It shows your average daily load from the past 7 days.
	Strain *float32 `json:"strain,omitempty"`

	// Tolerance Tolerance describes how prepared you are to endure cardio training. It shows your average daily load from the past 28 days.
	Tolerance *float32 `json:"tolerance,omitempty"`
}

// CardioLoadLevels Cardio load levels indicate how hard a training session was compared to your session average from the past 90 days.
type CardioLoadLevels struct {
	High     *float32 `json:"high,omitempty"`
	Low      *float32 `json:"low,omitempty"`
	Medium   *float32 `json:"medium,omitempty"`
	VeryHigh *float32 `json:"very-high,omitempty"`
	VeryLow  *float32 `json:"very_low,omitempty"`
}

// CardioLoadSchema List of cardio loads.
type CardioLoadSchema = []CardioLoad

// CardioLoadStatusEnum Text representation of cardio load status.
type CardioLoadStatusEnum string

// CircadianBedtime Circadian bedtime period data
type CircadianBedtime struct {
	// PeriodEndTime Circadian bedtime period end time (UTC)
	PeriodEndTime *openapi_types.Date `json:"period_end_time,omitempty"`

	// PeriodStartTime Circadian bedtime period start time (UTC)
	PeriodStartTime *openapi_types.Date `json:"period_start_time,omitempty"`

	// PreferredSleepPeriodEndTime Circadian bedtime preferred sleep period end time (UTC)
	PreferredSleepPeriodEndTime *openapi_types.Date `json:"preferred_sleep_period_end_time,omitempty"`

	// PreferredSleepPeriodStartTime Circadian bedtime preferred sleep period start time (UTC)
	PreferredSleepPeriodStartTime *openapi_types.Date `json:"preferred_sleep_period_start_time,omitempty"`

	// Quality Quality
	Quality *CircadianBedtimeQuality `json:"quality,omitempty"`

	// ResultType Result type
	ResultType *CircadianBedtimeResultType `json:"result_type,omitempty"`

	// SleepGateEndTime Circadian bedtime sleep gate (suggested fall a sleep window) end time (UTC)
	SleepGateEndTime *openapi_types.Date `json:"sleep_gate_end_time,omitempty"`

	// SleepGateStartTime Circadian bedtime sleep gate (suggested fall a sleep window) start time (UTC)
	SleepGateStartTime *openapi_types.Date `json:"sleep_gate_start_time,omitempty"`

	// SleepTimezoneOffsetMinutes Sleep timezone offset minutes
	SleepTimezoneOffsetMinutes *int64 `json:"sleep_timezone_offset_minutes,omitempty"`

	// Validity Validity
	Validity *CircadianBedtimeValidity `json:"validity,omitempty"`
}

// CircadianBedtimeQuality Quality
type CircadianBedtimeQuality string

// CircadianBedtimeResultType Result type
type CircadianBedtimeResultType string

// CircadianBedtimeValidity Validity
type CircadianBedtimeValidity string

// ContinuousHeartrate 5 min average samples of heart rate from the duration of the continuous heart rate measurement. Default  time between samples is 5 minutes. There may be periods with samples more often than every 5 minutes.  Unit of samples is beats per minute (bpm).
type ContinuousHeartrate struct {
	// Date Result date of the Continuous Heart Rate
	Date             *openapi_types.Date `json:"date,omitempty"`
	HeartRateSamples *struct {
		// HeartRate heart rate rpm
		HeartRate *int `json:"heart_rate,omitempty"`

		// SampleTime Measurement time of heart rate. Device time used for measurement
		SampleTime *openapi_types.Date `json:"sample_time,omitempty"`
	} `json:"heart_rate_samples,omitempty"`

	// PolarUser Absolute link to user owning the continuous heart rate samples
	PolarUser *string `json:"polar_user,omitempty"`
}

// CreatedWebhook defines model for createdWebhook.
type CreatedWebhook struct {
	Data *struct {
		// Events Subscribed event types.
		Events *[]WebhookType `json:"events,omitempty"`

		// Id Id of the new webhook.
		Id *string `json:"id,omitempty"`

		// SignatureSecretKey Signing key for verifying that sender is actually Polar.
		SignatureSecretKey *string `json:"signature_secret_key,omitempty"`

		// Url Url where the webhook notification is sent.
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// EcgSample defines model for ecg-sample.
type EcgSample struct {
	AmplitudeMv          *float32 `json:"amplitude_mv,omitempty"`
	RecordingTimeDeltaMs *int32   `json:"recording_time_delta_ms,omitempty"`
}

// EcgTestResult defines model for ecg-test-result.
type EcgTestResult struct {
	AverageHeartRateBpm          *uint32                                 `json:"average_heart_rate_bpm,omitempty"`
	HeartRateVariabilityLevel    *EcgTestResultHeartRateVariabilityLevel `json:"heart_rate_variability_level,omitempty"`
	HeartRateVariabilityMs       *float32                                `json:"heart_rate_variability_ms,omitempty"`
	PulseTransitTimeDiastolicMs  *float32                                `json:"pulse_transit_time_diastolic_ms,omitempty"`
	PulseTransitTimeQualityIndex *float32                                `json:"pulse_transit_time_quality_index,omitempty"`
	PulseTransitTimeSystolicMs   *float32                                `json:"pulse_transit_time_systolic_ms,omitempty"`
	QualityMeasurements          *[]QualityMeasurement                   `json:"quality_measurements,omitempty"`
	RriMs                        *float32                                `json:"rri_ms,omitempty"`
	Samples                      *[]EcgSample                            `json:"samples,omitempty"`
	SourceDeviceId               *string                                 `json:"source_device_id,omitempty"`
	TestTime                     *int64                                  `json:"test_time,omitempty"`
	TimeZoneOffset               *int32                                  `json:"time_zone_offset,omitempty"`
}

// EcgTestResultHeartRateVariabilityLevel defines model for EcgTestResult.HeartRateVariabilityLevel.
type EcgTestResultHeartRateVariabilityLevel string

// Error Error model which contains useful info about the error occurred.
type Error struct {
	// CorrId Correlation id of the response for problem solving and debugging use.
	CorrId *string `json:"corrId,omitempty"`

	// ErrorType Error type.
	ErrorType *string `json:"errorType,omitempty"`

	// Message Human readable error message.
	Message *string `json:"message,omitempty"`

	// Status Http status code
	Status *int `json:"status,omitempty"`

	// Timestamp Timestamp of the error.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// Exercise Training session summary data
type Exercise struct {
	// Calories Expended calories during training in kilocalories
	Calories *int32 `json:"calories,omitempty"`

	// CarbohydratePercentage Carbohydrate percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	CarbohydratePercentage *int32 `json:"carbohydrate-percentage,omitempty"`

	// ClubId Has value if the exercise is from "Flow For Club", otherwise not printed. Value -1 indicates that there were errors finding the club
	ClubId *int64 `json:"club-id,omitempty"`

	// ClubName Has value if the exercise is from "Flow For Club", otherwise not printed. Value "Ambiguous club location. Please contact support." is printed in case of error (and the club-id is -1).
	ClubName *string `json:"club-name,omitempty"`

	// DetailedSportInfo String containing the name of a Polar Flow-compatible sport, if one is set for the exercise.
	DetailedSportInfo *string `json:"detailed-sport-info,omitempty"`

	// Device Polar product used in training
	Device *string `json:"device,omitempty"`

	// DeviceId Id of the Polar device
	DeviceId *string `json:"device-id,omitempty"`

	// Distance Distance in meters travelled during training
	Distance *float32 `json:"distance,omitempty"`

	// Duration The duration of the training session as specified in ISO8601
	Duration *string `json:"duration,omitempty"`

	// FatPercentage Fat percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	FatPercentage *int32 `json:"fat-percentage,omitempty"`

	// HasRoute Boolean indicating if the exercise has route data
	HasRoute *bool `json:"has-route,omitempty"`

	// HeartRate Heart-rate statistics information
	HeartRate *HeartRate `json:"heart-rate,omitempty"`

	// Id Id of the training session
	Id *int64 `json:"id,omitempty"`

	// PolarUser Absolute link to Polar user owning the training
	PolarUser *string `json:"polar-user,omitempty"`

	// ProteinPercentage Protein percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	ProteinPercentage *int32 `json:"protein-percentage,omitempty"`

	// RunningIndex <a href="https://support.polar.com/en/support/tips/Running_Index_feature#">  Running index</a> is a score automatically calculated every run based on your  heart rate and speed data collected via GPS or stride sensor.
	RunningIndex *int32 `json:"running-index,omitempty"`

	// Sport Sport name
	Sport *string `json:"sport,omitempty"`

	// StartTime Start time of the training session in local time
	StartTime *string `json:"start-time,omitempty"`

	// StartTimeUtcOffset The offset from UTC (in minutes) when the training session was started
	StartTimeUtcOffset *int32 `json:"start-time-utc-offset,omitempty"`

	// TrainingLoad Training load effect to user
	TrainingLoad    *float32               `json:"training-load,omitempty"`
	TrainingLoadPro *TrainingLoadProSample `json:"training-load-pro,omitempty"`

	// TransactionId Id of the exercise-transaction this training was transferred in
	TransactionId *int64 `json:"transaction-id,omitempty"`

	// UploadTime Time of the transfer from wrist unit to Polar database
	UploadTime *string `json:"upload-time,omitempty"`
}

// ExerciseHashId Training session summary data
type ExerciseHashId struct {
	// Calories Expended calories during training in kilocalories
	Calories *int32 `json:"calories,omitempty"`

	// CarbohydratePercentage Carbohydrate percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	CarbohydratePercentage *int32 `json:"carbohydrate_percentage,omitempty"`

	// ClubId Has value if the exercise is from "Flow For Club", otherwise not printed. Value -1 indicates that there were errors finding the club
	ClubId *int64 `json:"club_id,omitempty"`

	// ClubName Has value if the exercise is from "Flow For Club", otherwise not printed. Value "Ambiguous club location. Please contact support." is printed in case of error (and the club-id is -1).
	ClubName *string `json:"club_name,omitempty"`

	// DetailedSportInfo String containing the name of a Polar Flow-compatible sport, if one is set for the exercise.
	DetailedSportInfo *string `json:"detailed_sport_info,omitempty"`

	// Device Polar product used in training
	Device *string `json:"device,omitempty"`

	// DeviceId Id of the Polar device
	DeviceId *string `json:"device_id,omitempty"`

	// Distance Distance in meters travelled during training
	Distance *float32 `json:"distance,omitempty"`

	// Duration The duration of the training session as specified in ISO8601
	Duration *string `json:"duration,omitempty"`

	// FatPercentage Fat percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	FatPercentage *int32 `json:"fat_percentage,omitempty"`

	// HasRoute Boolean indicating if the exercise has route data
	HasRoute *bool `json:"has_route,omitempty"`

	// HeartRate Heart-rate statistics information
	HeartRate *HeartRate `json:"heart_rate,omitempty"`

	// HeartRateZones Heart rate zones for this exercise. Returned when query parameter 'zones=true' is used.
	HeartRateZones *[]Zone `json:"heart_rate_zones,omitempty"`

	// Id Hashed id of the training session
	Id *string `json:"id,omitempty"`

	// PolarUser Absolute link to Polar user owning the training
	PolarUser *string `json:"polar_user,omitempty"`

	// ProteinPercentage Protein percentage of exercise calories. Has value if the exercise is from training device supporting Energy sources, otherwise not printed.
	ProteinPercentage *int32 `json:"protein_percentage,omitempty"`

	// Route List of all route points/locations available for this exercise. Returned when query parameter 'route=true' is used.
	Route *[]Location `json:"route,omitempty"`

	// RunningIndex <a href="https://support.polar.com/en/support/tips/Running_Index_feature#"> Running index</a> is a score automatically calculated every run based on your heart rate and speed data collected via GPS or stride sensor.
	RunningIndex *int32 `json:"running-index,omitempty"`

	// Samples List of all samples available for this exercise. Returned when query parameter 'samples=true' is used.
	Samples *[]Sample `json:"samples,omitempty"`

	// Sport Sport name
	Sport *string `json:"sport,omitempty"`

	// StartTime Start time of the training session in local time
	StartTime *string `json:"start_time,omitempty"`

	// StartTimeUtcOffset The offset from UTC (in minutes) when the training session was started
	StartTimeUtcOffset *int32 `json:"start_time_utc_offset,omitempty"`

	// TrainingLoad Training load effect to user
	TrainingLoad    *float32               `json:"training_load,omitempty"`
	TrainingLoadPro *TrainingLoadProSample `json:"training_load_pro,omitempty"`

	// UploadTime Time of the transfer from wrist unit to Polar database
	UploadTime *string `json:"upload_time,omitempty"`
}

// Exercises Exercise transaction container
type Exercises struct {
	// Exercises Absolute links to individual exercises within the transaction
	Exercises *[]string `json:"exercises,omitempty"`
}

// ExercisesHashId List of exercises.
type ExercisesHashId = []ExerciseHashId

// Location Exercise route point/location.
type Location struct {
	// Fix Fix. A byte-sized value with a maximum of three.
	Fix *int64 `json:"fix,omitempty"`

	// Latitude The latitude, expressed in degrees.
	Latitude *float64 `json:"latitude,omitempty"`

	// Longitude The longitude, expressed in degrees.
	Longitude *float64 `json:"longitude,omitempty"`

	// Satellites Satellites. A byte-sized value with a maximum of 63.
	Satellites *int64 `json:"satellites,omitempty"`

	// Time The time, expressed as a duration.
	Time *string `json:"time,omitempty"`
}

// NightlyRecharge defines model for nightly-recharge.
type NightlyRecharge struct {
	// AnsCharge ANS stands for autonomic nervous system. ANS charge is formed by measuring heart rate, heart rate variability and breathing rate during roughly the first four hours of your sleep. It is formed comparing your last night to your usual levels from the past 28 days. The scale is from -10.0 to +10.0. Around zero is your usual level.
	AnsCharge *float32 `json:"ans_charge,omitempty"`

	// AnsChargeStatus ANS charge status = much below usual (1) - below usual (2) - usual (3) - above usual (4) - much above usual (5)
	AnsChargeStatus *int32 `json:"ans_charge_status,omitempty"`

	// BeatToBeatAvg Average time in milliseconds (ms) between successive heart beats during a 4-hour period starting at 30 minutes after falling asleep.
	BeatToBeatAvg *int32 `json:"beat_to_beat_avg,omitempty"`

	// BreathingRateAvg Average breathing rate as breaths per minute (bpm) during a 4-hour period starting at 30 minutes after falling asleep.
	BreathingRateAvg *float32 `json:"breathing_rate_avg,omitempty"`

	// BreathingSamples 5-minute average samples of breathing rate. Unit of samples is breaths per minute (bpm).
	BreathingSamples *map[string]interface{} `json:"breathing_samples,omitempty"`

	// Date Result date of the Nightly Recharge
	Date *openapi_types.Date `json:"date,omitempty"`

	// HeartRateAvg Average heart rate as beats per minute (bpm) during a 4-hour period starting at 30 minutes after falling asleep.
	HeartRateAvg *int32 `json:"heart_rate_avg,omitempty"`

	// HeartRateVariabilityAvg Average variation in the time in milliseconds (ms) between successive heart beats during a 4-hour period starting at 30 minutes after falling asleep. The Heart rate variability is Root Mean Square of Successive Differences (RMSSD) in beat-to-beat intervals.
	HeartRateVariabilityAvg *int32 `json:"heart_rate_variability_avg,omitempty"`

	// HrvSamples 5-minute average samples of heart rate variability. Unit of samples is milliseconds(ms).
	HrvSamples *map[string]interface{} `json:"hrv_samples,omitempty"`

	// NightlyRechargeStatus The Nightly Recharge status shows how your body was able to recover from training and stress during the night. Scores for both ANS charge and sleep charge are taken into account. Nightly Recharge status has the following (6-item) scale: very poor (1) – poor (2) – compromised (3) – OK (4) – good (5) – very good (6).
	NightlyRechargeStatus *int32 `json:"nightly_recharge_status,omitempty"`

	// PolarUser Absolute link to user owning the sleep
	PolarUser *string `json:"polar_user,omitempty"`
}

// Nights Sleep list
type Nights struct {
	// Nights List of sleep objects
	Nights *[]Sleep `json:"nights,omitempty"`
}

// PhysicalInformation User's physical information
type PhysicalInformation struct {
	// AerobicThreshold Aerobic threshold
	AerobicThreshold *int32 `json:"aerobic-threshold,omitempty"`

	// AnaerobicThreshold Anaerobic threshold
	AnaerobicThreshold *int32 `json:"anaerobic-threshold,omitempty"`

	// Created The time physical information was created in AccessLink, in format YYYY-MM-DDTHH:mm:ss.SSSZ
	Created *string `json:"created,omitempty"`

	// Height Height
	Height *float32 `json:"height,omitempty"`

	// Id Physical information id
	Id *int64 `json:"id,omitempty"`

	// MaximumHeartRate Maximum heart rate
	MaximumHeartRate *int32 `json:"maximum-heart-rate,omitempty"`

	// PolarUser Absolute link to user owning the activity
	PolarUser *string `json:"polar-user,omitempty"`

	// RestingHeartRate Resting hear rate
	RestingHeartRate *int32 `json:"resting-heart-rate,omitempty"`

	// TransactionId Id of the physical-information-transaction this training was transferred in
	TransactionId *int64 `json:"transaction-id,omitempty"`

	// Vo2Max VO2 max
	Vo2Max *int32 `json:"vo2-max,omitempty"`

	// Weight Weight
	Weight *float32 `json:"weight,omitempty"`

	// WeightSource Weight source
	WeightSource *PhysicalInformationWeightSource `json:"weight-source,omitempty"`
}

// PhysicalInformationWeightSource Weight source
type PhysicalInformationWeightSource string

// PhysicalInformations Physical information transaction container
type PhysicalInformations struct {
	// PhysicalInformations Absolute links to individual physical information within the transaction
	PhysicalInformations *[]string `json:"physical-informations,omitempty"`
}

// QualityMeasurement defines model for quality-measurement.
type QualityMeasurement struct {
	QualityLevel         *QualityMeasurementQualityLevel `json:"quality_level,omitempty"`
	RecordingTimeDeltaMs *int32                          `json:"recording_time_delta_ms,omitempty"`
}

// QualityMeasurementQualityLevel defines model for QualityMeasurement.QualityLevel.
type QualityMeasurementQualityLevel string

// Recharges Nightly Recharge list
type Recharges struct {
	// Recharges List of Nightly Recharge objects
	Recharges *[]NightlyRecharge `json:"recharges,omitempty"`
}

// Register Model for registering user to partner.
type Register struct {
	// MemberId Partner's custom identifier for user.
	MemberId string `json:"member-id"`
}

// Sample Training session sample data
type Sample struct {
	// Data Sample values as a comma-separated list of strings. Can contain null -values which indicate a situation where sensor was offline.
	Data *string `json:"data,omitempty"`

	// RecordingRate Sample recording rate in seconds. Null when recording rate is not applicable - currently only with RR-data.
	RecordingRate *int32 `json:"recording-rate,omitempty"`

	// SampleType Sample type
	SampleType *[]byte `json:"sample-type,omitempty"`
}

// Samples List of URIs pointing to single sample type data.
type Samples struct {
	// Samples List of URIs pointing to single sample type data.
	Samples *[]string `json:"samples,omitempty"`
}

// SkinContactChange defines model for skin-contact-change.
type SkinContactChange struct {
	RecordingTimeDeltaMilliseconds *int64 `json:"recording_time_delta_milliseconds,omitempty"`
	SkinContact                    *bool  `json:"skin_contact,omitempty"`
}

// SkinContactPeriod defines model for skin-contact-period.
type SkinContactPeriod struct {
	// EndTime Measurement period end time (UTC)
	EndTime *time.Time `json:"end_time,omitempty"`

	// ModifiedTime Measurement period modified time (UTC)
	ModifiedTime       *time.Time           `json:"modified_time,omitempty"`
	SkinContactChanges *[]SkinContactChange `json:"skin_contact_changes,omitempty"`
	SourceDeviceId     *string              `json:"source_device_id,omitempty"`

	// StartTime Measurement period start time (UTC)
	StartTime *time.Time `json:"start_time,omitempty"`
}

// SkinTemperature defines model for skin-temperature.
type SkinTemperature struct {
	DeviationFromBaselineCelsius    *float32            `json:"deviation_from_baseline_celsius,omitempty"`
	SleepDate                       *openapi_types.Date `json:"sleep_date,omitempty"`
	SleepTimeSkinTemperatureCelsius *float32            `json:"sleep_time_skin_temperature_celsius,omitempty"`
}

// Sleep defines model for sleep.
type Sleep struct {
	// Continuity Continuity is an estimate of how continuous the sleep was on a scale of 1.0 – 5.0, where 5.0 reflects uninterrupted sleep. The lower the value the more fragmented the sleep was.
	Continuity *float32 `json:"continuity,omitempty"`

	// ContinuityClass Verbal assessments of sleep continuity Very continuous sleep (5) Continuous sleep (4) Fairly continuous sleep (3) Fairly fragmented sleep (2) Fragmented sleep (1)
	ContinuityClass *int32 `json:"continuity_class,omitempty"`

	// Date Result date of the sleep
	Date *openapi_types.Date `json:"date,omitempty"`

	// DeepSleep Total time in seconds spent in the deep sleep stage between when you fell asleep and when you woke up. Corresponds to N3 according to AASM classification.
	DeepSleep *int32 `json:"deep_sleep,omitempty"`

	// DeviceId Id of the device the sleep was measured with
	DeviceId *string `json:"device_id,omitempty"`

	// GroupDurationScore Sleep score consists of six components that are grouped under three themes. Score for sleep duration theme looks at your sleep time compared to your ‘preferred sleep time’ setting and the age-related duration recommendations. Group duration score ranges from 1.0 to 100.0. It is interpreted as textual feedback: poor, moderate or good amount.
	GroupDurationScore *float32 `json:"group_duration_score,omitempty"`

	// GroupRegenerationScore Sleep score consists of six components that are grouped under three themes. Score for regeneration theme is the average of the scores of REM sleep and deep sleep. Group regeneration score ranges from 1.0 to 100.0. It is interpreted as textual feedback: poor, moderate or good regeneration
	GroupRegenerationScore *float32 `json:"group_regeneration_score,omitempty"`

	// GroupSolidityScore Sleep score consists of six components that are grouped under three themes. Score for sleep solidity theme is the average of the component scores of long interruptions, continuity and actual sleep. Group solidity score ranges from 1.0 to 100.0. It is interpreted as textual feedback: poor, moderate or good solidity.
	GroupSolidityScore *float32 `json:"group_solidity_score,omitempty"`

	// HeartRateSamples 5 min average samples of heart rate from the duration of the sleep. Default time between samples is 5 minutes. There may be periods with samples more often than every 5 minutes. Unit of samples is beats per minute (bpm).
	HeartRateSamples *map[string]interface{} `json:"heart_rate_samples,omitempty"`

	// Hypnogram The time span between when you fell asleep and when you woke up is classified into light, deep or REM sleep, or unrecognised or wake in 30-s epochs.
	//
	// 0 = WAKE, 1 = REM, 2 = LIGHTER NON-REM, 3 = LIGHT NON-REM, 4 = DEEP NON-REM, 5 = UNKNOWN (eg. due to bad skin contact).
	Hypnogram *map[string]interface{} `json:"hypnogram,omitempty"`

	// LightSleep Total time in seconds spent in light sleep stage between when you fell asleep and when you woke up. Corresponds to N1+ N2 according to AASM classification.
	LightSleep *int32 `json:"light_sleep,omitempty"`

	// LongInterruptionDuration Total time in seconds of long interruptions. Long interruption is interruption in sleep of 90 seconds or more.
	LongInterruptionDuration *int32 `json:"long_interruption_duration,omitempty"`

	// PolarUser Absolute link to user owning the sleep
	PolarUser *string `json:"polar_user,omitempty"`

	// RemSleep Total time in seconds spent in REM sleep stage between when you fell asleep and when you woke up. REM stands for rapid eye movement.
	RemSleep *int32 `json:"rem_sleep,omitempty"`

	// ShortInterruptionDuration Total time in seconds of short interruptions. Short interruption is interruption in sleep of less than 90 seconds.
	ShortInterruptionDuration *int32 `json:"short_interruption_duration,omitempty"`

	// SleepCharge Sleep score compared to your usual level from the past 28 days.Scale: much below usual (1) – below usual (2) – usual (3) – above usual (4) – much above usual(5).
	SleepCharge *int32 `json:"sleep_charge,omitempty"`

	// SleepCycles Number of sleep cycles.
	SleepCycles *int32 `json:"sleep_cycles,omitempty"`

	// SleepEndTime End timestamp of the sleep as ISO-8601 datetime string
	SleepEndTime *time.Time `json:"sleep_end_time,omitempty"`

	// SleepGoal Time goal in seconds for sleep selectedby user. A default value of the setting is based on age-related sleep duration recommendations.
	SleepGoal *int32 `json:"sleep_goal,omitempty"`

	// SleepRating Numeric value given by user for representing the quality of sleep. Selection scale: Very poorly(1), poorly(2), ok(3), well(4), very well(5). 0 means no value is given.
	SleepRating *int32 `json:"sleep_rating,omitempty"`

	// SleepScore Sleep score summarizes the amount and quality of your sleep into a single number on a scale of 1 – 100. Sleep score tells you how well you slept compared to the indicators of a good night's sleep based on the current sleep science. It consists of six components; sleep time, long interruptions, continuity, actual sleep, REM sleep, and deep sleep.
	SleepScore *int32 `json:"sleep_score,omitempty"`

	// SleepStartTime Start timestamp of the sleep as ISO-8601 datetime string
	SleepStartTime *time.Time `json:"sleep_start_time,omitempty"`

	// TotalInterruptionDuration The total time in seconds you spent awake between when you fell asleep and when you woke up.
	TotalInterruptionDuration *int32 `json:"total_interruption_duration,omitempty"`

	// UnrecognizedSleepStage Total time in seconds spent in unrecognised sleep stage. Sometimes it's impossible to recognize sleep stages. This might happen when, for example, the wrist strap is not tight enough, or if you sleep on your hand.
	UnrecognizedSleepStage *int32 `json:"unrecognized_sleep_stage,omitempty"`
}

// Spo2TestResult defines model for spo2-test-result.
type Spo2TestResult struct {
	AltitudeMeters                 *float32                                      `json:"altitude_meters,omitempty"`
	AverageHeartRateBpm            *uint32                                       `json:"average_heart_rate_bpm,omitempty"`
	BloodOxygenPercent             *int32                                        `json:"blood_oxygen_percent,omitempty"`
	HeartRateVariabilityMs         *float32                                      `json:"heart_rate_variability_ms,omitempty"`
	SourceDeviceId                 *string                                       `json:"source_device_id,omitempty"`
	Spo2Class                      *Spo2TestResultSpo2Class                      `json:"spo2_class,omitempty"`
	Spo2HrvDeviationFromBaseline   *Spo2TestResultSpo2HrvDeviationFromBaseline   `json:"spo2_hrv_deviation_from_baseline,omitempty"`
	Spo2QualityAveragePercent      *float32                                      `json:"spo2_quality_average_percent,omitempty"`
	Spo2ValueDeviationFromBaseline *Spo2TestResultSpo2ValueDeviationFromBaseline `json:"spo2_value_deviation_from_baseline,omitempty"`
	TestStatus                     *Spo2TestResultTestStatus                     `json:"test_status,omitempty"`
	TestTime                       *int64                                        `json:"test_time,omitempty"`
	TimeZoneOffset                 *int32                                        `json:"time_zone_offset,omitempty"`
}

// Spo2TestResultSpo2Class defines model for Spo2TestResult.Spo2Class.
type Spo2TestResultSpo2Class string

// Spo2TestResultSpo2HrvDeviationFromBaseline defines model for Spo2TestResult.Spo2HrvDeviationFromBaseline.
type Spo2TestResultSpo2HrvDeviationFromBaseline string

// Spo2TestResultSpo2ValueDeviationFromBaseline defines model for Spo2TestResult.Spo2ValueDeviationFromBaseline.
type Spo2TestResultSpo2ValueDeviationFromBaseline string

// Spo2TestResultTestStatus defines model for Spo2TestResult.TestStatus.
type Spo2TestResultTestStatus string

// TrainingLoadProLoadEnum defines model for training-load-pro-load-enum.
type TrainingLoadProLoadEnum string

// TrainingLoadProRpeEnum Quantifies internal training load of a session.
type TrainingLoadProRpeEnum string

// TrainingLoadProSample defines model for training-load-pro-sample.
type TrainingLoadProSample struct {
	// CardioLoad User cardio load value.
	CardioLoad               *float32                 `json:"cardio-load,omitempty"`
	CardioLoadInterpretation *TrainingLoadProLoadEnum `json:"cardio-load-interpretation,omitempty"`

	// Date Date in format YYYY-MM-DD.
	Date *openapi_types.Date `json:"date,omitempty"`

	// MuscleLoad User muscle load value.
	MuscleLoad               *float32                 `json:"muscle-load,omitempty"`
	MuscleLoadInterpretation *TrainingLoadProLoadEnum `json:"muscle-load-interpretation,omitempty"`

	// PerceivedLoad User perceived load value.
	PerceivedLoad               *float32                 `json:"perceived-load,omitempty"`
	PerceivedLoadInterpretation *TrainingLoadProLoadEnum `json:"perceived-load-interpretation,omitempty"`

	// UserRpe Quantifies internal training load of a session.
	UserRpe *TrainingLoadProRpeEnum `json:"user-rpe,omitempty"`
}

// TransactionLocation Contains absolute link to the created transaction.
type TransactionLocation struct {
	// ResourceUri Absolute links to the created transaction
	ResourceUri *string `json:"resource-uri,omitempty"`

	// TransactionId Id of the created transaction
	TransactionId *int64 `json:"transaction-id,omitempty"`
}

// User User's basic information
type User struct {
	// Birthdate User's birthdate as YYYY-MM-DD
	Birthdate *string `json:"birthdate,omitempty"`

	// ExtraInfo List containing answers given by the user to a number of partner-specific questions. Extra-info is null if there are no required fields defined by the partner.
	ExtraInfo *[]UserExtraInfo `json:"extra-info,omitempty"`

	// FirstName User's first name
	FirstName *string `json:"first-name,omitempty"`

	// Gender User's sex
	Gender *UserGender `json:"gender,omitempty"`

	// Height Users height in centimeters
	Height *float32 `json:"height,omitempty"`

	// LastName User's surname
	LastName *string `json:"last-name,omitempty"`

	// MemberId User's identifier in partner's database
	MemberId *string `json:"member-id,omitempty"`

	// PolarUserId User's id in Polar database
	PolarUserId *int64 `json:"polar-user-id,omitempty"`

	// RegistrationDate Timestamp marked when ACCEPTED
	RegistrationDate *time.Time `json:"registration-date,omitempty"`

	// Weight User's weight in kg
	Weight *float32 `json:"weight,omitempty"`
}

// UserGender User's sex
type UserGender string

// WebhookInfo defines model for webhookInfo.
type WebhookInfo struct {
	Data *[]struct {
		// Active Is the webhook active.
		Active *bool `json:"active,omitempty"`

		// Events Subscribed event types.
		Events *[]WebhookType `json:"events,omitempty"`

		// Id Id of the webhook.
		Id *string `json:"id,omitempty"`

		// Url Url where the webhook notification is sent.
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// WebhookPatch defines model for webhookPatch.
type WebhookPatch struct {
	// Events Type of events to subscribe.
	Events *[]WebhookType `json:"events,omitempty"`

	// Url Url where the webhook notification is sent.
	Url *string `json:"url,omitempty"`
}

// WebhookRequest defines model for webhookRequest.
type WebhookRequest struct {
	// Events Type of events to subscribe.
	Events []WebhookType `json:"events"`

	// Url Url where the webhook notification is sent.
	Url string `json:"url"`
}

// WebhookType Event type to subscribe. Currently EXERCISE, SLEEP, CONTINUOUS_HEART_RATE, SLEEP_WISE_CIRCADIAN_BEDTIME, SLEEP_WISE_ALERTNESS and ACTIVITY_SUMMARY are supported.
type WebhookType string

// Zone Heart-rate zone information
type Zone struct {
	// InZone Time duration spent in the zone ISO 8601
	InZone *string `json:"in-zone,omitempty"`

	// Index Zone list index
	Index *int32 `json:"index,omitempty"`

	// LowerLimit Lower heart-rate boundary of the zone
	LowerLimit *int32 `json:"lower-limit,omitempty"`

	// UpperLimit Upper heart-rate boundary of the zone
	UpperLimit *int32 `json:"upper-limit,omitempty"`
}

// Zones List containing the times (in zone) in different heart rate zones (i.e. Heart rate between lower and upper values). Zone is null if no zone information available.
type Zones struct {
	// Zone List of heart rate zones.
	Zone *[]Zone `json:"zone,omitempty"`
}

// ListExercisesWithoutTransactionParams defines parameters for ListExercisesWithoutTransaction.
type ListExercisesWithoutTransactionParams struct {
	// Samples Return all sample data for this exercise.
	Samples *bool `form:"samples,omitempty" json:"samples,omitempty"`

	// Zones Return all zones data for this exercise.
	Zones *bool `form:"zones,omitempty" json:"zones,omitempty"`

	// Route Return all route data for this exercise.
	Route *bool `form:"route,omitempty" json:"route,omitempty"`
}

// GetExerciseWithoutTransactionParams defines parameters for GetExerciseWithoutTransaction.
type GetExerciseWithoutTransactionParams struct {
	// Samples Return all sample data for this exercise.
	Samples *bool `form:"samples,omitempty" json:"samples,omitempty"`

	// Zones Return all zones data for this exercise.
	Zones *bool `form:"zones,omitempty" json:"zones,omitempty"`

	// Route Return all route data for this exercise.
	Route *bool `form:"route,omitempty" json:"route,omitempty"`
}

// ListActivitiesWithoutTransactionParams defines parameters for ListActivitiesWithoutTransaction.
type ListActivitiesWithoutTransactionParams struct {
	// Steps include steps samples for activity summary.
	Steps *bool `form:"steps,omitempty" json:"steps,omitempty"`

	// ActivityZones include activity zones samples for activity summary.
	ActivityZones *bool `form:"activity_zones,omitempty" json:"activity_zones,omitempty"`

	// InactivityStamps include inactivity stamps for activity summary.
	InactivityStamps *bool `form:"inactivity_stamps,omitempty" json:"inactivity_stamps,omitempty"`
}

// ListActivitiesWithoutTransactionByDateRangeParams defines parameters for ListActivitiesWithoutTransactionByDateRange.
type ListActivitiesWithoutTransactionByDateRangeParams struct {
	// From Start date in format YYYY-MM-DD.
	From openapi_types.Date `form:"from" json:"from"`

	// To End date in format YYYY-MM-DD. If not given, defaults to today.
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`

	// Steps include steps samples for activity summary.
	Steps *bool `form:"steps,omitempty" json:"steps,omitempty"`

	// ActivityZones include activity zones samples for activity summary.
	ActivityZones *bool `form:"activity_zones,omitempty" json:"activity_zones,omitempty"`

	// InactivityStamps include inactivity stamps for activity summary.
	InactivityStamps *bool `form:"inactivity_stamps,omitempty" json:"inactivity_stamps,omitempty"`
}

// ListActivitySamplesWithoutTransactionByDateRangeParams defines parameters for ListActivitySamplesWithoutTransactionByDateRange.
type ListActivitySamplesWithoutTransactionByDateRangeParams struct {
	// From Start date in format YYYY-MM-DD.
	From openapi_types.Date `form:"from" json:"from"`

	// To End date in format YYYY-MM-DD. If not given, defaults to today.
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetActivityWithoutTransactionParams defines parameters for GetActivityWithoutTransaction.
type GetActivityWithoutTransactionParams struct {
	// Steps include steps samples for activity summary.
	Steps *bool `form:"steps,omitempty" json:"steps,omitempty"`

	// ActivityZones include activity zones samples for activity summary.
	ActivityZones *bool `form:"activity_zones,omitempty" json:"activity_zones,omitempty"`

	// InactivityStamps include inactivity stamps for activity summary.
	InactivityStamps *bool `form:"inactivity_stamps,omitempty" json:"inactivity_stamps,omitempty"`
}

// GetV3UsersBiosensingBodytemperatureParams defines parameters for GetV3UsersBiosensingBodytemperature.
type GetV3UsersBiosensingBodytemperatureParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2023-10-01"
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2023-10-28"
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetV3UsersBiosensingEcgParams defines parameters for GetV3UsersBiosensingEcg.
type GetV3UsersBiosensingEcgParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2023-10-01"
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2023-10-28"
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetV3UsersBiosensingSkincontactsParams defines parameters for GetV3UsersBiosensingSkincontacts.
type GetV3UsersBiosensingSkincontactsParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2023-10-01"
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2023-10-28"
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetV3UsersBiosensingSkintemperatureParams defines parameters for GetV3UsersBiosensingSkintemperature.
type GetV3UsersBiosensingSkintemperatureParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2023-10-01"
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2023-10-28"
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetV3UsersBiosensingSpo2Params defines parameters for GetV3UsersBiosensingSpo2.
type GetV3UsersBiosensingSpo2Params struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2023-10-01"
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2023-10-28"
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// GetCardioLoadByDateRangeParams defines parameters for GetCardioLoadByDateRange.
type GetCardioLoadByDateRangeParams struct {
	// From Inclusive as ISO-8601 date string, example: "2022-01-01"
	From openapi_types.Date `form:"from" json:"from"`

	// To Inclusive as ISO-8601 date string, example: "2022-01-01"
	To openapi_types.Date `form:"to" json:"to"`
}

// GetV3UsersContinuousHeartRateParams defines parameters for GetV3UsersContinuousHeartRate.
type GetV3UsersContinuousHeartRateParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2022-01-01"
	From openapi_types.Date `form:"from" json:"from"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2022-01-28"
	To openapi_types.Date `form:"to" json:"to"`
}

// GetV3UsersSleepwiseAlertnessDateParams defines parameters for GetV3UsersSleepwiseAlertnessDate.
type GetV3UsersSleepwiseAlertnessDateParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2022-01-01"
	From openapi_types.Date `form:"from" json:"from"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2022-01-28"
	To openapi_types.Date `form:"to" json:"to"`
}

// GetV3UsersSleepwiseCircadianBedtimeDateParams defines parameters for GetV3UsersSleepwiseCircadianBedtimeDate.
type GetV3UsersSleepwiseCircadianBedtimeDateParams struct {
	// From Inclusive start date of range as ISO-8601 date string, example: "2022-01-01"
	From openapi_types.Date `form:"from" json:"from"`

	// To Inclusive end date of range as ISO-8601 date string, example: "2022-01-28"
	To openapi_types.Date `form:"to" json:"to"`
}

// GetGpxParams defines parameters for GetGpx.
type GetGpxParams struct {
	// IncludePauseTimes Whether to add pauses as part of the route. Default is false.
	IncludePauseTimes *bool `form:"includePauseTimes,omitempty" json:"includePauseTimes,omitempty"`
}

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = Register

// CreateWebhookJSONRequestBody defines body for CreateWebhook for application/json ContentType.
type CreateWebhookJSONRequestBody = WebhookRequest

// UpdateWebhookJSONRequestBody defines body for UpdateWebhook for application/json ContentType.
type UpdateWebhookJSONRequestBody = WebhookPatch

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListExercisesWithoutTransaction request
	ListExercisesWithoutTransaction(ctx context.Context, params *ListExercisesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExerciseWithoutTransaction request
	GetExerciseWithoutTransaction(ctx context.Context, exerciseId string, params *GetExerciseWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExerciseFitWithoutTransaction request
	GetExerciseFitWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExerciseGpxWithoutTransaction request
	GetExerciseGpxWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExerciseTcxWithoutTransaction request
	GetExerciseTcxWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// List request
	List(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterUserWithBody request with any body
	RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivitiesWithoutTransaction request
	ListActivitiesWithoutTransaction(ctx context.Context, params *ListActivitiesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivitiesWithoutTransactionByDateRange request
	ListActivitiesWithoutTransactionByDateRange(ctx context.Context, params *ListActivitiesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivitySamplesWithoutTransaction request
	ListActivitySamplesWithoutTransaction(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivitySamplesWithoutTransactionByDateRange request
	ListActivitySamplesWithoutTransactionByDateRange(ctx context.Context, params *ListActivitySamplesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivitySamplesWithoutTransaction request
	GetActivitySamplesWithoutTransaction(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityWithoutTransaction request
	GetActivityWithoutTransaction(ctx context.Context, date openapi_types.Date, params *GetActivityWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersBiosensingBodytemperature request
	GetV3UsersBiosensingBodytemperature(ctx context.Context, params *GetV3UsersBiosensingBodytemperatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersBiosensingEcg request
	GetV3UsersBiosensingEcg(ctx context.Context, params *GetV3UsersBiosensingEcgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersBiosensingSkincontacts request
	GetV3UsersBiosensingSkincontacts(ctx context.Context, params *GetV3UsersBiosensingSkincontactsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersBiosensingSkintemperature request
	GetV3UsersBiosensingSkintemperature(ctx context.Context, params *GetV3UsersBiosensingSkintemperatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersBiosensingSpo2 request
	GetV3UsersBiosensingSpo2(ctx context.Context, params *GetV3UsersBiosensingSpo2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersCardioLoad request
	GetV3UsersCardioLoad(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCardioLoadByDateRange request
	GetCardioLoadByDateRange(ctx context.Context, params *GetCardioLoadByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersCardioLoadPeriodDaysDays request
	GetV3UsersCardioLoadPeriodDaysDays(ctx context.Context, days int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersCardioLoadPeriodMonthsMonths request
	GetV3UsersCardioLoadPeriodMonthsMonths(ctx context.Context, months int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersCardioLoadDate request
	GetV3UsersCardioLoadDate(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersContinuousHeartRate request
	GetV3UsersContinuousHeartRate(ctx context.Context, params *GetV3UsersContinuousHeartRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersContinuousHeartRateDate request
	GetV3UsersContinuousHeartRateDate(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNightlyRecharge request
	ListNightlyRecharge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersNightlyRechargeDate request
	GetV3UsersNightlyRechargeDate(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNights request
	ListNights(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepAvailable request
	GetV3UsersSleepAvailable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepDate request
	GetV3UsersSleepDate(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepwiseAlertness request
	GetV3UsersSleepwiseAlertness(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepwiseAlertnessDate request
	GetV3UsersSleepwiseAlertnessDate(ctx context.Context, params *GetV3UsersSleepwiseAlertnessDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepwiseCircadianBedtime request
	GetV3UsersSleepwiseCircadianBedtime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV3UsersSleepwiseCircadianBedtimeDate request
	GetV3UsersSleepwiseCircadianBedtimeDate(ctx context.Context, params *GetV3UsersSleepwiseCircadianBedtimeDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInformation request
	GetUserInformation(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateActivityTransaction request
	CreateActivityTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivities request
	ListActivities(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitActivityTransaction request
	CommitActivityTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivitySummary request
	GetActivitySummary(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStepSamples request
	GetStepSamples(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZoneSamples request
	GetZoneSamples(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExerciseTransaction request
	CreateExerciseTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExercises request
	ListExercises(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitExerciseTransaction request
	CommitExerciseTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExerciseSummary request
	GetExerciseSummary(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFit request
	GetFit(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpx request
	GetGpx(ctx context.Context, userId int, transactionId int, exerciseId int, params *GetGpxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHeartRateZones request
	GetHeartRateZones(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableSamples request
	GetAvailableSamples(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamples request
	GetSamples(ctx context.Context, userId int, transactionId int, exerciseId int, typeId []byte, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTcx request
	GetTcx(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePhysicalInfoTransaction request
	CreatePhysicalInfoTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPhysicalInfos request
	ListPhysicalInfos(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitPhysicalInfoTransaction request
	CommitPhysicalInfoTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalInfo request
	GetPhysicalInfo(ctx context.Context, userId int, transactionId int, physicalInfoId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookWithBody request with any body
	CreateWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3WebhooksActivate request
	PostV3WebhooksActivate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3WebhooksDeactivate request
	PostV3WebhooksDeactivate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookWithBody request with any body
	UpdateWebhookWithBody(ctx context.Context, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook(ctx context.Context, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListExercisesWithoutTransaction(ctx context.Context, params *ListExercisesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExercisesWithoutTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExerciseWithoutTransaction(ctx context.Context, exerciseId string, params *GetExerciseWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExerciseWithoutTransactionRequest(c.Server, exerciseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExerciseFitWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExerciseFitWithoutTransactionRequest(c.Server, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExerciseGpxWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExerciseGpxWithoutTransactionRequest(c.Server, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExerciseTcxWithoutTransaction(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExerciseTcxWithoutTransactionRequest(c.Server, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) List(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivitiesWithoutTransaction(ctx context.Context, params *ListActivitiesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivitiesWithoutTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivitiesWithoutTransactionByDateRange(ctx context.Context, params *ListActivitiesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivitiesWithoutTransactionByDateRangeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivitySamplesWithoutTransaction(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivitySamplesWithoutTransactionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivitySamplesWithoutTransactionByDateRange(ctx context.Context, params *ListActivitySamplesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivitySamplesWithoutTransactionByDateRangeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivitySamplesWithoutTransaction(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitySamplesWithoutTransactionRequest(c.Server, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityWithoutTransaction(ctx context.Context, date openapi_types.Date, params *GetActivityWithoutTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityWithoutTransactionRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersBiosensingBodytemperature(ctx context.Context, params *GetV3UsersBiosensingBodytemperatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersBiosensingBodytemperatureRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersBiosensingEcg(ctx context.Context, params *GetV3UsersBiosensingEcgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersBiosensingEcgRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersBiosensingSkincontacts(ctx context.Context, params *GetV3UsersBiosensingSkincontactsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersBiosensingSkincontactsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersBiosensingSkintemperature(ctx context.Context, params *GetV3UsersBiosensingSkintemperatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersBiosensingSkintemperatureRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersBiosensingSpo2(ctx context.Context, params *GetV3UsersBiosensingSpo2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersBiosensingSpo2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersCardioLoad(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersCardioLoadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCardioLoadByDateRange(ctx context.Context, params *GetCardioLoadByDateRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCardioLoadByDateRangeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersCardioLoadPeriodDaysDays(ctx context.Context, days int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersCardioLoadPeriodDaysDaysRequest(c.Server, days)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersCardioLoadPeriodMonthsMonths(ctx context.Context, months int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersCardioLoadPeriodMonthsMonthsRequest(c.Server, months)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersCardioLoadDate(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersCardioLoadDateRequest(c.Server, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersContinuousHeartRate(ctx context.Context, params *GetV3UsersContinuousHeartRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersContinuousHeartRateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersContinuousHeartRateDate(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersContinuousHeartRateDateRequest(c.Server, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNightlyRecharge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNightlyRechargeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersNightlyRechargeDate(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersNightlyRechargeDateRequest(c.Server, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNights(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNightsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepAvailable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepAvailableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepDate(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepDateRequest(c.Server, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepwiseAlertness(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepwiseAlertnessRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepwiseAlertnessDate(ctx context.Context, params *GetV3UsersSleepwiseAlertnessDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepwiseAlertnessDateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepwiseCircadianBedtime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepwiseCircadianBedtimeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV3UsersSleepwiseCircadianBedtimeDate(ctx context.Context, params *GetV3UsersSleepwiseCircadianBedtimeDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV3UsersSleepwiseCircadianBedtimeDateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInformation(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInformationRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateActivityTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateActivityTransactionRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivities(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivitiesRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitActivityTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitActivityTransactionRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivitySummary(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivitySummaryRequest(c.Server, userId, transactionId, activityId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStepSamples(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStepSamplesRequest(c.Server, userId, transactionId, activityId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZoneSamples(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZoneSamplesRequest(c.Server, userId, transactionId, activityId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExerciseTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExerciseTransactionRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExercises(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExercisesRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitExerciseTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitExerciseTransactionRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExerciseSummary(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExerciseSummaryRequest(c.Server, userId, transactionId, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFit(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFitRequest(c.Server, userId, transactionId, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpx(ctx context.Context, userId int, transactionId int, exerciseId int, params *GetGpxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpxRequest(c.Server, userId, transactionId, exerciseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHeartRateZones(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHeartRateZonesRequest(c.Server, userId, transactionId, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableSamples(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableSamplesRequest(c.Server, userId, transactionId, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamples(ctx context.Context, userId int, transactionId int, exerciseId int, typeId []byte, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamplesRequest(c.Server, userId, transactionId, exerciseId, typeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTcx(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTcxRequest(c.Server, userId, transactionId, exerciseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePhysicalInfoTransaction(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePhysicalInfoTransactionRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPhysicalInfos(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPhysicalInfosRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitPhysicalInfoTransaction(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitPhysicalInfoTransactionRequest(c.Server, userId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalInfo(ctx context.Context, userId int, transactionId int, physicalInfoId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalInfoRequest(c.Server, userId, transactionId, physicalInfoId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3WebhooksActivate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3WebhooksActivateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3WebhooksDeactivate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3WebhooksDeactivateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithBody(ctx context.Context, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithBody(c.Server, webhookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook(ctx context.Context, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequest(c.Server, webhookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListExercisesWithoutTransactionRequest generates requests for ListExercisesWithoutTransaction
func NewListExercisesWithoutTransactionRequest(server string, params *ListExercisesWithoutTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/exercises")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Samples != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "samples", runtime.ParamLocationQuery, *params.Samples); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zones", runtime.ParamLocationQuery, *params.Zones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Route != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "route", runtime.ParamLocationQuery, *params.Route); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExerciseWithoutTransactionRequest generates requests for GetExerciseWithoutTransaction
func NewGetExerciseWithoutTransactionRequest(server string, exerciseId string, params *GetExerciseWithoutTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exerciseId", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/exercises/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Samples != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "samples", runtime.ParamLocationQuery, *params.Samples); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zones", runtime.ParamLocationQuery, *params.Zones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Route != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "route", runtime.ParamLocationQuery, *params.Route); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExerciseFitWithoutTransactionRequest generates requests for GetExerciseFitWithoutTransaction
func NewGetExerciseFitWithoutTransactionRequest(server string, exerciseId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exerciseId", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/exercises/%s/fit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExerciseGpxWithoutTransactionRequest generates requests for GetExerciseGpxWithoutTransaction
func NewGetExerciseGpxWithoutTransactionRequest(server string, exerciseId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exerciseId", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/exercises/%s/gpx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExerciseTcxWithoutTransactionRequest generates requests for GetExerciseTcxWithoutTransaction
func NewGetExerciseTcxWithoutTransactionRequest(server string, exerciseId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exerciseId", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/exercises/%s/tcx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequest generates requests for List
func NewListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterUserRequest calls the generic RegisterUser builder with application/json body
func NewRegisterUserRequest(server string, body RegisterUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterUserRequestWithBody generates requests for RegisterUser with any type of body
func NewRegisterUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListActivitiesWithoutTransactionRequest generates requests for ListActivitiesWithoutTransaction
func NewListActivitiesWithoutTransactionRequest(server string, params *ListActivitiesWithoutTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Steps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "steps", runtime.ParamLocationQuery, *params.Steps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActivityZones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity_zones", runtime.ParamLocationQuery, *params.ActivityZones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InactivityStamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inactivity_stamps", runtime.ParamLocationQuery, *params.InactivityStamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListActivitiesWithoutTransactionByDateRangeRequest generates requests for ListActivitiesWithoutTransactionByDateRange
func NewListActivitiesWithoutTransactionByDateRangeRequest(server string, params *ListActivitiesWithoutTransactionByDateRangeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Steps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "steps", runtime.ParamLocationQuery, *params.Steps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActivityZones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity_zones", runtime.ParamLocationQuery, *params.ActivityZones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InactivityStamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inactivity_stamps", runtime.ParamLocationQuery, *params.InactivityStamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListActivitySamplesWithoutTransactionRequest generates requests for ListActivitySamplesWithoutTransaction
func NewListActivitySamplesWithoutTransactionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities/samples")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListActivitySamplesWithoutTransactionByDateRangeRequest generates requests for ListActivitySamplesWithoutTransactionByDateRange
func NewListActivitySamplesWithoutTransactionByDateRangeRequest(server string, params *ListActivitySamplesWithoutTransactionByDateRangeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities/samples/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivitySamplesWithoutTransactionRequest generates requests for GetActivitySamplesWithoutTransaction
func NewGetActivitySamplesWithoutTransactionRequest(server string, date openapi_types.Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities/samples/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityWithoutTransactionRequest generates requests for GetActivityWithoutTransaction
func NewGetActivityWithoutTransactionRequest(server string, date openapi_types.Date, params *GetActivityWithoutTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Steps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "steps", runtime.ParamLocationQuery, *params.Steps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActivityZones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity_zones", runtime.ParamLocationQuery, *params.ActivityZones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InactivityStamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inactivity_stamps", runtime.ParamLocationQuery, *params.InactivityStamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersBiosensingBodytemperatureRequest generates requests for GetV3UsersBiosensingBodytemperature
func NewGetV3UsersBiosensingBodytemperatureRequest(server string, params *GetV3UsersBiosensingBodytemperatureParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/biosensing/bodytemperature")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersBiosensingEcgRequest generates requests for GetV3UsersBiosensingEcg
func NewGetV3UsersBiosensingEcgRequest(server string, params *GetV3UsersBiosensingEcgParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/biosensing/ecg")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersBiosensingSkincontactsRequest generates requests for GetV3UsersBiosensingSkincontacts
func NewGetV3UsersBiosensingSkincontactsRequest(server string, params *GetV3UsersBiosensingSkincontactsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/biosensing/skincontacts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersBiosensingSkintemperatureRequest generates requests for GetV3UsersBiosensingSkintemperature
func NewGetV3UsersBiosensingSkintemperatureRequest(server string, params *GetV3UsersBiosensingSkintemperatureParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/biosensing/skintemperature")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersBiosensingSpo2Request generates requests for GetV3UsersBiosensingSpo2
func NewGetV3UsersBiosensingSpo2Request(server string, params *GetV3UsersBiosensingSpo2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/biosensing/spo2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersCardioLoadRequest generates requests for GetV3UsersCardioLoad
func NewGetV3UsersCardioLoadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/cardio-load/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCardioLoadByDateRangeRequest generates requests for GetCardioLoadByDateRange
func NewGetCardioLoadByDateRangeRequest(server string, params *GetCardioLoadByDateRangeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/cardio-load/date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersCardioLoadPeriodDaysDaysRequest generates requests for GetV3UsersCardioLoadPeriodDaysDays
func NewGetV3UsersCardioLoadPeriodDaysDaysRequest(server string, days int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "days", runtime.ParamLocationPath, days)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/cardio-load/period/days/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersCardioLoadPeriodMonthsMonthsRequest generates requests for GetV3UsersCardioLoadPeriodMonthsMonths
func NewGetV3UsersCardioLoadPeriodMonthsMonthsRequest(server string, months int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "months", runtime.ParamLocationPath, months)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/cardio-load/period/months/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersCardioLoadDateRequest generates requests for GetV3UsersCardioLoadDate
func NewGetV3UsersCardioLoadDateRequest(server string, date openapi_types.Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/cardio-load/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersContinuousHeartRateRequest generates requests for GetV3UsersContinuousHeartRate
func NewGetV3UsersContinuousHeartRateRequest(server string, params *GetV3UsersContinuousHeartRateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/continuous-heart-rate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersContinuousHeartRateDateRequest generates requests for GetV3UsersContinuousHeartRateDate
func NewGetV3UsersContinuousHeartRateDateRequest(server string, date openapi_types.Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/continuous-heart-rate/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNightlyRechargeRequest generates requests for ListNightlyRecharge
func NewListNightlyRechargeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/nightly-recharge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersNightlyRechargeDateRequest generates requests for GetV3UsersNightlyRechargeDate
func NewGetV3UsersNightlyRechargeDateRequest(server string, date string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/nightly-recharge/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNightsRequest generates requests for ListNights
func NewListNightsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleep")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepAvailableRequest generates requests for GetV3UsersSleepAvailable
func NewGetV3UsersSleepAvailableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleep/available")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepDateRequest generates requests for GetV3UsersSleepDate
func NewGetV3UsersSleepDateRequest(server string, date string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleep/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepwiseAlertnessRequest generates requests for GetV3UsersSleepwiseAlertness
func NewGetV3UsersSleepwiseAlertnessRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleepwise/alertness")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepwiseAlertnessDateRequest generates requests for GetV3UsersSleepwiseAlertnessDate
func NewGetV3UsersSleepwiseAlertnessDateRequest(server string, params *GetV3UsersSleepwiseAlertnessDateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleepwise/alertness/date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepwiseCircadianBedtimeRequest generates requests for GetV3UsersSleepwiseCircadianBedtime
func NewGetV3UsersSleepwiseCircadianBedtimeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleepwise/circadian-bedtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetV3UsersSleepwiseCircadianBedtimeDateRequest generates requests for GetV3UsersSleepwiseCircadianBedtimeDate
func NewGetV3UsersSleepwiseCircadianBedtimeDateRequest(server string, params *GetV3UsersSleepwiseCircadianBedtimeDateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/sleepwise/circadian-bedtime/date")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserInformationRequest generates requests for GetUserInformation
func NewGetUserInformationRequest(server string, userId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateActivityTransactionRequest generates requests for CreateActivityTransaction
func NewCreateActivityTransactionRequest(server string, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListActivitiesRequest generates requests for ListActivities
func NewListActivitiesRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitActivityTransactionRequest generates requests for CommitActivityTransaction
func NewCommitActivityTransactionRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivitySummaryRequest generates requests for GetActivitySummary
func NewGetActivitySummaryRequest(server string, userId int, transactionId int, activityId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "activity-id", runtime.ParamLocationPath, activityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions/%s/activities/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStepSamplesRequest generates requests for GetStepSamples
func NewGetStepSamplesRequest(server string, userId int, transactionId int, activityId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "activity-id", runtime.ParamLocationPath, activityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions/%s/activities/%s/step-samples", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZoneSamplesRequest generates requests for GetZoneSamples
func NewGetZoneSamplesRequest(server string, userId int, transactionId int, activityId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "activity-id", runtime.ParamLocationPath, activityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/activity-transactions/%s/activities/%s/zone-samples", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExerciseTransactionRequest generates requests for CreateExerciseTransaction
func NewCreateExerciseTransactionRequest(server string, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListExercisesRequest generates requests for ListExercises
func NewListExercisesRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitExerciseTransactionRequest generates requests for CommitExerciseTransaction
func NewCommitExerciseTransactionRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExerciseSummaryRequest generates requests for GetExerciseSummary
func NewGetExerciseSummaryRequest(server string, userId int, transactionId int, exerciseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFitRequest generates requests for GetFit
func NewGetFitRequest(server string, userId int, transactionId int, exerciseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/fit", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGpxRequest generates requests for GetGpx
func NewGetGpxRequest(server string, userId int, transactionId int, exerciseId int, params *GetGpxParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/gpx", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludePauseTimes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includePauseTimes", runtime.ParamLocationQuery, *params.IncludePauseTimes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHeartRateZonesRequest generates requests for GetHeartRateZones
func NewGetHeartRateZonesRequest(server string, userId int, transactionId int, exerciseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/heart-rate-zones", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailableSamplesRequest generates requests for GetAvailableSamples
func NewGetAvailableSamplesRequest(server string, userId int, transactionId int, exerciseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/samples", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSamplesRequest generates requests for GetSamples
func NewGetSamplesRequest(server string, userId int, transactionId int, exerciseId int, typeId []byte) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "type-id", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/samples/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTcxRequest generates requests for GetTcx
func NewGetTcxRequest(server string, userId int, transactionId int, exerciseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "exercise-id", runtime.ParamLocationPath, exerciseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/exercise-transactions/%s/exercises/%s/tcx", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePhysicalInfoTransactionRequest generates requests for CreatePhysicalInfoTransaction
func NewCreatePhysicalInfoTransactionRequest(server string, userId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/physical-information-transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPhysicalInfosRequest generates requests for ListPhysicalInfos
func NewListPhysicalInfosRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/physical-information-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitPhysicalInfoTransactionRequest generates requests for CommitPhysicalInfoTransaction
func NewCommitPhysicalInfoTransactionRequest(server string, userId int, transactionId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/physical-information-transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPhysicalInfoRequest generates requests for GetPhysicalInfo
func NewGetPhysicalInfoRequest(server string, userId int, transactionId int, physicalInfoId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user-id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction-id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "physical-info-id", runtime.ParamLocationPath, physicalInfoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/users/%s/physical-information-transactions/%s/physical-informations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookRequest calls the generic CreateWebhook builder with application/json body
func NewCreateWebhookRequest(server string, body CreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func NewCreateWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostV3WebhooksActivateRequest generates requests for PostV3WebhooksActivate
func NewPostV3WebhooksActivateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks/activate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV3WebhooksDeactivateRequest generates requests for PostV3WebhooksDeactivate
func NewPostV3WebhooksDeactivateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks/deactivate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook-id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookRequest calls the generic UpdateWebhook builder with application/json body
func NewUpdateWebhookRequest(server string, webhookId string, body UpdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookRequestWithBody(server, webhookId, "application/json", bodyReader)
}

// NewUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func NewUpdateWebhookRequestWithBody(server string, webhookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook-id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListExercisesWithoutTransactionWithResponse request
	ListExercisesWithoutTransactionWithResponse(ctx context.Context, params *ListExercisesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*ListExercisesWithoutTransactionResponse, error)

	// GetExerciseWithoutTransactionWithResponse request
	GetExerciseWithoutTransactionWithResponse(ctx context.Context, exerciseId string, params *GetExerciseWithoutTransactionParams, reqEditors ...RequestEditorFn) (*GetExerciseWithoutTransactionResponse, error)

	// GetExerciseFitWithoutTransactionWithResponse request
	GetExerciseFitWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseFitWithoutTransactionResponse, error)

	// GetExerciseGpxWithoutTransactionWithResponse request
	GetExerciseGpxWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseGpxWithoutTransactionResponse, error)

	// GetExerciseTcxWithoutTransactionWithResponse request
	GetExerciseTcxWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseTcxWithoutTransactionResponse, error)

	// ListWithResponse request
	ListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResponse, error)

	// RegisterUserWithBodyWithResponse request with any body
	RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	// ListActivitiesWithoutTransactionWithResponse request
	ListActivitiesWithoutTransactionWithResponse(ctx context.Context, params *ListActivitiesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*ListActivitiesWithoutTransactionResponse, error)

	// ListActivitiesWithoutTransactionByDateRangeWithResponse request
	ListActivitiesWithoutTransactionByDateRangeWithResponse(ctx context.Context, params *ListActivitiesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*ListActivitiesWithoutTransactionByDateRangeResponse, error)

	// ListActivitySamplesWithoutTransactionWithResponse request
	ListActivitySamplesWithoutTransactionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListActivitySamplesWithoutTransactionResponse, error)

	// ListActivitySamplesWithoutTransactionByDateRangeWithResponse request
	ListActivitySamplesWithoutTransactionByDateRangeWithResponse(ctx context.Context, params *ListActivitySamplesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*ListActivitySamplesWithoutTransactionByDateRangeResponse, error)

	// GetActivitySamplesWithoutTransactionWithResponse request
	GetActivitySamplesWithoutTransactionWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetActivitySamplesWithoutTransactionResponse, error)

	// GetActivityWithoutTransactionWithResponse request
	GetActivityWithoutTransactionWithResponse(ctx context.Context, date openapi_types.Date, params *GetActivityWithoutTransactionParams, reqEditors ...RequestEditorFn) (*GetActivityWithoutTransactionResponse, error)

	// GetV3UsersBiosensingBodytemperatureWithResponse request
	GetV3UsersBiosensingBodytemperatureWithResponse(ctx context.Context, params *GetV3UsersBiosensingBodytemperatureParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingBodytemperatureResponse, error)

	// GetV3UsersBiosensingEcgWithResponse request
	GetV3UsersBiosensingEcgWithResponse(ctx context.Context, params *GetV3UsersBiosensingEcgParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingEcgResponse, error)

	// GetV3UsersBiosensingSkincontactsWithResponse request
	GetV3UsersBiosensingSkincontactsWithResponse(ctx context.Context, params *GetV3UsersBiosensingSkincontactsParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSkincontactsResponse, error)

	// GetV3UsersBiosensingSkintemperatureWithResponse request
	GetV3UsersBiosensingSkintemperatureWithResponse(ctx context.Context, params *GetV3UsersBiosensingSkintemperatureParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSkintemperatureResponse, error)

	// GetV3UsersBiosensingSpo2WithResponse request
	GetV3UsersBiosensingSpo2WithResponse(ctx context.Context, params *GetV3UsersBiosensingSpo2Params, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSpo2Response, error)

	// GetV3UsersCardioLoadWithResponse request
	GetV3UsersCardioLoadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadResponse, error)

	// GetCardioLoadByDateRangeWithResponse request
	GetCardioLoadByDateRangeWithResponse(ctx context.Context, params *GetCardioLoadByDateRangeParams, reqEditors ...RequestEditorFn) (*GetCardioLoadByDateRangeResponse, error)

	// GetV3UsersCardioLoadPeriodDaysDaysWithResponse request
	GetV3UsersCardioLoadPeriodDaysDaysWithResponse(ctx context.Context, days int, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadPeriodDaysDaysResponse, error)

	// GetV3UsersCardioLoadPeriodMonthsMonthsWithResponse request
	GetV3UsersCardioLoadPeriodMonthsMonthsWithResponse(ctx context.Context, months int, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadPeriodMonthsMonthsResponse, error)

	// GetV3UsersCardioLoadDateWithResponse request
	GetV3UsersCardioLoadDateWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadDateResponse, error)

	// GetV3UsersContinuousHeartRateWithResponse request
	GetV3UsersContinuousHeartRateWithResponse(ctx context.Context, params *GetV3UsersContinuousHeartRateParams, reqEditors ...RequestEditorFn) (*GetV3UsersContinuousHeartRateResponse, error)

	// GetV3UsersContinuousHeartRateDateWithResponse request
	GetV3UsersContinuousHeartRateDateWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetV3UsersContinuousHeartRateDateResponse, error)

	// ListNightlyRechargeWithResponse request
	ListNightlyRechargeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNightlyRechargeResponse, error)

	// GetV3UsersNightlyRechargeDateWithResponse request
	GetV3UsersNightlyRechargeDateWithResponse(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*GetV3UsersNightlyRechargeDateResponse, error)

	// ListNightsWithResponse request
	ListNightsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNightsResponse, error)

	// GetV3UsersSleepAvailableWithResponse request
	GetV3UsersSleepAvailableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepAvailableResponse, error)

	// GetV3UsersSleepDateWithResponse request
	GetV3UsersSleepDateWithResponse(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*GetV3UsersSleepDateResponse, error)

	// GetV3UsersSleepwiseAlertnessWithResponse request
	GetV3UsersSleepwiseAlertnessWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseAlertnessResponse, error)

	// GetV3UsersSleepwiseAlertnessDateWithResponse request
	GetV3UsersSleepwiseAlertnessDateWithResponse(ctx context.Context, params *GetV3UsersSleepwiseAlertnessDateParams, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseAlertnessDateResponse, error)

	// GetV3UsersSleepwiseCircadianBedtimeWithResponse request
	GetV3UsersSleepwiseCircadianBedtimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseCircadianBedtimeResponse, error)

	// GetV3UsersSleepwiseCircadianBedtimeDateWithResponse request
	GetV3UsersSleepwiseCircadianBedtimeDateWithResponse(ctx context.Context, params *GetV3UsersSleepwiseCircadianBedtimeDateParams, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseCircadianBedtimeDateResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserInformationWithResponse request
	GetUserInformationWithResponse(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*GetUserInformationResponse, error)

	// CreateActivityTransactionWithResponse request
	CreateActivityTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreateActivityTransactionResponse, error)

	// ListActivitiesWithResponse request
	ListActivitiesWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListActivitiesResponse, error)

	// CommitActivityTransactionWithResponse request
	CommitActivityTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitActivityTransactionResponse, error)

	// GetActivitySummaryWithResponse request
	GetActivitySummaryWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetActivitySummaryResponse, error)

	// GetStepSamplesWithResponse request
	GetStepSamplesWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetStepSamplesResponse, error)

	// GetZoneSamplesWithResponse request
	GetZoneSamplesWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetZoneSamplesResponse, error)

	// CreateExerciseTransactionWithResponse request
	CreateExerciseTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreateExerciseTransactionResponse, error)

	// ListExercisesWithResponse request
	ListExercisesWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListExercisesResponse, error)

	// CommitExerciseTransactionWithResponse request
	CommitExerciseTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitExerciseTransactionResponse, error)

	// GetExerciseSummaryWithResponse request
	GetExerciseSummaryWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetExerciseSummaryResponse, error)

	// GetFitWithResponse request
	GetFitWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetFitResponse, error)

	// GetGpxWithResponse request
	GetGpxWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, params *GetGpxParams, reqEditors ...RequestEditorFn) (*GetGpxResponse, error)

	// GetHeartRateZonesWithResponse request
	GetHeartRateZonesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetHeartRateZonesResponse, error)

	// GetAvailableSamplesWithResponse request
	GetAvailableSamplesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetAvailableSamplesResponse, error)

	// GetSamplesWithResponse request
	GetSamplesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, typeId []byte, reqEditors ...RequestEditorFn) (*GetSamplesResponse, error)

	// GetTcxWithResponse request
	GetTcxWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetTcxResponse, error)

	// CreatePhysicalInfoTransactionWithResponse request
	CreatePhysicalInfoTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreatePhysicalInfoTransactionResponse, error)

	// ListPhysicalInfosWithResponse request
	ListPhysicalInfosWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListPhysicalInfosResponse, error)

	// CommitPhysicalInfoTransactionWithResponse request
	CommitPhysicalInfoTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitPhysicalInfoTransactionResponse, error)

	// GetPhysicalInfoWithResponse request
	GetPhysicalInfoWithResponse(ctx context.Context, userId int, transactionId int, physicalInfoId int, reqEditors ...RequestEditorFn) (*GetPhysicalInfoResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// CreateWebhookWithBodyWithResponse request with any body
	CreateWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	CreateWebhookWithResponse(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	// PostV3WebhooksActivateWithResponse request
	PostV3WebhooksActivateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostV3WebhooksActivateResponse, error)

	// PostV3WebhooksDeactivateWithResponse request
	PostV3WebhooksDeactivateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostV3WebhooksDeactivateResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// UpdateWebhookWithBodyWithResponse request with any body
	UpdateWebhookWithBodyWithResponse(ctx context.Context, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithResponse(ctx context.Context, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)
}

type ListExercisesWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExercisesHashId
}

// Status returns HTTPResponse.Status
func (r ListExercisesWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExercisesWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExerciseWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExerciseHashId
}

// Status returns HTTPResponse.Status
func (r GetExerciseWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExerciseWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExerciseFitWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExerciseFitWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExerciseFitWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExerciseGpxWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExerciseGpxWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExerciseGpxWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExerciseTcxWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetExerciseTcxWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExerciseTcxWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AvailableUserDatas
	XML200       *AvailableUserDatas
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	XML200       *User
}

// Status returns HTTPResponse.Status
func (r RegisterUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivitiesWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfActivitySummaryWithAllSamples
}

// Status returns HTTPResponse.Status
func (r ListActivitiesWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivitiesWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivitiesWithoutTransactionByDateRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfActivitySummaryWithAllSamples
}

// Status returns HTTPResponse.Status
func (r ListActivitiesWithoutTransactionByDateRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivitiesWithoutTransactionByDateRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivitySamplesWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfActivityDayWithSamples
}

// Status returns HTTPResponse.Status
func (r ListActivitySamplesWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivitySamplesWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivitySamplesWithoutTransactionByDateRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayOfActivityDayWithSamples
}

// Status returns HTTPResponse.Status
func (r ListActivitySamplesWithoutTransactionByDateRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivitySamplesWithoutTransactionByDateRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitySamplesWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityDayWithSamples
}

// Status returns HTTPResponse.Status
func (r GetActivitySamplesWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitySamplesWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityWithoutTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivitySummaryWithAllSamples
}

// Status returns HTTPResponse.Status
func (r GetActivityWithoutTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityWithoutTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersBiosensingBodytemperatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BodyTemperaturePeriod
}

// Status returns HTTPResponse.Status
func (r GetV3UsersBiosensingBodytemperatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersBiosensingBodytemperatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersBiosensingEcgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EcgTestResult
}

// Status returns HTTPResponse.Status
func (r GetV3UsersBiosensingEcgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersBiosensingEcgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersBiosensingSkincontactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SkinContactPeriod
}

// Status returns HTTPResponse.Status
func (r GetV3UsersBiosensingSkincontactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersBiosensingSkincontactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersBiosensingSkintemperatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SkinTemperature
}

// Status returns HTTPResponse.Status
func (r GetV3UsersBiosensingSkintemperatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersBiosensingSkintemperatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersBiosensingSpo2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Spo2TestResult
}

// Status returns HTTPResponse.Status
func (r GetV3UsersBiosensingSpo2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersBiosensingSpo2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersCardioLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardioLoadSchema
}

// Status returns HTTPResponse.Status
func (r GetV3UsersCardioLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersCardioLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCardioLoadByDateRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardioLoadSchema
}

// Status returns HTTPResponse.Status
func (r GetCardioLoadByDateRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCardioLoadByDateRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersCardioLoadPeriodDaysDaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardioLoadSchema
}

// Status returns HTTPResponse.Status
func (r GetV3UsersCardioLoadPeriodDaysDaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersCardioLoadPeriodDaysDaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersCardioLoadPeriodMonthsMonthsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardioLoadSchema
}

// Status returns HTTPResponse.Status
func (r GetV3UsersCardioLoadPeriodMonthsMonthsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersCardioLoadPeriodMonthsMonthsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersCardioLoadDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CardioLoadSchema
}

// Status returns HTTPResponse.Status
func (r GetV3UsersCardioLoadDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersCardioLoadDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersContinuousHeartRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContinuousHeartrate
}

// Status returns HTTPResponse.Status
func (r GetV3UsersContinuousHeartRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersContinuousHeartRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersContinuousHeartRateDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContinuousHeartrate
}

// Status returns HTTPResponse.Status
func (r GetV3UsersContinuousHeartRateDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersContinuousHeartRateDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNightlyRechargeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Recharges
}

// Status returns HTTPResponse.Status
func (r ListNightlyRechargeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNightlyRechargeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersNightlyRechargeDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NightlyRecharge
}

// Status returns HTTPResponse.Status
func (r GetV3UsersNightlyRechargeDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersNightlyRechargeDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nights
}

// Status returns HTTPResponse.Status
func (r ListNightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepAvailableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AvailableSleeps
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepAvailableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepAvailableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sleep
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepwiseAlertnessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alertness
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepwiseAlertnessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepwiseAlertnessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepwiseAlertnessDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alertness
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepwiseAlertnessDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepwiseAlertnessDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepwiseCircadianBedtimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CircadianBedtime
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepwiseCircadianBedtimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepwiseCircadianBedtimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV3UsersSleepwiseCircadianBedtimeDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CircadianBedtime
}

// Status returns HTTPResponse.Status
func (r GetV3UsersSleepwiseCircadianBedtimeDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV3UsersSleepwiseCircadianBedtimeDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	XML200       *User
}

// Status returns HTTPResponse.Status
func (r GetUserInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateActivityTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TransactionLocation
	XML201       *TransactionLocation
}

// Status returns HTTPResponse.Status
func (r CreateActivityTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateActivityTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityLog
	XML200       *ActivityLog
}

// Status returns HTTPResponse.Status
func (r ListActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitActivityTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CommitActivityTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitActivityTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivitySummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Activity
	XML200       *Activity
}

// Status returns HTTPResponse.Status
func (r GetActivitySummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivitySummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStepSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityStepSamples
	XML200       *ActivityStepSamples
}

// Status returns HTTPResponse.Status
func (r GetStepSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStepSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZoneSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityZoneSamples
	XML200       *ActivityZoneSamples
}

// Status returns HTTPResponse.Status
func (r GetZoneSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZoneSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExerciseTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TransactionLocation
	XML201       *TransactionLocation
}

// Status returns HTTPResponse.Status
func (r CreateExerciseTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExerciseTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExercisesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exercises
	XML200       *Exercises
}

// Status returns HTTPResponse.Status
func (r ListExercisesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExercisesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitExerciseTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CommitExerciseTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitExerciseTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExerciseSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exercise
	XML200       *Exercise
}

// Status returns HTTPResponse.Status
func (r GetExerciseSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExerciseSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetGpxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHeartRateZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Zones
	XML200       *Zones
}

// Status returns HTTPResponse.Status
func (r GetHeartRateZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHeartRateZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Samples
	XML200       *Samples
}

// Status returns HTTPResponse.Status
func (r GetAvailableSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sample
	XML200       *Sample
}

// Status returns HTTPResponse.Status
func (r GetSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTcxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTcxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTcxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePhysicalInfoTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TransactionLocation
	XML201       *TransactionLocation
}

// Status returns HTTPResponse.Status
func (r CreatePhysicalInfoTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePhysicalInfoTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPhysicalInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PhysicalInformations
	XML200       *PhysicalInformations
}

// Status returns HTTPResponse.Status
func (r ListPhysicalInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhysicalInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitPhysicalInfoTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CommitPhysicalInfoTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitPhysicalInfoTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PhysicalInformation
	XML200       *PhysicalInformation
}

// Status returns HTTPResponse.Status
func (r GetPhysicalInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInfo
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedWebhook
	JSON400      *Error
	JSON409      *Error
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3WebhooksActivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostV3WebhooksActivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3WebhooksActivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3WebhooksDeactivateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostV3WebhooksDeactivateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3WebhooksDeactivateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInfo
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListExercisesWithoutTransactionWithResponse request returning *ListExercisesWithoutTransactionResponse
func (c *ClientWithResponses) ListExercisesWithoutTransactionWithResponse(ctx context.Context, params *ListExercisesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*ListExercisesWithoutTransactionResponse, error) {
	rsp, err := c.ListExercisesWithoutTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExercisesWithoutTransactionResponse(rsp)
}

// GetExerciseWithoutTransactionWithResponse request returning *GetExerciseWithoutTransactionResponse
func (c *ClientWithResponses) GetExerciseWithoutTransactionWithResponse(ctx context.Context, exerciseId string, params *GetExerciseWithoutTransactionParams, reqEditors ...RequestEditorFn) (*GetExerciseWithoutTransactionResponse, error) {
	rsp, err := c.GetExerciseWithoutTransaction(ctx, exerciseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExerciseWithoutTransactionResponse(rsp)
}

// GetExerciseFitWithoutTransactionWithResponse request returning *GetExerciseFitWithoutTransactionResponse
func (c *ClientWithResponses) GetExerciseFitWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseFitWithoutTransactionResponse, error) {
	rsp, err := c.GetExerciseFitWithoutTransaction(ctx, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExerciseFitWithoutTransactionResponse(rsp)
}

// GetExerciseGpxWithoutTransactionWithResponse request returning *GetExerciseGpxWithoutTransactionResponse
func (c *ClientWithResponses) GetExerciseGpxWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseGpxWithoutTransactionResponse, error) {
	rsp, err := c.GetExerciseGpxWithoutTransaction(ctx, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExerciseGpxWithoutTransactionResponse(rsp)
}

// GetExerciseTcxWithoutTransactionWithResponse request returning *GetExerciseTcxWithoutTransactionResponse
func (c *ClientWithResponses) GetExerciseTcxWithoutTransactionWithResponse(ctx context.Context, exerciseId string, reqEditors ...RequestEditorFn) (*GetExerciseTcxWithoutTransactionResponse, error) {
	rsp, err := c.GetExerciseTcxWithoutTransaction(ctx, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExerciseTcxWithoutTransactionResponse(rsp)
}

// ListWithResponse request returning *ListResponse
func (c *ClientWithResponses) ListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.List(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResponse(rsp)
}

// RegisterUserWithBodyWithResponse request with arbitrary body returning *RegisterUserResponse
func (c *ClientWithResponses) RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

func (c *ClientWithResponses) RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

// ListActivitiesWithoutTransactionWithResponse request returning *ListActivitiesWithoutTransactionResponse
func (c *ClientWithResponses) ListActivitiesWithoutTransactionWithResponse(ctx context.Context, params *ListActivitiesWithoutTransactionParams, reqEditors ...RequestEditorFn) (*ListActivitiesWithoutTransactionResponse, error) {
	rsp, err := c.ListActivitiesWithoutTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivitiesWithoutTransactionResponse(rsp)
}

// ListActivitiesWithoutTransactionByDateRangeWithResponse request returning *ListActivitiesWithoutTransactionByDateRangeResponse
func (c *ClientWithResponses) ListActivitiesWithoutTransactionByDateRangeWithResponse(ctx context.Context, params *ListActivitiesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*ListActivitiesWithoutTransactionByDateRangeResponse, error) {
	rsp, err := c.ListActivitiesWithoutTransactionByDateRange(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivitiesWithoutTransactionByDateRangeResponse(rsp)
}

// ListActivitySamplesWithoutTransactionWithResponse request returning *ListActivitySamplesWithoutTransactionResponse
func (c *ClientWithResponses) ListActivitySamplesWithoutTransactionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListActivitySamplesWithoutTransactionResponse, error) {
	rsp, err := c.ListActivitySamplesWithoutTransaction(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivitySamplesWithoutTransactionResponse(rsp)
}

// ListActivitySamplesWithoutTransactionByDateRangeWithResponse request returning *ListActivitySamplesWithoutTransactionByDateRangeResponse
func (c *ClientWithResponses) ListActivitySamplesWithoutTransactionByDateRangeWithResponse(ctx context.Context, params *ListActivitySamplesWithoutTransactionByDateRangeParams, reqEditors ...RequestEditorFn) (*ListActivitySamplesWithoutTransactionByDateRangeResponse, error) {
	rsp, err := c.ListActivitySamplesWithoutTransactionByDateRange(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivitySamplesWithoutTransactionByDateRangeResponse(rsp)
}

// GetActivitySamplesWithoutTransactionWithResponse request returning *GetActivitySamplesWithoutTransactionResponse
func (c *ClientWithResponses) GetActivitySamplesWithoutTransactionWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetActivitySamplesWithoutTransactionResponse, error) {
	rsp, err := c.GetActivitySamplesWithoutTransaction(ctx, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitySamplesWithoutTransactionResponse(rsp)
}

// GetActivityWithoutTransactionWithResponse request returning *GetActivityWithoutTransactionResponse
func (c *ClientWithResponses) GetActivityWithoutTransactionWithResponse(ctx context.Context, date openapi_types.Date, params *GetActivityWithoutTransactionParams, reqEditors ...RequestEditorFn) (*GetActivityWithoutTransactionResponse, error) {
	rsp, err := c.GetActivityWithoutTransaction(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityWithoutTransactionResponse(rsp)
}

// GetV3UsersBiosensingBodytemperatureWithResponse request returning *GetV3UsersBiosensingBodytemperatureResponse
func (c *ClientWithResponses) GetV3UsersBiosensingBodytemperatureWithResponse(ctx context.Context, params *GetV3UsersBiosensingBodytemperatureParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingBodytemperatureResponse, error) {
	rsp, err := c.GetV3UsersBiosensingBodytemperature(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersBiosensingBodytemperatureResponse(rsp)
}

// GetV3UsersBiosensingEcgWithResponse request returning *GetV3UsersBiosensingEcgResponse
func (c *ClientWithResponses) GetV3UsersBiosensingEcgWithResponse(ctx context.Context, params *GetV3UsersBiosensingEcgParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingEcgResponse, error) {
	rsp, err := c.GetV3UsersBiosensingEcg(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersBiosensingEcgResponse(rsp)
}

// GetV3UsersBiosensingSkincontactsWithResponse request returning *GetV3UsersBiosensingSkincontactsResponse
func (c *ClientWithResponses) GetV3UsersBiosensingSkincontactsWithResponse(ctx context.Context, params *GetV3UsersBiosensingSkincontactsParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSkincontactsResponse, error) {
	rsp, err := c.GetV3UsersBiosensingSkincontacts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersBiosensingSkincontactsResponse(rsp)
}

// GetV3UsersBiosensingSkintemperatureWithResponse request returning *GetV3UsersBiosensingSkintemperatureResponse
func (c *ClientWithResponses) GetV3UsersBiosensingSkintemperatureWithResponse(ctx context.Context, params *GetV3UsersBiosensingSkintemperatureParams, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSkintemperatureResponse, error) {
	rsp, err := c.GetV3UsersBiosensingSkintemperature(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersBiosensingSkintemperatureResponse(rsp)
}

// GetV3UsersBiosensingSpo2WithResponse request returning *GetV3UsersBiosensingSpo2Response
func (c *ClientWithResponses) GetV3UsersBiosensingSpo2WithResponse(ctx context.Context, params *GetV3UsersBiosensingSpo2Params, reqEditors ...RequestEditorFn) (*GetV3UsersBiosensingSpo2Response, error) {
	rsp, err := c.GetV3UsersBiosensingSpo2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersBiosensingSpo2Response(rsp)
}

// GetV3UsersCardioLoadWithResponse request returning *GetV3UsersCardioLoadResponse
func (c *ClientWithResponses) GetV3UsersCardioLoadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadResponse, error) {
	rsp, err := c.GetV3UsersCardioLoad(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersCardioLoadResponse(rsp)
}

// GetCardioLoadByDateRangeWithResponse request returning *GetCardioLoadByDateRangeResponse
func (c *ClientWithResponses) GetCardioLoadByDateRangeWithResponse(ctx context.Context, params *GetCardioLoadByDateRangeParams, reqEditors ...RequestEditorFn) (*GetCardioLoadByDateRangeResponse, error) {
	rsp, err := c.GetCardioLoadByDateRange(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCardioLoadByDateRangeResponse(rsp)
}

// GetV3UsersCardioLoadPeriodDaysDaysWithResponse request returning *GetV3UsersCardioLoadPeriodDaysDaysResponse
func (c *ClientWithResponses) GetV3UsersCardioLoadPeriodDaysDaysWithResponse(ctx context.Context, days int, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadPeriodDaysDaysResponse, error) {
	rsp, err := c.GetV3UsersCardioLoadPeriodDaysDays(ctx, days, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersCardioLoadPeriodDaysDaysResponse(rsp)
}

// GetV3UsersCardioLoadPeriodMonthsMonthsWithResponse request returning *GetV3UsersCardioLoadPeriodMonthsMonthsResponse
func (c *ClientWithResponses) GetV3UsersCardioLoadPeriodMonthsMonthsWithResponse(ctx context.Context, months int, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadPeriodMonthsMonthsResponse, error) {
	rsp, err := c.GetV3UsersCardioLoadPeriodMonthsMonths(ctx, months, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersCardioLoadPeriodMonthsMonthsResponse(rsp)
}

// GetV3UsersCardioLoadDateWithResponse request returning *GetV3UsersCardioLoadDateResponse
func (c *ClientWithResponses) GetV3UsersCardioLoadDateWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetV3UsersCardioLoadDateResponse, error) {
	rsp, err := c.GetV3UsersCardioLoadDate(ctx, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersCardioLoadDateResponse(rsp)
}

// GetV3UsersContinuousHeartRateWithResponse request returning *GetV3UsersContinuousHeartRateResponse
func (c *ClientWithResponses) GetV3UsersContinuousHeartRateWithResponse(ctx context.Context, params *GetV3UsersContinuousHeartRateParams, reqEditors ...RequestEditorFn) (*GetV3UsersContinuousHeartRateResponse, error) {
	rsp, err := c.GetV3UsersContinuousHeartRate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersContinuousHeartRateResponse(rsp)
}

// GetV3UsersContinuousHeartRateDateWithResponse request returning *GetV3UsersContinuousHeartRateDateResponse
func (c *ClientWithResponses) GetV3UsersContinuousHeartRateDateWithResponse(ctx context.Context, date openapi_types.Date, reqEditors ...RequestEditorFn) (*GetV3UsersContinuousHeartRateDateResponse, error) {
	rsp, err := c.GetV3UsersContinuousHeartRateDate(ctx, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersContinuousHeartRateDateResponse(rsp)
}

// ListNightlyRechargeWithResponse request returning *ListNightlyRechargeResponse
func (c *ClientWithResponses) ListNightlyRechargeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNightlyRechargeResponse, error) {
	rsp, err := c.ListNightlyRecharge(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNightlyRechargeResponse(rsp)
}

// GetV3UsersNightlyRechargeDateWithResponse request returning *GetV3UsersNightlyRechargeDateResponse
func (c *ClientWithResponses) GetV3UsersNightlyRechargeDateWithResponse(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*GetV3UsersNightlyRechargeDateResponse, error) {
	rsp, err := c.GetV3UsersNightlyRechargeDate(ctx, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersNightlyRechargeDateResponse(rsp)
}

// ListNightsWithResponse request returning *ListNightsResponse
func (c *ClientWithResponses) ListNightsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNightsResponse, error) {
	rsp, err := c.ListNights(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNightsResponse(rsp)
}

// GetV3UsersSleepAvailableWithResponse request returning *GetV3UsersSleepAvailableResponse
func (c *ClientWithResponses) GetV3UsersSleepAvailableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepAvailableResponse, error) {
	rsp, err := c.GetV3UsersSleepAvailable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepAvailableResponse(rsp)
}

// GetV3UsersSleepDateWithResponse request returning *GetV3UsersSleepDateResponse
func (c *ClientWithResponses) GetV3UsersSleepDateWithResponse(ctx context.Context, date string, reqEditors ...RequestEditorFn) (*GetV3UsersSleepDateResponse, error) {
	rsp, err := c.GetV3UsersSleepDate(ctx, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepDateResponse(rsp)
}

// GetV3UsersSleepwiseAlertnessWithResponse request returning *GetV3UsersSleepwiseAlertnessResponse
func (c *ClientWithResponses) GetV3UsersSleepwiseAlertnessWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseAlertnessResponse, error) {
	rsp, err := c.GetV3UsersSleepwiseAlertness(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepwiseAlertnessResponse(rsp)
}

// GetV3UsersSleepwiseAlertnessDateWithResponse request returning *GetV3UsersSleepwiseAlertnessDateResponse
func (c *ClientWithResponses) GetV3UsersSleepwiseAlertnessDateWithResponse(ctx context.Context, params *GetV3UsersSleepwiseAlertnessDateParams, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseAlertnessDateResponse, error) {
	rsp, err := c.GetV3UsersSleepwiseAlertnessDate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepwiseAlertnessDateResponse(rsp)
}

// GetV3UsersSleepwiseCircadianBedtimeWithResponse request returning *GetV3UsersSleepwiseCircadianBedtimeResponse
func (c *ClientWithResponses) GetV3UsersSleepwiseCircadianBedtimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseCircadianBedtimeResponse, error) {
	rsp, err := c.GetV3UsersSleepwiseCircadianBedtime(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepwiseCircadianBedtimeResponse(rsp)
}

// GetV3UsersSleepwiseCircadianBedtimeDateWithResponse request returning *GetV3UsersSleepwiseCircadianBedtimeDateResponse
func (c *ClientWithResponses) GetV3UsersSleepwiseCircadianBedtimeDateWithResponse(ctx context.Context, params *GetV3UsersSleepwiseCircadianBedtimeDateParams, reqEditors ...RequestEditorFn) (*GetV3UsersSleepwiseCircadianBedtimeDateResponse, error) {
	rsp, err := c.GetV3UsersSleepwiseCircadianBedtimeDate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetV3UsersSleepwiseCircadianBedtimeDateResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserInformationWithResponse request returning *GetUserInformationResponse
func (c *ClientWithResponses) GetUserInformationWithResponse(ctx context.Context, userId int64, reqEditors ...RequestEditorFn) (*GetUserInformationResponse, error) {
	rsp, err := c.GetUserInformation(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInformationResponse(rsp)
}

// CreateActivityTransactionWithResponse request returning *CreateActivityTransactionResponse
func (c *ClientWithResponses) CreateActivityTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreateActivityTransactionResponse, error) {
	rsp, err := c.CreateActivityTransaction(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateActivityTransactionResponse(rsp)
}

// ListActivitiesWithResponse request returning *ListActivitiesResponse
func (c *ClientWithResponses) ListActivitiesWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListActivitiesResponse, error) {
	rsp, err := c.ListActivities(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivitiesResponse(rsp)
}

// CommitActivityTransactionWithResponse request returning *CommitActivityTransactionResponse
func (c *ClientWithResponses) CommitActivityTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitActivityTransactionResponse, error) {
	rsp, err := c.CommitActivityTransaction(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitActivityTransactionResponse(rsp)
}

// GetActivitySummaryWithResponse request returning *GetActivitySummaryResponse
func (c *ClientWithResponses) GetActivitySummaryWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetActivitySummaryResponse, error) {
	rsp, err := c.GetActivitySummary(ctx, userId, transactionId, activityId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivitySummaryResponse(rsp)
}

// GetStepSamplesWithResponse request returning *GetStepSamplesResponse
func (c *ClientWithResponses) GetStepSamplesWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetStepSamplesResponse, error) {
	rsp, err := c.GetStepSamples(ctx, userId, transactionId, activityId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStepSamplesResponse(rsp)
}

// GetZoneSamplesWithResponse request returning *GetZoneSamplesResponse
func (c *ClientWithResponses) GetZoneSamplesWithResponse(ctx context.Context, userId int, transactionId int, activityId int, reqEditors ...RequestEditorFn) (*GetZoneSamplesResponse, error) {
	rsp, err := c.GetZoneSamples(ctx, userId, transactionId, activityId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZoneSamplesResponse(rsp)
}

// CreateExerciseTransactionWithResponse request returning *CreateExerciseTransactionResponse
func (c *ClientWithResponses) CreateExerciseTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreateExerciseTransactionResponse, error) {
	rsp, err := c.CreateExerciseTransaction(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExerciseTransactionResponse(rsp)
}

// ListExercisesWithResponse request returning *ListExercisesResponse
func (c *ClientWithResponses) ListExercisesWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListExercisesResponse, error) {
	rsp, err := c.ListExercises(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExercisesResponse(rsp)
}

// CommitExerciseTransactionWithResponse request returning *CommitExerciseTransactionResponse
func (c *ClientWithResponses) CommitExerciseTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitExerciseTransactionResponse, error) {
	rsp, err := c.CommitExerciseTransaction(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitExerciseTransactionResponse(rsp)
}

// GetExerciseSummaryWithResponse request returning *GetExerciseSummaryResponse
func (c *ClientWithResponses) GetExerciseSummaryWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetExerciseSummaryResponse, error) {
	rsp, err := c.GetExerciseSummary(ctx, userId, transactionId, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExerciseSummaryResponse(rsp)
}

// GetFitWithResponse request returning *GetFitResponse
func (c *ClientWithResponses) GetFitWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetFitResponse, error) {
	rsp, err := c.GetFit(ctx, userId, transactionId, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFitResponse(rsp)
}

// GetGpxWithResponse request returning *GetGpxResponse
func (c *ClientWithResponses) GetGpxWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, params *GetGpxParams, reqEditors ...RequestEditorFn) (*GetGpxResponse, error) {
	rsp, err := c.GetGpx(ctx, userId, transactionId, exerciseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpxResponse(rsp)
}

// GetHeartRateZonesWithResponse request returning *GetHeartRateZonesResponse
func (c *ClientWithResponses) GetHeartRateZonesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetHeartRateZonesResponse, error) {
	rsp, err := c.GetHeartRateZones(ctx, userId, transactionId, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHeartRateZonesResponse(rsp)
}

// GetAvailableSamplesWithResponse request returning *GetAvailableSamplesResponse
func (c *ClientWithResponses) GetAvailableSamplesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetAvailableSamplesResponse, error) {
	rsp, err := c.GetAvailableSamples(ctx, userId, transactionId, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableSamplesResponse(rsp)
}

// GetSamplesWithResponse request returning *GetSamplesResponse
func (c *ClientWithResponses) GetSamplesWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, typeId []byte, reqEditors ...RequestEditorFn) (*GetSamplesResponse, error) {
	rsp, err := c.GetSamples(ctx, userId, transactionId, exerciseId, typeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamplesResponse(rsp)
}

// GetTcxWithResponse request returning *GetTcxResponse
func (c *ClientWithResponses) GetTcxWithResponse(ctx context.Context, userId int, transactionId int, exerciseId int, reqEditors ...RequestEditorFn) (*GetTcxResponse, error) {
	rsp, err := c.GetTcx(ctx, userId, transactionId, exerciseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTcxResponse(rsp)
}

// CreatePhysicalInfoTransactionWithResponse request returning *CreatePhysicalInfoTransactionResponse
func (c *ClientWithResponses) CreatePhysicalInfoTransactionWithResponse(ctx context.Context, userId int, reqEditors ...RequestEditorFn) (*CreatePhysicalInfoTransactionResponse, error) {
	rsp, err := c.CreatePhysicalInfoTransaction(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePhysicalInfoTransactionResponse(rsp)
}

// ListPhysicalInfosWithResponse request returning *ListPhysicalInfosResponse
func (c *ClientWithResponses) ListPhysicalInfosWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*ListPhysicalInfosResponse, error) {
	rsp, err := c.ListPhysicalInfos(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPhysicalInfosResponse(rsp)
}

// CommitPhysicalInfoTransactionWithResponse request returning *CommitPhysicalInfoTransactionResponse
func (c *ClientWithResponses) CommitPhysicalInfoTransactionWithResponse(ctx context.Context, userId int, transactionId int64, reqEditors ...RequestEditorFn) (*CommitPhysicalInfoTransactionResponse, error) {
	rsp, err := c.CommitPhysicalInfoTransaction(ctx, userId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitPhysicalInfoTransactionResponse(rsp)
}

// GetPhysicalInfoWithResponse request returning *GetPhysicalInfoResponse
func (c *ClientWithResponses) GetPhysicalInfoWithResponse(ctx context.Context, userId int, transactionId int, physicalInfoId int, reqEditors ...RequestEditorFn) (*GetPhysicalInfoResponse, error) {
	rsp, err := c.GetPhysicalInfo(ctx, userId, transactionId, physicalInfoId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalInfoResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// CreateWebhookWithBodyWithResponse request with arbitrary body returning *CreateWebhookResponse
func (c *ClientWithResponses) CreateWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookWithResponse(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

// PostV3WebhooksActivateWithResponse request returning *PostV3WebhooksActivateResponse
func (c *ClientWithResponses) PostV3WebhooksActivateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostV3WebhooksActivateResponse, error) {
	rsp, err := c.PostV3WebhooksActivate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3WebhooksActivateResponse(rsp)
}

// PostV3WebhooksDeactivateWithResponse request returning *PostV3WebhooksDeactivateResponse
func (c *ClientWithResponses) PostV3WebhooksDeactivateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostV3WebhooksDeactivateResponse, error) {
	rsp, err := c.PostV3WebhooksDeactivate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3WebhooksDeactivateResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// UpdateWebhookWithBodyWithResponse request with arbitrary body returning *UpdateWebhookResponse
func (c *ClientWithResponses) UpdateWebhookWithBodyWithResponse(ctx context.Context, webhookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithBody(ctx, webhookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithResponse(ctx context.Context, webhookId string, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhook(ctx, webhookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

// ParseListExercisesWithoutTransactionResponse parses an HTTP response from a ListExercisesWithoutTransactionWithResponse call
func ParseListExercisesWithoutTransactionResponse(rsp *http.Response) (*ListExercisesWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExercisesWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExercisesHashId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExerciseWithoutTransactionResponse parses an HTTP response from a GetExerciseWithoutTransactionWithResponse call
func ParseGetExerciseWithoutTransactionResponse(rsp *http.Response) (*GetExerciseWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExerciseWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExerciseHashId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExerciseFitWithoutTransactionResponse parses an HTTP response from a GetExerciseFitWithoutTransactionWithResponse call
func ParseGetExerciseFitWithoutTransactionResponse(rsp *http.Response) (*GetExerciseFitWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExerciseFitWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExerciseGpxWithoutTransactionResponse parses an HTTP response from a GetExerciseGpxWithoutTransactionWithResponse call
func ParseGetExerciseGpxWithoutTransactionResponse(rsp *http.Response) (*GetExerciseGpxWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExerciseGpxWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExerciseTcxWithoutTransactionResponse parses an HTTP response from a GetExerciseTcxWithoutTransactionWithResponse call
func ParseGetExerciseTcxWithoutTransactionResponse(rsp *http.Response) (*GetExerciseTcxWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExerciseTcxWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListResponse parses an HTTP response from a ListWithResponse call
func ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableUserDatas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest AvailableUserDatas
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseRegisterUserResponse parses an HTTP response from a RegisterUserWithResponse call
func ParseRegisterUserResponse(rsp *http.Response) (*RegisterUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest User
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseListActivitiesWithoutTransactionResponse parses an HTTP response from a ListActivitiesWithoutTransactionWithResponse call
func ParseListActivitiesWithoutTransactionResponse(rsp *http.Response) (*ListActivitiesWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivitiesWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfActivitySummaryWithAllSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListActivitiesWithoutTransactionByDateRangeResponse parses an HTTP response from a ListActivitiesWithoutTransactionByDateRangeWithResponse call
func ParseListActivitiesWithoutTransactionByDateRangeResponse(rsp *http.Response) (*ListActivitiesWithoutTransactionByDateRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivitiesWithoutTransactionByDateRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfActivitySummaryWithAllSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListActivitySamplesWithoutTransactionResponse parses an HTTP response from a ListActivitySamplesWithoutTransactionWithResponse call
func ParseListActivitySamplesWithoutTransactionResponse(rsp *http.Response) (*ListActivitySamplesWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivitySamplesWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfActivityDayWithSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListActivitySamplesWithoutTransactionByDateRangeResponse parses an HTTP response from a ListActivitySamplesWithoutTransactionByDateRangeWithResponse call
func ParseListActivitySamplesWithoutTransactionByDateRangeResponse(rsp *http.Response) (*ListActivitySamplesWithoutTransactionByDateRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivitySamplesWithoutTransactionByDateRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayOfActivityDayWithSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivitySamplesWithoutTransactionResponse parses an HTTP response from a GetActivitySamplesWithoutTransactionWithResponse call
func ParseGetActivitySamplesWithoutTransactionResponse(rsp *http.Response) (*GetActivitySamplesWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitySamplesWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityDayWithSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActivityWithoutTransactionResponse parses an HTTP response from a GetActivityWithoutTransactionWithResponse call
func ParseGetActivityWithoutTransactionResponse(rsp *http.Response) (*GetActivityWithoutTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityWithoutTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivitySummaryWithAllSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersBiosensingBodytemperatureResponse parses an HTTP response from a GetV3UsersBiosensingBodytemperatureWithResponse call
func ParseGetV3UsersBiosensingBodytemperatureResponse(rsp *http.Response) (*GetV3UsersBiosensingBodytemperatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersBiosensingBodytemperatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BodyTemperaturePeriod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersBiosensingEcgResponse parses an HTTP response from a GetV3UsersBiosensingEcgWithResponse call
func ParseGetV3UsersBiosensingEcgResponse(rsp *http.Response) (*GetV3UsersBiosensingEcgResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersBiosensingEcgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EcgTestResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersBiosensingSkincontactsResponse parses an HTTP response from a GetV3UsersBiosensingSkincontactsWithResponse call
func ParseGetV3UsersBiosensingSkincontactsResponse(rsp *http.Response) (*GetV3UsersBiosensingSkincontactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersBiosensingSkincontactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SkinContactPeriod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersBiosensingSkintemperatureResponse parses an HTTP response from a GetV3UsersBiosensingSkintemperatureWithResponse call
func ParseGetV3UsersBiosensingSkintemperatureResponse(rsp *http.Response) (*GetV3UsersBiosensingSkintemperatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersBiosensingSkintemperatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SkinTemperature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersBiosensingSpo2Response parses an HTTP response from a GetV3UsersBiosensingSpo2WithResponse call
func ParseGetV3UsersBiosensingSpo2Response(rsp *http.Response) (*GetV3UsersBiosensingSpo2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersBiosensingSpo2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Spo2TestResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersCardioLoadResponse parses an HTTP response from a GetV3UsersCardioLoadWithResponse call
func ParseGetV3UsersCardioLoadResponse(rsp *http.Response) (*GetV3UsersCardioLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersCardioLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardioLoadSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCardioLoadByDateRangeResponse parses an HTTP response from a GetCardioLoadByDateRangeWithResponse call
func ParseGetCardioLoadByDateRangeResponse(rsp *http.Response) (*GetCardioLoadByDateRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCardioLoadByDateRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardioLoadSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersCardioLoadPeriodDaysDaysResponse parses an HTTP response from a GetV3UsersCardioLoadPeriodDaysDaysWithResponse call
func ParseGetV3UsersCardioLoadPeriodDaysDaysResponse(rsp *http.Response) (*GetV3UsersCardioLoadPeriodDaysDaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersCardioLoadPeriodDaysDaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardioLoadSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersCardioLoadPeriodMonthsMonthsResponse parses an HTTP response from a GetV3UsersCardioLoadPeriodMonthsMonthsWithResponse call
func ParseGetV3UsersCardioLoadPeriodMonthsMonthsResponse(rsp *http.Response) (*GetV3UsersCardioLoadPeriodMonthsMonthsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersCardioLoadPeriodMonthsMonthsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardioLoadSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersCardioLoadDateResponse parses an HTTP response from a GetV3UsersCardioLoadDateWithResponse call
func ParseGetV3UsersCardioLoadDateResponse(rsp *http.Response) (*GetV3UsersCardioLoadDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersCardioLoadDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CardioLoadSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersContinuousHeartRateResponse parses an HTTP response from a GetV3UsersContinuousHeartRateWithResponse call
func ParseGetV3UsersContinuousHeartRateResponse(rsp *http.Response) (*GetV3UsersContinuousHeartRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersContinuousHeartRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContinuousHeartrate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersContinuousHeartRateDateResponse parses an HTTP response from a GetV3UsersContinuousHeartRateDateWithResponse call
func ParseGetV3UsersContinuousHeartRateDateResponse(rsp *http.Response) (*GetV3UsersContinuousHeartRateDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersContinuousHeartRateDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContinuousHeartrate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNightlyRechargeResponse parses an HTTP response from a ListNightlyRechargeWithResponse call
func ParseListNightlyRechargeResponse(rsp *http.Response) (*ListNightlyRechargeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNightlyRechargeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Recharges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersNightlyRechargeDateResponse parses an HTTP response from a GetV3UsersNightlyRechargeDateWithResponse call
func ParseGetV3UsersNightlyRechargeDateResponse(rsp *http.Response) (*GetV3UsersNightlyRechargeDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersNightlyRechargeDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NightlyRecharge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNightsResponse parses an HTTP response from a ListNightsWithResponse call
func ParseListNightsResponse(rsp *http.Response) (*ListNightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nights
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepAvailableResponse parses an HTTP response from a GetV3UsersSleepAvailableWithResponse call
func ParseGetV3UsersSleepAvailableResponse(rsp *http.Response) (*GetV3UsersSleepAvailableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepAvailableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AvailableSleeps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepDateResponse parses an HTTP response from a GetV3UsersSleepDateWithResponse call
func ParseGetV3UsersSleepDateResponse(rsp *http.Response) (*GetV3UsersSleepDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sleep
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepwiseAlertnessResponse parses an HTTP response from a GetV3UsersSleepwiseAlertnessWithResponse call
func ParseGetV3UsersSleepwiseAlertnessResponse(rsp *http.Response) (*GetV3UsersSleepwiseAlertnessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepwiseAlertnessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alertness
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepwiseAlertnessDateResponse parses an HTTP response from a GetV3UsersSleepwiseAlertnessDateWithResponse call
func ParseGetV3UsersSleepwiseAlertnessDateResponse(rsp *http.Response) (*GetV3UsersSleepwiseAlertnessDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepwiseAlertnessDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alertness
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepwiseCircadianBedtimeResponse parses an HTTP response from a GetV3UsersSleepwiseCircadianBedtimeWithResponse call
func ParseGetV3UsersSleepwiseCircadianBedtimeResponse(rsp *http.Response) (*GetV3UsersSleepwiseCircadianBedtimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepwiseCircadianBedtimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CircadianBedtime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV3UsersSleepwiseCircadianBedtimeDateResponse parses an HTTP response from a GetV3UsersSleepwiseCircadianBedtimeDateWithResponse call
func ParseGetV3UsersSleepwiseCircadianBedtimeDateResponse(rsp *http.Response) (*GetV3UsersSleepwiseCircadianBedtimeDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV3UsersSleepwiseCircadianBedtimeDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CircadianBedtime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserInformationResponse parses an HTTP response from a GetUserInformationWithResponse call
func ParseGetUserInformationResponse(rsp *http.Response) (*GetUserInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest User
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateActivityTransactionResponse parses an HTTP response from a CreateActivityTransactionWithResponse call
func ParseCreateActivityTransactionResponse(rsp *http.Response) (*CreateActivityTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateActivityTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML201 = &dest

	}

	return response, nil
}

// ParseListActivitiesResponse parses an HTTP response from a ListActivitiesWithResponse call
func ParseListActivitiesResponse(rsp *http.Response) (*ListActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest ActivityLog
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCommitActivityTransactionResponse parses an HTTP response from a CommitActivityTransactionWithResponse call
func ParseCommitActivityTransactionResponse(rsp *http.Response) (*CommitActivityTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitActivityTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetActivitySummaryResponse parses an HTTP response from a GetActivitySummaryWithResponse call
func ParseGetActivitySummaryResponse(rsp *http.Response) (*GetActivitySummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivitySummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Activity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Activity
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetStepSamplesResponse parses an HTTP response from a GetStepSamplesWithResponse call
func ParseGetStepSamplesResponse(rsp *http.Response) (*GetStepSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStepSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityStepSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest ActivityStepSamples
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetZoneSamplesResponse parses an HTTP response from a GetZoneSamplesWithResponse call
func ParseGetZoneSamplesResponse(rsp *http.Response) (*GetZoneSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZoneSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityZoneSamples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest ActivityZoneSamples
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCreateExerciseTransactionResponse parses an HTTP response from a CreateExerciseTransactionWithResponse call
func ParseCreateExerciseTransactionResponse(rsp *http.Response) (*CreateExerciseTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExerciseTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML201 = &dest

	}

	return response, nil
}

// ParseListExercisesResponse parses an HTTP response from a ListExercisesWithResponse call
func ParseListExercisesResponse(rsp *http.Response) (*ListExercisesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExercisesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exercises
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Exercises
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCommitExerciseTransactionResponse parses an HTTP response from a CommitExerciseTransactionWithResponse call
func ParseCommitExerciseTransactionResponse(rsp *http.Response) (*CommitExerciseTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitExerciseTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExerciseSummaryResponse parses an HTTP response from a GetExerciseSummaryWithResponse call
func ParseGetExerciseSummaryResponse(rsp *http.Response) (*GetExerciseSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExerciseSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exercise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Exercise
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetFitResponse parses an HTTP response from a GetFitWithResponse call
func ParseGetFitResponse(rsp *http.Response) (*GetFitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGpxResponse parses an HTTP response from a GetGpxWithResponse call
func ParseGetGpxResponse(rsp *http.Response) (*GetGpxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHeartRateZonesResponse parses an HTTP response from a GetHeartRateZonesWithResponse call
func ParseGetHeartRateZonesResponse(rsp *http.Response) (*GetHeartRateZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHeartRateZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Zones
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Zones
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetAvailableSamplesResponse parses an HTTP response from a GetAvailableSamplesWithResponse call
func ParseGetAvailableSamplesResponse(rsp *http.Response) (*GetAvailableSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Samples
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Samples
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetSamplesResponse parses an HTTP response from a GetSamplesWithResponse call
func ParseGetSamplesResponse(rsp *http.Response) (*GetSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sample
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Sample
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetTcxResponse parses an HTTP response from a GetTcxWithResponse call
func ParseGetTcxResponse(rsp *http.Response) (*GetTcxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTcxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePhysicalInfoTransactionResponse parses an HTTP response from a CreatePhysicalInfoTransactionWithResponse call
func ParseCreatePhysicalInfoTransactionResponse(rsp *http.Response) (*CreatePhysicalInfoTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePhysicalInfoTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 201:
		var dest TransactionLocation
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML201 = &dest

	}

	return response, nil
}

// ParseListPhysicalInfosResponse parses an HTTP response from a ListPhysicalInfosWithResponse call
func ParseListPhysicalInfosResponse(rsp *http.Response) (*ListPhysicalInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPhysicalInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PhysicalInformations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest PhysicalInformations
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseCommitPhysicalInfoTransactionResponse parses an HTTP response from a CommitPhysicalInfoTransactionWithResponse call
func ParseCommitPhysicalInfoTransactionResponse(rsp *http.Response) (*CommitPhysicalInfoTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitPhysicalInfoTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPhysicalInfoResponse parses an HTTP response from a GetPhysicalInfoWithResponse call
func ParseGetPhysicalInfoResponse(rsp *http.Response) (*GetPhysicalInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PhysicalInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest PhysicalInformation
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWebhookResponse parses an HTTP response from a CreateWebhookWithResponse call
func ParseCreateWebhookResponse(rsp *http.Response) (*CreateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParsePostV3WebhooksActivateResponse parses an HTTP response from a PostV3WebhooksActivateWithResponse call
func ParsePostV3WebhooksActivateResponse(rsp *http.Response) (*PostV3WebhooksActivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3WebhooksActivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostV3WebhooksDeactivateResponse parses an HTTP response from a PostV3WebhooksDeactivateWithResponse call
func ParsePostV3WebhooksDeactivateResponse(rsp *http.Response) (*PostV3WebhooksDeactivateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3WebhooksDeactivateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookResponse parses an HTTP response from a UpdateWebhookWithResponse call
func ParseUpdateWebhookResponse(rsp *http.Response) (*UpdateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
